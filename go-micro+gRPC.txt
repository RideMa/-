微服务加RPC 云存储项目
每一个微服务，如果不需要直接对外通讯的话，就向注册中心注册一个微服务，告诉它我的名字，TTL，
然后注册RPC，注册过程是注册一个对象，这个对象有好些RCP定义的方法

别的微服务再调用这个微服务的时候，需要从注册中心拿到对应名字，在本地初始化微服务客户端，然后通过这些客户端，调用微服务
使用go-micro的时候，利用proto-micro-go就可以生成对应的方法，调用的时候直接用这些方法就可以，NewUserService(name, server.Client())这种

在db处理的时候，别的微服务同样是生成一个client向dbproxy发送RPC，但是由于代码进行了封装，所以是不需要在自己的代码中显式初始化
这个client的逻辑在db的client文件夹下，是以一个client的方式向dbproxy进行RPC调用，调用接口只有一个，但是具体逻辑的执行是通过传入方法字符串
然后用字符串对应其具体的处理函数，根据传过来的具体处理函数，来调用本地的函数，将结果返回，结果做了一个统一的封装
这样做RPC种类大大减少，因为DB这里要处理的逻辑很多，通过这种方式就可以把这些逻辑统一处理了，就不需要分别处理了
但是这样的问题就是RPC用起来没有RPC的感觉，不过通过在db这里加了client的封装，让这个问题解决了

如果需要向外界通信，则使用gin框架监听端口，自己处理这部分逻辑

总体来说，本来是用一个gateway来处理所有的请求，但是由于想让下载和上传的流量和这个流量分开，于是给下载和上传分别给一个端口，自己监听
这俩也是微服务的形式，不过暂时没有别的微服务调用他俩，他俩自己通过http请求服务外界。

go-micro和gRPC的结合非常方便，有一个编译器就可以，别的微服务要调用的时候，可以从go-micro就可以从编译出来的proto-micro的go文件里面，调用new方法创建客户端
自己注册gRPC的时候，生成一个对应名称的结构体，然后给他实现所有注册在proto文件里的方法，将其注册在micro里，就可以注册所有的RPC方法
如果RPC太多了，一个解决方案就是RPC只有一个，但是其根据参数不同调用不同的本地方法，将结果设置成interface，以二进制定义proto文件
这样的问题是其他微服务调用的时候不是RPc的感觉，这可以通过封装客户端的方式实现，可以给这个单一的RPC封装不同的函数，函数里面传入不同的参数
这样其他微服务调用的时候还是调用函数，但是，其函数底层是调用统一的RPC接口

