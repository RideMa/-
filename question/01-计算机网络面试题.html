<!DOCTYPE html>
<html>
 <head>
 </head>
 <body>
  <meta content="relax" name="paragraphSpacing"/>
  <blockquote class="lake-alert lake-alert-info">
   <p style="text-align: center">
    <strong>
     整理作者：蓦然                                     知识星球、公众号（同名）：旧时光大数据
    </strong>
   </p>
  </blockquote>
  <h3>
   OSI网络7层模型
  </h3>
  <p>
   可回答：1）OSI七层模型以及作用；2）计网的七层协议以及对应的一些常见的协议；3）什么是传输层（TCP/UDP）、网络层（IP）、物理层？4）物理层是干嘛的？数据链路层是干嘛的？
  </p>
  <p>
   问过的一些公司：Boss直聘北京(2022.10)，大连东软(2022.10)，京东(2022.09)，比亚迪(2022.09)，网易有道(2022.09)x2，同程旅行(2022.09)，元气森林(2022.09)x3，字节(2022.09)(2022.08)(2022.07)(2022.01)，哈啰(2022.09)，友塔游戏(2022.09)，美团(2022.08)x4，字节提前批(2022.08)，阿里巴巴菜鸟(2022.08)，OPPO提前批(2022.08)，第四范式(2022.08)，猿辅导(2022.08)x2，民生科技(2022.08)，翼支付(2022.08)，影石(2022.08)，兴业数金(2022.08)，同盾(2022.08)，华人运通(2022.03)，阿里Lazada(2021.12)，今日头条(2021.09)，YY直播(2021.09)，字节抖音(2021.08)，百度(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   OSI 参考模型将网络协议提供的服务分成 7 层（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），并定义每一层的服务内容，实现每一层服务的是协议，协议的具体内容是规则。上下层之间通过接口进行交互，同一层之间通过协议进行交互。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669816269889-55be979d-c556-4342-96b0-7ce7d36d20b0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    1、应用层
   </strong>
  </p>
  <p>
   OSI参考模型的第7层（最高层）。
   <strong>
    应用程序和网络之间的接口，直接向用户提供服务
   </strong>
   <span class="lake-fontsize-12">
    。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3，SMTP等。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669816980724-c96e3527-081d-4d52-8a00-a4e5caaa7a4a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   开心一刻：
  </p>
  <p>
   实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。
  </p>
  <p>
   <strong>
    2、表示层
   </strong>
  </p>
  <p>
   <strong>
    负责数据格式的互相转换，如编码、数据格式转换和加密解密等
   </strong>
   <span class="lake-fontsize-12">
    。保证一个系统应用层发出的信息可被另一系统的应用层读出。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669817128898-05cd4694-7770-4a34-b24e-87fd45fe7703.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   开心一刻：
  </p>
  <p>
   由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。
  </p>
  <p>
   <strong>
    3、会话层
   </strong>
  </p>
  <p>
   <strong>
    主要是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669817183452-2d4f9715-d653-4fa7-9d17-c8f0847af635.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   开心一刻：
  </p>
  <p>
   会话层的同事拿到表示层的同事转换后资料（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。
  </p>
  <p>
   <strong>
    4、传输层
   </strong>
  </p>
  <p>
   传输层建立了主机端到端的链接，
   <strong>
    为上层协议提供通信主机间的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669817868867-b980b898-6457-4db7-8f74-d07a5caa696b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP、UDP就是在这一层。端口号既是这里的“端”。
  </p>
  <p>
   开心一刻：
  </p>
  <p>
   传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。
  </p>
  <p>
   <strong>
    5、网络层
   </strong>
  </p>
  <p>
   <strong>
    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层
   </strong>
   <span class="lake-fontsize-12">
    。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669818060711-6ad71190-888d-47b3-84e3-c39f7bfbdaaa.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   开心一刻：
  </p>
  <p>
   网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。
  </p>
  <p>
   <strong>
    6、数据链路层
   </strong>
  </p>
  <p>
   负责物理层面上两个互连主机间的通信传输，将由0、1组成的比特流划分成数据帧传输给对端，即数据帧的生成与接收。通信传输实际上是通过物理的传输介质实现的。
   <strong>
    数据链路层的作用就是在这些通过传输介质互连的设备之间进行数据处理
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是
   <strong>
    网络层负责将整个数据发送给最终目标地址
   </strong>
   <span class="lake-fontsize-12">
    ， 而
   </span>
   <strong>
    数据链路层则只负责发送一个分段内的数据
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669818215631-2db8bac0-e4b5-4a21-abb2-4fc0d3746ef8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    7、物理层
   </strong>
  </p>
  <p>
   负责逻辑信号（比特流）与物理信号（电信号、光信号）之间的互相转换，通过传输介质为数据链路层提供物理连接。
  </p>
  <p>
   常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆，这些都是物理层的传输介质。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669818326020-72c7d2c6-b295-4655-9c16-37d4130dab7f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   开心一刻：
  </p>
  <p>
   快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。
  </p>
  <p>
   经典图
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/gif/12867669/1669819019473-e83c4042-40cc-4eb9-a37c-f23858a3f307.gif"/>
  </p>
  <h3>
   应用层，传输层，网络层，数据链路层都有哪些协议？它们都起到了什么作用？
  </h3>
  <p>
   问过的一些公司：万得(2022.10)，同程旅行(2022.09)，哈啰(2022.09)，科大讯飞(2022.08)，字节(2022.07)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、应用层
   </strong>
  </p>
  <p>
   常见协议及作用：
  </p>
  <p>
   HTTP 80：超文本传输协议，提供浏览网页服务
  </p>
  <p>
   Telnet 23：远程登陆协议，提供远程管理服务
  </p>
  <p>
   FTP 20、21：文件传输协议，提供互联网文件资源共享服务
  </p>
  <p>
   SMTP 25：简单邮件传输协议（发邮件），提供互联网电子邮件服务
  </p>
  <p>
   POP3 110：邮局协议（收邮件），提供互联网电子邮件服务
  </p>
  <p>
   TFTP 69(UDP)：简单文件传输协议，提供简单的文件传输服务
  </p>
  <p>
   <strong>
    2、传输层
   </strong>
  </p>
  <p>
   常见协议及作用：
  </p>
  <p>
   TCP（传输控制协议）：面向连接的网络协议。定义了两台计算机之间进行可靠的传输而交换的数据和确认信息的格式，以及计算机为了确保数据的正确到达而采取的措施。TCP最大的特点就是提供的是面向连接、可靠的字节流服务。
  </p>
  <p>
   UDP（用户报文协议）：无连接的网络协议。是一个简单的面向数据报的传输层协议。提供的是非面向连接的、不可靠的数据流传输。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
  </p>
  <p>
   <strong>
    3、网络层
   </strong>
  </p>
  <p>
   常见协议及作用：
  </p>
  <p>
   IP协议（Internet Protocol（网际互连协议））：是一个用于网络之间互连的协议。
  </p>
  <p>
   IP协议主要作用有：
  </p>
  <ul list="ub80faaff">
   <li fid="ufa7a224d">
    寻址与路由
   </li>
  </ul>
  <ul data-lake-indent="1" list="ub80faaff">
   <li fid="ufa7a224d">
    用IP地址来标识Internet的主机：在每个IP数据报中，都会携带源IP地址和目标IP地址来标识该IP数据报的源和目的主机。IP数据报在传输过程中，每个中间节点(IP 网关)还需要为其选择从源主机到目的主机的合适的转发路径(即路由)。IP协议可以根据路由选择协议提供的路由信息对IP数据报进行转发，直至抵达目的主机。
   </li>
   <li fid="ufa7a224d">
    IP地址和MAC地址的匹配。数据链路层使用MAC地址来发送数据帧，因此在实际发送IP报文时，还需要进行IP地址和MAC地址的匹配，由TCP/IP协议簇中的ARP（地址解析协议）协议完成。
   </li>
  </ul>
  <ul data-lake-indent="2" list="ub80faaff">
   <li fid="ufa7a224d">
    ARP协议（地址解析协议）：根据设备的IP地址来查询对应MAC地址的协议。主机通过ARP查询到MAC地址后，将在ARP缓存表中增加映射表项，即IP地址和MAC地址的映射表项。
   </li>
  </ul>
  <ul list="ub80faaff" start="2">
   <li fid="ufa7a224d">
    分段与重组
   </li>
  </ul>
  <ul data-lake-indent="1" list="ub80faaff">
   <li fid="ufa7a224d">
    IP报文通过不同类型的通信网络发送，IP报文的大小会受到这些网络所规定的最大传输单元（MTU）的限制。如果IP报文大小超过MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的IP报文。
   </li>
  </ul>
  <p>
   <strong>
    4、数据链路层
   </strong>
  </p>
  <p>
   常见协议及作用：
  </p>
  <p>
   Ethernet以太网协议：
   <span class="lake-fontsize-12">
    用于实现链路层的
   </span>
   <strong>
    数据传输和地址封装
   </strong>
  </p>
  <h3>
   讲讲TCP/IP四层模型
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    四层模型？具体讲讲传输层和网络层干嘛的？
   </span>
  </p>
  <p>
   问过的一些公司：快手(2022.08)，翼支付(2022.08)，美团(2022.08)，YY直播(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669821556629-4595087b-9fb9-48b2-b4d6-3ae3334f2a4f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    1、应用层
   </strong>
  </p>
  <p>
   应用层是最上层协议，我们直接接触到的就是应用层，我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
  </p>
  <p>
   所以，
   <strong>
    应用层只需要专注于为用户提供应用功能
   </strong>
   <span class="lake-fontsize-12">
    ，比如 HTTP、FTP、Telnet、DNS、SMTP等。
   </span>
  </p>
  <p>
   应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。
  </p>
  <p>
   而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。
  </p>
  <p>
   <strong>
    2、传输层
   </strong>
  </p>
  <p>
   应用层的数据包会传给传输层，
   <strong>
    传输层是为应用层提供网络支持的
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   TCP和UDP是传输层最常见两个传输协议。
  </p>
  <p>
   TCP的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。
  </p>
  <p>
   UDP（用户数据包协议）相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠UDP传输协议，也不是一件简单的事情。
  </p>
  <p>
   <strong>
    3、网络层
   </strong>
  </p>
  <p>
   <strong>
    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层
   </strong>
   <span class="lake-fontsize-12">
    。一句话解释：网络层的主要作用是
   </span>
   <strong>
    实现终端节点之间的通信
   </strong>
   <span class="lake-fontsize-12">
    。这种终端节点之间的通信，也叫
   </span>
   <strong>
    点对点通信
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   网络层最常使用的是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。
  </p>
  <p>
   <strong>
    4、网络接口层
   </strong>
  </p>
  <p>
   生成了IP头部之后，接下来要交给网络接口层（Link Layer）在IP头部的前面加上MAC头部，并封装成数据帧（Dataframe）发送到网络上。
  </p>
  <p>
   IP头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。
  </p>
  <p>
   以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的，所以，在以太网进行通讯要用到MAC地址。
  </p>
  <p>
   MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息，我们可以通过ARP协议获取对方的MAC地址。
  </p>
  <p>
   所以说，
   <strong>
    网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来标识网络上的设备
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <h3>
   网络层不传输数据吗？
  </h3>
  <p>
   问过的一些公司：YY直播(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   网络层是负责实现网络互连和数据包的传输。它为数据包添加网络层报头，包含了源地址和目的地址等信息，然后根据路由算法选择最佳路径发送数据包。网络层不保证数据包的可靠传输，只负责尽最大努力发送。
  </p>
  <h3>
   网络协议
  </h3>
  <p>
   问过的一些公司：农行西安软开(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   网络协议是
   <strong>
    指通信双方就通信如何进行所必须共同遵守的约定和通信规则的集合
   </strong>
   <span class="lake-fontsize-12">
    。在网络上通信的双方只有遵守相同的协议，才能正确地交流信息，就像人们交谈时要使用同一种语言一样，如果谈话里使用不同的语言，就会造成双方都不知所云，交流就被迫中断。典型的网络协议有：TCP/IP协议、IPX/SPX协议、IEEEE802标准协议系列、X.25协议等。
   </span>
  </p>
  <h3>
   数据链路层怎么传输数据的，展开说说
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   数据链路层是
   <span class="lake-fontsize-12">
    在两个相邻结点间的线路上无差错地传送以帧为单位的数据。
   </span>
  </p>
  <p>
   工作原理：
  </p>
  <p>
   1．链路管理：当网络中的两个结点要进行通信时，数据的发方必须确知收方是否已经处在准备接收的状态。为此，通信的双方必须先要交换一些必要的信息。或者用我们的术语，必须先建立一条数据链路。同样地，在传输数据时要维持数据链路，而在通信完毕时要释放数据链路。数据链路的建立、维持和释放就叫做链路管理。
  </p>
  <p>
   2．帧同步：在数据链路层，数据的传送单位是帧。数据一帧一帧地传送，就可以在出现差错时，将有差错的帧再重传一次，而避免了将全部数据都进行重传。帧同步指的是收方如何从收到的比特流中准确地区分出一帧的开始和结束。
  </p>
  <p>
   3．流量控制：发方发送数据的速率必须使收方来得及接收。当收方来不及接收时，就必须及时控制发方发送数据的速率。
  </p>
  <p>
   4．差错控制：在计算机通信中，一般都要求有极低的比特差错率。为此，广泛地采用了编码技术。编码技术有两大类。一类是前向纠错，即收方收到有差错的数据帧时，能够自动将差错改正过来。这种方法的开销较大，不适合于计算机通信。另一类是检错重发，即收方可以检测出收到的帧中有差错(但并不知道是哪几个比特错了)。于是就让发方重复发送这一帧，直到收方正确收到这一帧为止。这种方法在计算机通信中是最常用的。本章所要讨论的协议，都是采用检错重发这种差错控制方法。为了防止发送方等待收方应答时出现等待死锁，还将提供超时控制机制。重发帧后，为了防止收方收到重复帧，通常为帧给定一个帧序号。
  </p>
  <p>
   5．区分数据和控制信息：由于数据和控制信息都是在同一信道中传送，而在许多情况下，数据和控制信息处于同一帧中。因此一定要有相应的措施使收方能够将它们区分开来。
  </p>
  <p>
   6．透明传输：简单的说，透明传输就是发送方发送什么的数据，不管数据传输过程是如何实现的接收方将收到什么样的数据。更确切地说，所谓透明传输就是不管所传数据是什么样的比特组合，都应当能够在链路上传送。当所传数据中的比特组合恰巧出现了与某一个控制信息完全一样时，必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输的透明的。
  </p>
  <p>
   7．寻址：在多点连接的情况下，必须保证每一帧都能送到正确的目的站。收方也应当知道发方是哪一个站。
  </p>
  <h3>
   TCP滑动窗口
  </h3>
  <p>
   可回答：1）计算机网络的滑动窗口；2）TCP滑动窗口是如何实现传输过程？3）
   <span class="lake-fontsize-12">
    说一下可变大小的滑动窗口协议
   </span>
  </p>
  <p>
   问过的一些公司：小米(2022.08)，滴滴(2022.08)，招商银行(2022.08)，好未来(2022.08)，字节(2022.07)(2022.01)，今日头条(2021.09)，恒生电子(2022.09)，翼支付(2022.08)，百度(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、滑动窗口产生原因
   </strong>
  </p>
  <p>
   TCP是以1个段为单位，每发一个段进行一次确认应答。
   <strong>
    当上一个数据包收到了应答了，再发送下一个。
   </strong>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669910349281-58383533-6ed3-46fe-88b2-916f83806925.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   这样的传输方式有一个缺点：
   <strong>
    数据包的往返时间越长，通信的效率就越低。
   </strong>
   <span class="lake-fontsize-12">
    为解决这个问题，TCP引入了窗口这个概念。
   </span>
  </p>
  <p>
   <strong>
    2、滑动窗口
   </strong>
  </p>
  <p>
   确认应答不再是每个分段，而是以窗口的大小进行确认，转发时间被大幅度的缩短。
  </p>
  <p>
   窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口大小是一个16位字段，因此窗口最大是65535字节。
  </p>
  <p>
   TCP头里有一个字段叫Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，
   <strong>
    通常窗口的大小是由接收方的窗口大小来决定的
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669911189852-39043417-35ad-455f-acdf-3a35f1a048f4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   发送数据中，窗口内的数据即使没有收到确认应答也可以发送出去。如果窗口中的数据在传输中丢失，也需要进行重发。因此，发送端主机在收到确认应答前，必须在缓冲区保留这部分数据。
  </p>
  <p>
   <strong>
    收到确认应答后，将窗口滑动到确认应答中的序列号位置。这样可以按顺序将多个段同时发送，这种机制也被称为滑动窗口控制
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <h3>
   TCP重传机制
  </h3>
  <p>
   可回答：1）TCP有哪些重传；2）超时重传与快速重传
  </p>
  <p>
   问过的一些公司：字节基础架构北京(2022.10)，猿辅导(2022.08)，有赞(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   重传是TCP实现可靠传输的方式之一，是通过序列号与确认应答。
  </p>
  <p>
   在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。
  </p>
  <p>
   但在错综复杂的网络，并不一定能顺利进行正常的数据传输，万一数据在传输过程中丢失了呢？所以TCP针对数据包丢失的情况，会用重传机制解决。
  </p>
  <p>
   <strong>
    常见的重传机制
   </strong>
   <span class="lake-fontsize-12">
    ：
   </span>
  </p>
  <ul list="uce8c11a9">
   <li fid="u3fce0cab">
    超时重传
   </li>
   <li fid="u3fce0cab">
    快速重传
   </li>
   <li fid="u3fce0cab">
    带选择确认的重传（SACK）
   </li>
   <li fid="u3fce0cab">
    重复SACK（D-SACK）
   </li>
  </ul>
  <p>
   <strong>
    1、超时重传
   </strong>
  </p>
  <p>
   超时重传，是TCP协议保证数据可靠性的其中一个重要机制，
   <strong>
    其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   TCP会在以下两种情况发⽣超时重传：
  </p>
  <ul list="u350f0536">
   <li fid="ue064a73e">
    数据包丢失
   </li>
   <li fid="ue064a73e">
    确认应答丢失
   </li>
  </ul>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669914349990-afe29318-8efe-4421-93b8-ba53f96d94be.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   超时时间应该设置为多少呢？
  </p>
  <p>
   在回答这个问题之前，我们先来了解下什么是RTT（Round-Trip Time往返时延）
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669914515093-d0fe7f05-904a-4de0-8c1f-8141c2bf212e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   RTT指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。超时重传时间是以RTO（Retransmission Timeout超时重传时间）表示。
  </p>
  <p>
   假设在重传的情况下，超时时间RTO「较长或较短」时，会发生什么事情呢？
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669914582786-521f5f25-9787-4cb4-a8d6-87b29797313e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   上图中有两种超时时间不同的情况：
  </p>
  <ul list="u06124299">
   <li fid="u12896dc7">
    当
    <strong>
     超时时间RTO较大
    </strong>
    <span class="lake-fontsize-12">
     时，重发就慢，丢了老半天才重发，没有效率，性能差；
    </span>
   </li>
   <li fid="u12896dc7">
    当
    <strong>
     超时时间RTO较小
    </strong>
    <span class="lake-fontsize-12">
     时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。
    </span>
   </li>
  </ul>
  <p>
   精确的测量超时时间RTO的值是非常重要的，这可让我们的重传机制更高效。
  </p>
  <p>
   根据上述的两种情况，我们可以得知，
   <strong>
    超时重传时间RTO的值应该略大于报文往返RTT的值
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684638603211-01339434-db72-4e2c-a0f6-40b96bd556da.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   超时重传不是十分完美的重传方案，它有这些缺点：
  </p>
  <ul list="u2a97cfec">
   <li fid="ud076df66">
    当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。
   </li>
   <li fid="ud076df66">
    当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。
   </li>
  </ul>
  <p>
   并且，对于TCP，如果发生一次超时重传，时间间隔下次就会加倍。
  </p>
  <p>
   <strong>
    2、快速重传
   </strong>
  </p>
  <p>
   TCP还有另外一种
   <strong>
    快速重传（Fast Retransmit）机制
   </strong>
   <span class="lake-fontsize-12">
    ，是
   </span>
   <strong>
    为了解决超时重发的时间等待问题
   </strong>
   <span class="lake-fontsize-12">
    ，它
   </span>
   <strong>
    不以时间为驱动，而是以数据驱动重传
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   快速重传机制，是如何工作的呢？具体见下图。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684638754468-3368ec9c-f740-4deb-8d35-24d213e9eb4e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   在上图，发送方发出了1，2，3，4，5份数据：
  </p>
  <ul list="u27cc45fe">
   <li fid="ue2d0c2d5">
    第一份Seq1先送到了，于是就Ack回2；
   </li>
   <li fid="ue2d0c2d5">
    结果Seq2因为某些原因没收到，Seq3到达了，于是还是Ack回2；
   </li>
   <li fid="ue2d0c2d5">
    后面的Seq4和Seq5都到了，但还是Ack回2，因为Seq2还是没有收到；
   </li>
   <li fid="ue2d0c2d5">
    发送端收到了三个Ack=2的确认，知道了Seq2还没有收到，就会在定时器过期之前，重传丢失的Seq2。
   </li>
   <li fid="ue2d0c2d5">
    最后，收到了Seq2，此时因为Seq3，Seq4，Seq5都收到了，于是Ack回6。
   </li>
  </ul>
  <p>
   所以，快速重传的工作方式是当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段。
  </p>
  <p>
   快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。
  </p>
  <p>
   举个例子，假设发送方发了6个数据，编号的顺序是Seq1~Seq6，但是Seq2、Seq3都丢失了，那么接收方在收到Seq4、Seq5、Seq6时，都是回复ACK2给发送方，但是发送方并不清楚这连续的ACK2是接收方收到哪个报文而回复的，那是选择重传Seq2一个报文，还是重传Seq2之后已发送的所有报文呢（Seq2、Seq3、Seq4、Seq5、Seq6）呢？
  </p>
  <ul list="uf95f0b0e">
   <li fid="ua69962fc">
    如果只选择重传Seq2一个报文，那么重传的效率很低。因为对于丢失的Seq3报文，还得在后续收到三个重复的ACK3才能触发重传。
   </li>
   <li fid="ua69962fc">
    如果选择重传Seq2之后已发送的所有报文，虽然能同时重传已丢失的Seq2和Seq3报文，但是Seq4、Seq5、Seq6的报文是已经被接收过了，对于重传Seq4～Seq6折部分数据相当于做了一次无用功，浪费资源。
   </li>
  </ul>
  <p>
   可以看到，不管是重传一个报文，还是重传已发送的报文，都存在问题。
  </p>
  <p>
   为了解决不知道该重传哪些TCP报文，于是就有
   <span class="lake-fontsize-12">
    SACK
   </span>
   <span class="lake-fontsize-12">
    方法。
   </span>
  </p>
  <p>
   <strong>
    3、带选择确认的重传（SACK）
   </strong>
  </p>
  <p>
   SACK方法就是用来解决应该重传多少个包的问题。
  </p>
  <p>
   SACK机制就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包啦。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684638811470-9692f483-fe3c-4ecf-91bb-f78a96ff2a13.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如上图中，发送方收到了三次同样的ACK=30的确认报文，于是就会触发快速重发机制，通过SACK信息发现只有30~39这段数据丢失，于是重发时，就只选择了这个30~39的TCP报文段进行重发。
  </p>
  <p>
   <strong>
    4、
   </strong>
   <strong>
    重复SACK（D-SACK）
   </strong>
  </p>
  <p>
   D-SACK（Duplicate SACK）其主要使用了SACK来告诉「发送方」有哪些数据被重复接收了。D-SACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。
  </p>
  <p>
   下面举例两个例子，来说明D-SACK的作用。
  </p>
  <p>
   例子一号：ACK丢包
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684638903876-5b7a9a21-8d32-4fae-aa51-15e941095c5d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ul list="ub845f7e7">
   <li fid="u6027027c">
    「接收方」发给「发送方」的两个ACK确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000~3499）
   </li>
   <li fid="u6027027c">
    于是「接收方」发现数据是重复收到的，于是回了一个SACK=3000~3500，告诉「发送方」3000~3500的数据早已被接收了，因为ACK都到了4000了，已经意味着4000之前的所有数据都已收到，所以这个SACK就代表着D-SACK。
   </li>
   <li fid="u6027027c">
    这样「发送方」就知道了，数据没有丢，是「接收方」的ACK确认报文丢了。
   </li>
  </ul>
  <p>
   例子二号：网络延时
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684639058919-313006bc-f9d8-478c-95ed-e7fb5802fffa.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ul list="u0cd07986">
   <li fid="ue8bff526">
    数据包（1000~1499）被网络延迟了，导致「发送方」没有收到Ack 1500的确认报文。
   </li>
   <li fid="ue8bff526">
    而后面报文到达的三个相同的ACK确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；
   </li>
   <li fid="ue8bff526">
    所以「接收方」回了一个 SACK=1000~1500，因为ACK已经到了3000，所以这个SACK是D-SACK，表示收到了重复的包。
   </li>
   <li fid="ue8bff526">
    这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。
   </li>
  </ul>
  <p>
   可见，
   <span class="lake-fontsize-12">
    D-SACK优点如下
   </span>
   <span class="lake-fontsize-12">
    ：
   </span>
  </p>
  <ul list="uca109b29">
   <li fid="u3170df11">
    可以让「发送方」知道，是发出去的包丢了，还是接收方回应的ACK包丢了;
   </li>
   <li fid="u3170df11">
    可以知道是不是「发送方」的数据包被网络延迟了;
   </li>
   <li fid="u3170df11">
    可以知道网络中是不是把「发送方」的数据包给复制了。
   </li>
  </ul>
  <h3>
   数据链路层
  </h3>
  <p>
   问过的一些公司：百度(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、数据链路层概述
   </strong>
  </p>
  <p>
   <strong>
    数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层
   </strong>
   <span class="lake-fontsize-12">
    。数据链路层在不可靠的物理介质上提供可靠的传输。
   </span>
  </p>
  <p>
   该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
  </p>
  <p>
   有关数据链路层的重要内容：
  </p>
  <ul list="ue3227763">
   <li fid="u63cec55a">
    数据链路层为网络层提供可靠的数据传输；
   </li>
   <li fid="u63cec55a">
    基本数据单位为帧；
   </li>
   <li fid="u63cec55a">
    主要的协议：以太网协议；
   </li>
   <li fid="u63cec55a">
    两个重要设备名称：网桥和交换机。
   </li>
  </ul>
  <p>
   封装成帧：“帧”是数据链路层数据的基本单位：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669912234982-e2021f1c-5686-4e7d-99ff-1453470dc73f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   透明传输：“透明”是指即使控制字符在帧数据中，但是要当做不存在去处理。即在控制字符前加上转义字符ESC。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669912283454-a75bb797-7ded-450d-8e93-3fc001e9b9bb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    2、数据链路层的差错监测
   </strong>
  </p>
  <p>
   差错检测：奇偶校验码、循环冗余校验码CRC
  </p>
  <ul list="ud6e6aa6d">
   <li fid="u4aedafc4">
    奇偶校验码–局限性：当出错两位时，检测不到错误。
   </li>
   <li fid="u4aedafc4">
    循环冗余检验码：根据传输或保存的数据而产生固定位数校验码。
   </li>
  </ul>
  <p>
   <strong>
    3、最大传输单元MTU
   </strong>
  </p>
  <p>
   最大传输单元MTU(Maximum Transmission Unit)，数据链路层的数据帧不是无限大的，数据帧长度受MTU限制。
  </p>
  <p>
   路径MTU：由链路中MTU的最小值决定。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684639126181-31784f6d-fafa-45bf-ae61-2072733b6b24.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    4、以太网协议详解
   </strong>
  </p>
  <p>
   MAC地址：每一个设备都拥有唯一的MAC地址，共48位，使用十六进制表示。
  </p>
  <p>
   以太网协议：是一种使用广泛的局域网技术，是一种应用于数据链路层的协议，使用以太网可以完成相邻设备的数据帧传输：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669912399446-41a429c1-b6e4-4390-baec-59caedf0e470.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    局域网分类：
   </strong>
  </p>
  <p>
   <strong>
    Ethernet以太网IEEE802.3
   </strong>
  </p>
  <ul list="u2fef723c">
   <li fid="u94e9ad1b">
    以太网第一个广泛部署的高速局域网；
   </li>
   <li fid="u94e9ad1b">
    以太网数据速率快；
   </li>
   <li fid="u94e9ad1b">
    以太网硬件价格便宜，网络造价成本低。
   </li>
  </ul>
  <p>
   <strong>
    以太网帧结构
   </strong>
  </p>
  <ul list="u061e5597">
   <li fid="u1a70fa04">
    类型：标识上层协议（2字节）；
   </li>
   <li fid="u1a70fa04">
    目的地址和源地址：MAC地址（每个6字节）；
   </li>
   <li fid="u1a70fa04">
    数据：封装的上层协议的分组（46~1500字节）；
   </li>
   <li fid="u1a70fa04">
    CRC：循环冗余码（4字节）；
   </li>
   <li fid="u1a70fa04">
    以太网最短帧：以太网帧最短64字节；以太网帧除了数据部分18字节；数据最短46字节。
   </li>
  </ul>
  <p>
   <strong>
    MAC地址（物理地址、局域网地址）
   </strong>
  </p>
  <ul list="ua4a73c9c">
   <li fid="u0b84b3e6">
    MAC地址长度为6字节，48位；
   </li>
   <li fid="u0b84b3e6">
    MAC地址具有唯一性，每个网络适配器对应一个MAC地址；
   </li>
   <li fid="u0b84b3e6">
    通常采用十六进制表示法，每个字节表示一个十六进制数，用 - 或 : 连接起来；
   </li>
   <li fid="u0b84b3e6">
    MAC广播地址：FF-FF-FF-FF-FF-FF。
   </li>
  </ul>
  <h3>
   介绍下TCP，UDP
  </h3>
  <p>
   可回答：1）TCP协议了解吗？2）TCP与UDP介绍使用场景；3）TCP/IP结构模型？4）TCP/IP协议，介绍一下？
  </p>
  <p>
   问过的一些公司：快手(2022.09)，网易有道(2022.09)，同花顺(2022.09)，招商银行(2022.08)，Zoom(2022.08)，猿辅导(2022.08)，好未来(2022.08)，用友(2022.08)，格力提前批-应用软件设计(2022.08)，字节(2021.12)，阿里Lazada(2021.12)，快手(2021.09)，转转(2021.08)，有赞(2021.08)，字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、TCP
   </strong>
  </p>
  <p>
   <strong>
    TCP（传输控制协议）是一种面向连接的、可靠的流协议（基于字节流的传输层通信协议）
   </strong>
   <span class="lake-fontsize-12">
    。流就是不间断的数据，可以把它想象成排水管中的水流。当应用程序采用TCP发送消息时，虽然是按顺序发送，但接收端收到是没有间隔的数据流。比如，在发送端应用程序发送了10次100字节的数据，那么在接收端，应用程序可能会收到一个1000字节连续不间断的数据。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670045501540-89392a3e-64fa-418f-8937-04909f5042b8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    TCP为提供可靠性传输
   </strong>
   <span class="lake-fontsize-12">
    ，实行顺序控制、重发控制机制。此外还有流量控制、拥塞控制、提高网络利用率等众多功能。
   </span>
  </p>
  <p>
   TCP特点：
  </p>
  <p>
   1）面向连接
  </p>
  <p>
   面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。
  </p>
  <p>
   2）仅支持单播传输
  </p>
  <p>
   每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。
  </p>
  <p>
   3）面向字节流
  </p>
  <p>
   TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。
  </p>
  <p>
   4）可靠传输
  </p>
  <p>
   对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。
  </p>
  <p>
   5）提供拥塞控制
  </p>
  <p>
   当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞
  </p>
  <p>
   6）TCP提供全双工通信
  </p>
  <p>
   TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）
  </p>
  <p>
   <strong>
    2、UDP
   </strong>
  </p>
  <p>
   <strong>
    UDP（用户数据报协议）是不具有可靠性的协议，它是一种无连接的协议，可靠性功能交给上层的应用去完成
   </strong>
   <span class="lake-fontsize-12">
    。UDP虽然可以确保发送数据的大小，比如：发送端应用程序发送一个100字节的消息，那么接收端应用程序也会以100字节为长度接收数据。但不能保证数据一定会到达。因此，应用有时会根据需要进行重发处理。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670045663894-ad2f7f08-213d-4e37-a0bb-bbad86ffb169.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p style="text-align: left">
   因为UDP不提供数据包分组、组装和不能对数据包进行排序，所以当报文发送之后，是无法得知其是否安全完整到达的。
  </p>
  <p style="text-align: left">
   UDP特点：
  </p>
  <p style="text-align: left">
   1）面向无连接
  </p>
  <p>
   UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，它想发数据就可以开始发送了。并且它只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。
  </p>
  <p>
   具体来说就是：
  </p>
  <p>
   在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了。
  </p>
  <p>
   在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作。
  </p>
  <p>
   2）有单播，多播，广播的功能
  </p>
  <p>
   UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。
  </p>
  <p>
   3）UDP是面向报文的
  </p>
  <p>
   发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文
  </p>
  <p>
   4）不可靠性
  </p>
  <p>
   首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
  </p>
  <p>
   并且收到什么数据就传递什么数据，也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。
  </p>
  <p>
   再者网络环境时好时坏，但是UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用UDP而不是TCP。
   <span class="lake-fontsize-12">
    ​
   </span>
  </p>
  <p>
   <strong>
    3、TCP和UDP的使用场景
   </strong>
  </p>
  <p>
   1）TCP使用场景
  </p>
  <p>
   TCP实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。在对可靠性要求较高的情况下，可以使用TCP。
  </p>
  <p>
   文件传输
  </p>
  <ul list="ufb46a99e">
   <li fid="u4d1a33e1">
    FTP、HTTP对数据准确性要求高，速度可以相对慢
   </li>
  </ul>
  <p>
   发送或接收邮件
  </p>
  <ul list="u3955ae24">
   <li fid="u4714888a">
    POP、IMAP、SMTP对数据准确性要求高，非紧急应用
   </li>
  </ul>
  <p>
   远程登录
  </p>
  <ul list="u4c738fe2">
   <li fid="u72bc2df8">
    Telnet、SSH对数据准确性有一定要求，有连接的概念
   </li>
  </ul>
  <p>
   2）UDP使用场景
  </p>
  <p>
   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，随时都可以发送数据，处理简单且高效。在对可靠性要求不怎么高的情况下，可以使用UDP。
  </p>
  <p>
   即时通信
  </p>
  <ul list="uaa219809">
   <li fid="uffa4eb5f">
    QQ聊天 对数据准确性和丢包要求比较低，但速度必须快
   </li>
  </ul>
  <p>
   在线视频
  </p>
  <ul list="u922b8738">
   <li fid="u86ee862e">
    RTSP速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的
   </li>
  </ul>
  <p>
   网络语音电话
  </p>
  <ul list="u921693c5">
   <li fid="u281db209">
    VoIP语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题
   </li>
  </ul>
  <h3>
   TCP协议和UDP协议的报文中都有哪些东西？
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    TCP和UDP的首部分别存储的内容是什么？2）TCP报文的结构知道吗？
   </span>
  </p>
  <p>
   问过的一些公司：百度提前批(2022.08)，字节(2022.08)，二元互动(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、UDP协议报文
   </strong>
  </p>
  <p>
   UDP段由UDP头部和UDP数据组成。UDP头部有源端口号、目的端口号、长度、校验和组成，UDP头部长度为固定的8字节
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670388159199-961c8e2f-44af-48e1-93e3-3a3c3b83786c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   源端口号：字段长16位，表示发送端UDP端口号。
  </p>
  <p>
   目的端口号：字段长16位，表示接收端UDP端口号。
  </p>
  <p>
   长度：字段长16位，表示UDP头部和UDP数据的总长度。
  </p>
  <p>
   校验和：字段长16位，是错误检查的字段，包括UDP头和UDP数据的内容计算得出，用于检查传输过程中出现的错误。
  </p>
  <p>
   <strong>
    2、TCP协议报文
   </strong>
  </p>
  <p>
   TCP头部比UDP头部复杂得多，由一个20字节的固定长度加上可变长的选项字段组成。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670388232569-0b315b60-0637-4f62-8568-b626ab276a0c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   源端口号：字段长16位，表示发送端TCP端口号。
  </p>
  <p>
   目的端口号：字段长16位，表示接收端TCP端口号。
  </p>
  <p>
   序列号：字段长32位，是指TCP段数据的位置序号。根据序列号来判断是否存在重收、漏收、乱序等情况。
  </p>
  <p>
   确认号：字段长32位，是指下一次应该收到的数据的序列号。收到这个确认号，表示这个确认号之前的数据都已经正常收到。
  </p>
  <p>
   数据偏移：字段长4位，表示TCP数据从哪一位开始计算，也可以看作TCP头部的长度。
  </p>
  <p>
   保留：字段长6位，保留给以后扩展使用。
  </p>
  <p>
   控制位：字段长6位，每1位标志位可以打开一个控制功能，也叫做控制位。从左到右分别是URG、ACK、PSH、RST、SYN、FIN。
  </p>
  <ul list="u77618851">
   <li fid="u560945f3">
    URG：标志位为1时，表示有需要紧急处理的数据。
   </li>
   <li fid="u560945f3">
    ACK：标志位为1时，表示确认应答有效。
   </li>
   <li fid="u560945f3">
    PSH：标志位为1时，表示将数据立即上传给应用程序，而不是在缓冲区排队。
   </li>
   <li fid="u560945f3">
    RST：标志位为1时，表示TCP连接出现异常，必须强制断开连接。
   </li>
   <li fid="u560945f3">
    SYN：标志位为1时，表示请求建立连接，并设置序列号的初始值。
   </li>
   <li fid="u560945f3">
    FIN：标志位为1时，表示数据发送结束，请求断开TCP连接。
   </li>
  </ul>
  <p>
   窗口：字段长16位，标明滑动窗口的大小，表示自己还能接收多少字节的数据。
  </p>
  <p>
   校验和：字段长16位，是错误检查的字段，包括TCP头和TCP数据的内容计算得出，用于检查传输过程中出现的错误。
  </p>
  <p>
   紧急指针：字段长16位，表示紧急数据的长度。当URG位为1时，这个字段才有效。
  </p>
  <p>
   选项：字段的长度是可变的。通过添加不同的选项，实现TCP的一些扩展功能。
  </p>
  <p>
   填充：如果TCP段的头部不是4字节的整数倍，就填充一些0，来保证头部长度是4字节的整数倍。
  </p>
  <p>
   数据：TCP段的数据部分，不是TCP头部内容，字段最大是MSS。
  </p>
  <h3>
   TCP的头部有什么？
  </h3>
  <p>
   可回答：1）TCP协议头部长度是使用哪个字段？如何计算的？2）
   <span class="lake-fontsize-12">
    TCP的首部长度是多少？
   </span>
  </p>
  <p>
   问过的一些公司：同程旅行(2022.09)，字节(2022.07)，字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684639216006-ba7ebf08-f97d-4d19-b044-98400d0b5f6f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    TCP首部长度为20字节，加上选项部分最大可达60字节。
   </strong>
  </p>
  <p>
   <strong>
    第一个4字节
   </strong>
  </p>
  <ul list="u60564d23">
   <li fid="u14d67253">
    源端口，16位；发送数据的源进程端口。
   </li>
   <li fid="u14d67253">
    目的端口，16位；接收数据的进程端口。
   </li>
  </ul>
  <p>
   由于端口号最多为16位，因此端口号最大值为65535。
  </p>
  <p>
   <strong>
    第二个4字节与第三个4字节
   </strong>
  </p>
  <ul list="u4f6e6b60">
   <li fid="u85ef3f10">
    序号，32位；代表当前TCP数据段第一个字节占整个字节流的相对位置。
   </li>
   <li fid="u85ef3f10">
    确认号，32位；代表接收端希望接收的数据序号，为上次接收到数据报的序号+1，当ACK标志位为1时才生效。
   </li>
  </ul>
  <p>
   <strong>
    第四个4字节
   </strong>
  </p>
  <ul list="u16c926fd">
   <li fid="u60e36a98">
    数据偏移，4位；实际代表TCP首部长度，最大为60字节。
   </li>
   <li fid="u60e36a98">
    6个标志位，每个标志位1位：
   </li>
  </ul>
  <ul data-lake-indent="1" list="u16c926fd">
   <li fid="u60e36a98">
    SYN，为同步标志，用于数据同步；
   </li>
   <li fid="u60e36a98">
    ACK，为确认序号，ACK=1时确认号才有效；
   </li>
   <li fid="u60e36a98">
    FIN，为结束序号，用于发送端提出断开连接；
   </li>
   <li fid="u60e36a98">
    URG，为紧急序号，URG=1是紧急指针有效；
   </li>
   <li fid="u60e36a98">
    PSH，指示接收方立即将数据提交给应用层，而不是等待缓冲区满；
   </li>
   <li fid="u60e36a98">
    RST，重置连接。
   </li>
  </ul>
  <ul list="u16c926fd" start="3">
   <li fid="u60e36a98">
    窗口值，16位；窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。
   </li>
  </ul>
  <p>
   <strong>
    第五个4字节
   </strong>
  </p>
  <ul list="ud5a127cf">
   <li fid="u731fd212">
    校验和，16位；用于检验数据完整性。
   </li>
   <li fid="u731fd212">
    紧急指针，16位；只有当URG标识位为1时，紧急指针才有效。紧急指针的值与序号的相加值为紧急数据的最后一个字节位置。用于发送紧急数据。
   </li>
  </ul>
  <p>
   <strong>
    选项
   </strong>
  </p>
  <p>
   长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节，加上选项部分最大可达60字节。
  </p>
  <p>
   <strong>
    1）最大报文段长度（MSS）选项
   </strong>
  </p>
  <p>
   TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度。
  </p>
  <p>
   为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。
  </p>
  <p>
   因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）=556字节。
  </p>
  <p>
   <strong>
    2）窗口扩大选项
   </strong>
  </p>
  <p>
   窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。
  </p>
  <p>
   窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2（16+14）-1=230-1。
  </p>
  <p>
   窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。
  </p>
  <p>
   <strong>
    3）时间戳选项
   </strong>
  </p>
  <p>
   时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个作用：
  </p>
  <p>
   第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。
  </p>
  <p>
   第二、 用于处理TCP序号超过232的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加232个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。
  </p>
  <h3>
   TCP与UDP是哪层协议
  </h3>
  <p>
   问过的一些公司：美团(2022.09)(2022.08)(2021.08)x2，TP-LINK成都(2022.08)，华为(2022.05)，字节番茄小说(2022.08)，美团(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   传输层协议
  </p>
  <h3>
   TCP/IP体系结构介绍，每一层的具体概念
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    TCP/IP网络协议有几层？
   </span>
  </p>
  <p>
   问过的一些公司：蔚来(2022.08)，兴业数金(2022.08)，4399(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP/IP有四层模型和五层模型。TCP/IP分为四层或者五层都可以，只要能理解其中的原理即可。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670048528142-232a0f43-368a-4a84-91d9-61ca7756421d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    TCP/IP五层模型：应用层、传输层、网络层、数据链路层、物理层。
   </strong>
  </p>
  <p>
   应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。
  </p>
  <p>
   传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
  </p>
  <p>
   网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议、ICMP协议、ARP协议。
  </p>
  <p>
   数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。
  </p>
  <p>
   物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。
  </p>
  <p>
   <strong>
    TCP/IP四层模型：应用层、传输层、网络层、网络接入层。
   </strong>
  </p>
  <p>
   这里就只解释下网络接入层。
  </p>
  <p>
   物理层和数据链路层合并称之为网络接入层。
   <strong>
    网络接入层是对网络介质的管理，定义如何使用网络来传送数据
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   设备之间通过物理的传输介质互连，而互连的设备之间使用MAC地址实现数据传输。采用MAC地址，目的是为了识别连接到同一个传输介质上的设备。
  </p>
  <h3>
   TCP/IP协议涉及哪几层架构？
  </h3>
  <p>
   问过的一些公司：阿里(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP和IP协议分别在传输层和网际层。TCP协议提供可靠的面向连接的数据传输服务，而IP协议则负责数据在不同网络之间的传输和路由选择。
  </p>
  <p>
   包括以下四层：
  </p>
  <ul list="u3c9251d8">
   <li fid="u4931dca9">
    网络接口层（网络访问层）：负责数据在物理网络中的传输，包括对物理层的访问、帧的传输、数据的编解码等。常见的网络接口层协议包括以太网、Wi-Fi、PPP等。
   </li>
   <li fid="u4931dca9">
    网际层：负责数据在不同网络之间的传输，包括IP地址的分配和路由选择等。常见的网际层协议包括IP、ARP等。
   </li>
   <li fid="u4931dca9">
    传输层：负责数据的传输控制，包括建立、管理和维护数据传输连接，提供可靠或不可靠的数据传输服务等。常见的传输层协议包括TCP、UDP等。
   </li>
   <li fid="u4931dca9">
    应用层：负责对具体应用程序的支持，包括提供数据传输服务、数据格式转换等。常见的应用层协议包括HTTP、FTP、SMTP等。
   </li>
  </ul>
  <h3>
   IP层属于哪一层？
  </h3>
  <p>
   问过的一些公司：4399(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   属于网络层协议。
  </p>
  <h3>
   VLAN和ICMP属于什么层？
  </h3>
  <p>
   问过的一些公司：奇安信(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   他们都属于网络层协议。
  </p>
  <h3>
   ICMP报文能起到哪些作用？分别是如何起作用的？
  </h3>
  <p>
   问过的一些公司：字节(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、ICMP
   </strong>
  </p>
  <p>
   <strong>
    ICMP
   </strong>
   <strong>
    用于在IP主机、路由器之间传递控制消息，比如确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因，用来诊断网络的健康状况。
   </strong>
  </p>
  <p>
   ICMP协议
   <span class="lake-fontsize-12">
    最典型的应用就是ping和tracerooute。
   </span>
  </p>
  <ul list="ub451ab90">
   <li fid="ufec8bbe1">
    ping：通过发送回送请求报文和回送回答报文来检测源主机到目的主机的链路是否有问题，目的地是否可达，以及通信的延迟情况。
   </li>
   <li fid="ufec8bbe1">
    traceroute：
    <span class="lake-fontsize-12">
     通过发送探测报文来获取链路地址信息。第一个探测报文TTL为1，到达第一个路由器时，TTL减1为0所以丢掉这个探测包，同时向源主机发回ICMP时间超过报文，这时源主机就获得了第一个路由器的IP地址；接着源主机发送第二个探测报文，TTL增1为2，到达第一个路由器TTL减1为1并转发探测包到第二个路由器，这时TTL减1为0，丢掉这个探测包并向源主机发回ICMP时间超过报文，源主机就获得了第二个路由器的IP地址；以此类推，直到探测报文到达traceroute的目的地，这时源主机就获得了到目的地的每一跳路由的IP地址。
    </span>
   </li>
  </ul>
  <p>
   在IP通信中如果某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由ICMP负责通知。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670389034756-62f6e899-19f7-491c-acd8-e118d9d4e05a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如上图例子，主机A向主机B发送了数据包，由于某种原因，途中的路由器2未能发现主机B的存在，这时，路由器2就会向主机A发送一个ICMP目标不可达数据包，说明发往主机B的包未能成功。
  </p>
  <p>
   ICMP的这种通知消息会使用IP进行发送。
  </p>
  <p>
   因此，从路由器2返回的ICMP包会按照往常的路由控制先经过路由器1再转发给主机A。收到该ICMP包的主机A则分解ICMP的首部和数据域以后得知具体发生问题的原因。
  </p>
  <p>
   <strong>
    2、ICMP包头格式
   </strong>
  </p>
  <p>
   ICMP报文是封装在IP包里面，它工作在网络层，是IP协议的助手。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670389160264-a03a1c9c-70d1-4c38-9ef2-c99e521a476f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_42%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   类型（type）：表示ICMP消息的类型
  </p>
  <p>
   代码（code）：表示ICMP消息的具体含义。例如：type值为3表示目的不可达消息（DestinationUnreachableMessage），若code值为0表示目的网络不可达（NetworkUnreachable）。
  </p>
  <p>
   常见的ICMP消息类型如下图。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670389979143-4e22dc80-d96e-4776-8659-9f376fea6320.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    根据ICMP包头的类型字段（或者说从功能上区分），大致可以分为两大类：
   </strong>
  </p>
  <ul list="uaf37494d">
   <li fid="u75071f45">
    <strong>
     一类是用于诊断的查询消息，也就是「查询报文类型」
    </strong>
   </li>
   <li fid="u75071f45">
    <strong>
     另一类是通知出错原因的错误消息，也就是「差错报文类型」
    </strong>
   </li>
  </ul>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670389286129-98e20a59-b54d-48b9-b044-e1669ef3003f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   ICMP为什么在网络层？
  </h3>
  <p>
   问过的一些公司：Boss直聘北京(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ICMP（Internet Control Message Protocol）是一种网络层协议，用于在IP协议中传递控制消息。它主要用于报告错误，如网络不可达、主机不可达、超时等。
  </p>
  <p>
   ICMP属于网络层协议，主要原因是它主要用于处理IP协议中的错误信息，并且它的工作方式与网络层的其他协议（如IP协议）类似。例如，它会对数据进行封装，并通过网络传输。此外，它的主要功能是提供控制信息，这也是网络层的主要作用之一。因此，将ICMP分类为网络层协议是合理的。
  </p>
  <h3>
   UDP在哪一层？
  </h3>
  <p>
   问过的一些公司：大连东软(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   传输层
  </p>
  <h3>
   TCP和UDP的区别？
  </h3>
  <p>
   可回答：1）TCP和UDP有什么区别？分别应用于哪些场景？2）TCP和UDP的核心区别在哪？3）TCP和UDP有什么运用场景？有哪些区别？4）从UDP和TCP的数据包头来说下区别呢？
  </p>
  <p>
   问过的一些公司：同花顺(2022.10)，亚信安全(2022.10)，极致游戏(2022.10)，网易有道(2022.09)，字节番茄小说(2022.09)，字节(2022.09)(2022.08)x4(2022.07)(2022.01)(2021.08)x2，深信服(2022.09)，百度提前批(2022.08)，腾讯(2022.05)x2，招银网络(2022.09)，美团(2022.09)(2022.08)x3(2021.09)(2021.08)x2，华为(2022.05)，奇安信(2022.09)，4399(2022.09)，Zoom(2022.09)，创维数字(2022.09)，哈啰(2022.09)，元气森林(2022.09)，掌趣(2022.09)，阿里巴巴菜鸟(2022.08)，阿里巴巴杭州淘系(2022.08)，猿辅导(2022.08)x2，快手(2022.08)，TP-LINK成都(2022.08)，神策数据(2022.08)，民生科技(2022.08)，4399(2022.08)，中兴(2022.08)，万集科技(2022.08)，momenta(2021.11)x2，阿里蚂蚁金服(2021.11)，绿盟(2021.10)，阿里(2021.09)，OPPO(2021.08)，趋势科技(2021.08)，小米(2021.08)，字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、连接
   </strong>
  </p>
  <p>
   TCP是面向连接的传输层协议，传输数据前先要建立连接。
  </p>
  <p>
   UDP是不需要连接，即刻传输数据。
  </p>
  <p>
   <strong>
    2、服务对象
   </strong>
  </p>
  <p>
   TCP是一对一的两点服务，即一条连接只有两个端点。
  </p>
  <p>
   UDP支持一对一、一对多、多对多的交互通信
  </p>
  <p>
   <strong>
    3、可靠性
   </strong>
  </p>
  <p>
   TCP是可靠交付数据的，TCP通过超时重传、数据校验等方式来确保数据可以无差错、不丢失、不重复、按需到达。
  </p>
  <p>
   UDP由于无需连接的原因，将会以最大速度进行传输，但不保证可靠交付，也就是会出现丢失、重复等等问题。
  </p>
  <p>
   <strong>
    4、拥塞控制、流量控制
   </strong>
  </p>
  <p>
   TCP有拥塞控制和流量控制机制，保证数据传输的安全性。
  </p>
  <p>
   UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率。
  </p>
  <p>
   <strong>
    5、首部开销
   </strong>
  </p>
  <p>
   TCP首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是20个字节，如果使用了「选项」字段则会变长的。
  </p>
  <p>
   UDP首部只有8个字节，并且是固定不变的，开销较小。
  </p>
  <p>
   <strong>
    6、传输方式
   </strong>
  </p>
  <p>
   TCP是流式传输，没有边界，但保证顺序和可靠。
  </p>
  <p>
   UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
  </p>
  <p>
   <strong>
    7、分片不同
   </strong>
  </p>
  <p>
   TCP的数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
  </p>
  <p>
   UDP的数据大小如果大于MTU大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，接着再传给传输层。
  </p>
  <p>
   <strong>
    8、使用场景
   </strong>
  </p>
  <p>
   1）TCP使用场景
  </p>
  <p>
   TCP实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。在对可靠性要求较高的情况下，可以使用TCP。
  </p>
  <p>
   文件传输
  </p>
  <ul list="u7960a3b6">
   <li fid="u4d1a33e1">
    FTP、HTTP对数据准确性要求高，速度可以相对慢
   </li>
  </ul>
  <p>
   发送或接收邮件
  </p>
  <ul list="ucb852a0f">
   <li fid="u4714888a">
    POP、IMAP、SMTP对数据准确性要求高，非紧急应用
   </li>
  </ul>
  <p>
   远程登录
  </p>
  <ul list="ue1d4428c">
   <li fid="u72bc2df8">
    Telnet、SSH对数据准确性有一定要求，有连接的概念
   </li>
  </ul>
  <p>
   2）UDP使用场景
  </p>
  <p>
   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，随时都可以发送数据，处理简单且高效。在对可靠性要求不怎么高的情况下，可以使用UDP。
  </p>
  <p>
   即时通信
  </p>
  <ul list="u87d4e5b0">
   <li fid="uffa4eb5f">
    QQ聊天 对数据准确性和丢包要求比较低，但速度必须快
   </li>
  </ul>
  <p>
   在线视频
  </p>
  <ul list="u74094f19">
   <li fid="u86ee862e">
    RTSP速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的
   </li>
  </ul>
  <p>
   网络语音电话
  </p>
  <ul list="u84ec04d6">
   <li fid="u281db209">
    VoIP语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题
   </li>
  </ul>
  <h3>
   HTTP和UDP的区别
  </h3>
  <p>
   问过的一些公司：用友秋招提前批(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP就是基于TCP的，所以直接看上面的“TCP和UDP的区别”即可。
  </p>
  <h3>
   如果UDP发送方一直发，接受不过来会怎么样？
  </h3>
  <p>
   问过的一些公司：momenta(2021.11)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   接收端此时就会出现丢包现象。
  </p>
  <p style="text-align: left">
   UDP丢包一般处理方法：
  </p>
  <ul list="u9125b5d7">
   <li fid="ue5075485" style="text-align: left">
    增加发送端接收端的缓存
   </li>
   <li fid="ue5075485" style="text-align: left">
    发送端做发送平滑处理
   </li>
   <li fid="ue5075485" style="text-align: left">
    接收端的接收和处理部分分开
   </li>
   <li fid="ue5075485" style="text-align: left">
    采用可靠UDP传输
   </li>
  </ul>
  <h3>
   TCP和UDP哪个快？为什么快？
  </h3>
  <p>
   可回答：1）UDP比TCP快在哪？
  </p>
  <p>
   问过的一些公司：青书(2022.10)，绿盟(2022.09)，阿里巴巴菜鸟(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   UDP更快。
  </p>
  <p>
   因为UDP连接没有TCP的三次握手、确认应答、超时重发、流量控制、拥塞控制等机制，而且UDP是一个无状态的传输协议，所以它在传递数据时非常快。
  </p>
  <p>
   通俗来说：使用UDP传输数据，不用建立连接，数据直接丢过去即可。至于接收方能不能收到，那就是接收方的事情了。
  </p>
  <h3>
   UDP为什么是面向报文的？
  </h3>
  <p>
   可回答：1）TCP为什么是面向字节的？
  </p>
  <p>
   问过的一些公司：绿盟(2021.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    UDP是面向报文的
   </strong>
   <span class="lake-fontsize-12">
    ：发送方的UDP对应用程序交下来的报文，在添加了首部之后就向下交付，UDP对应用层交付下来的报文即不合并也不拆分，而是保留这些报文的边界，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，接收方UDP对下方交上来的UDP用户数据报，在去除首部之后就原封不动的交付给上层的应用程序，一次交付一个完整报文，所以是UDP是面向报文的
   </span>
  </p>
  <p>
   <strong>
    TCP是面向字节的
   </strong>
   <span class="lake-fontsize-12">
    ：发送方TCP对应用程序交下来的报文数据块，视为无结构的字节流（无边界约束，可拆分/合并），但维持各字节流顺序（相对顺序没有变），TCP发送方有一个发送缓冲区，当应用程序传输的数据块太长，TCP就可以把它划分端一些再传输，如果应用程序一次只传输一个字节，那么TCP可以等待积累足够多的字节后再构成报文端发送出去，所以TCP的面向字节的
   </span>
  </p>
  <h3>
   TCP三次握手，四次挥手
  </h3>
  <p>
   可回答：1）三次握手和四次挥手的过程；2）TCP协议建立连接、释放连接的过程；3）TCP连接和断开；4）UDP怎么连接的？5）TCP三次握手，四次挥手的实现原理？
  </p>
  <p>
   问过的一些公司：字节基础架构北京(2022.10)，去哪儿北京(2022.10)，海雀科技(2022.10)，万得(2022.10)，百度(2022.09)(2022.08)，腾讯(2022.08)(2022.05)x2(2021.08)x2，海康威视(2022.09)，招银网络(2022.09)，京东(2022.09)，字节(2022.08)x2(2022.07)(2021.08)x4，美团(2022.08)x3(2021.08)，快手(2022.08)(2021.09)，猿辅导(2022.08)x3，字节飞书(2022.08)(2022.04)，京东(2022.04)，OPPO(2022.09)(2022.08)，贝壳(2022.09)，顺丰(2022.09)，爱数(2022.09)，经纬恒润(2022.09)，满帮(2022.09)，字节抖音(2022.08)(2022.04)，美团(2022.08)，阿里巴巴菜鸟(2022.08)，蔚来(2022.08)(2022.07)，好未来(2022.08)x2，翼支付(2022.08)，大应科技(2022.08)，浩鲸科技(2022.08)，米哈游(2022.08)，同盾科技(2022.08)，联想战略分析(2022.08)，阿里巴巴杭州淘系(2022.08)，第四范式(2022.07)，华为(2021.11)，momenta(2021.11)x2，Bigo(2021.09)，字节番茄小说(2021.10)，腾讯音乐(2021.11)，欧科云链(2022.04)，绿盟(2021.10)，拼多多(2021.09)，转转(2021.08)x3，百度(2021.09)，有赞(2021.09)(2021.08)x2，泰隆银行(2021.09)，用友(2021.09)，知乎(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、三次握手
   </strong>
  </p>
  <p>
   主机A想向主机B发送数据，TCP模块通过三次握手建立连接TCP会话。
  </p>
  <p>
   三次握手，是指TCP会话建立过程中共交换了3个TCP控制段，它们分别是SYN段、SYN+ACK段、ACK段。
  </p>
  <p>
   详细过程如下：
  </p>
  <p>
   1）发送端主机A向接收端主机B发出SYN段，表示发起建立连接请求，同时把自己的状态告诉主机B。将段的序列号设为a，SYN置位，表示SYN管理段。
  </p>
  <p>
   2）主机B收到连接请求后，回应SYN+ACK段，将序列号设为b，确认号设为a+1，同时将SYN和ACK置位。
  </p>
  <p>
   3）主机A收到主机B的连接确认后，发送ACK段再次进行确认，确认会话的建立，将ACK置位。主机A收到确认号是a+1、序列号是b的段后，发送序列号为a+1、确认号为b+1的段进行确认。
  </p>
  <p>
   4）主机B收到确认报文后，连接建立。双方可以开始传输数据。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670079581480-4667e0c0-96fd-44d3-8ec0-d6716681d26a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   经过3次握手后，A和B之间其实是建立了两个TCP会话，一个是从A指向B的TCP会话，另一个是从B指向A的TCP会话。A发送的SYN段，表示A请求建立一个从A指向B的TCP会话，目的是控制数据能够正常、可靠的从A传输到B。B在收到SYN段后，会发送一个SYN+ACK段作为回应。SYN+ACK的含义是：B一方面同意了A的请求，另一方面也请求建立一个从B指向A的TCP会话，这个会话目的是控制数据能够正确、可靠的从B传输到A。A收到SYN+ACK段后，回应一个ACK，表示同意B的请求。
  </p>
  <p>
   <strong>
    2、四次挥手
   </strong>
  </p>
  <p>
   当TCP数据段的传输结束时，双方都需要发送FIN段和ACK段来终止TCP会话，这个方式叫做四次挥手。
  </p>
  <p>
   详细过程如下：
  </p>
  <p>
   1）主机A想要终止连接，发送序列号为p的段，FIN置位，表示FIN管理段。
  </p>
  <p>
   2）主机B收到主机A发送的FIN段后，发送ACK段，确认号为p+1，同时关闭连接。
  </p>
  <p>
   3）主机B发送序列号为q的段，FIN置位，通知连接关闭。
  </p>
  <p>
   4）主机A收到主机B发送的FIN段后，发送ACK段，确认号为q+1，同时关闭连接。TCP连接至此结束。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670080331008-466f32c8-8007-4474-b50d-3e136c386858.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   TCP会话的终止分为两个部分。首先A发送FIN控制段，请求终止从A到B的TCP会话。B回应ACK段，表示同意A的终止会话请求。A收到B的ACK段后，才开始终止这个会话。同理，B也会向A发起请求，终止从B到A的TCP会话。
  </p>
  <h3>
   TCP连接过程中双方有什么数据结构？
  </h3>
  <p>
   问过的一些公司：字节抖音(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    半连接队列，全连接队列
   </strong>
  </p>
  <p>
   在TCP进行三次握手时，Liunx会为其维护两个队列：
  </p>
  <ul list="ue0dac851">
   <li fid="u77af4be8">
    半连接队列，也叫syn队列
   </li>
   <li fid="u77af4be8">
    全连接队列，也叫accept队列
   </li>
  </ul>
  <p>
   服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670402126943-96a93c09-97a4-40ba-afaf-ea97a4c66112.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。
  </p>
  <p>
   <strong>
    1、
   </strong>
   <strong>
    半连接队列(syn队列)
   </strong>
  </p>
  <p>
   <strong>
    如何查看半连接队列的长度呢？
   </strong>
  </p>
  <p>
   我们可以抓住半连接队列的特点，处于syn_recv状态的tcp连接，就是我们的半连接队列
  </p>
  <p>
   于是，我们使用如下命令查看处于syn_recv状态的tcp连接
  </p>
  <pre><code class="language-java" lang="java">netstat -natp | grep SYN_RECV | wc -l</code></pre>
  <p>
   <strong>
    模拟tcp半连接队列溢出场景
   </strong>
  </p>
  <p>
   我们只需要一直对服务端发送syn包，但是不回ack回应包，这样就会使得服务端有大量请求处于syn_recv状态，
   <span class="lake-fontsize-12" style="background-color: rgb(249, 242, 244)">
    这就是所谓的syn洪泛，syn攻击，DDos攻击
   </span>
  </p>
  <p>
   <strong>
    如何抵御syn攻击？
   </strong>
  </p>
  <p>
   1）增大半连接队列
  </p>
  <p>
   不能只增大tcp_max_syn_backlog,还需要一同增大somaconn和backlog，也就是增大全连接队列
  </p>
  <p>
   2）开启tcp_syncookies功能
  </p>
  <p>
   开启tcp_syncookies就可以在不使用syn半连接队列的情况下建立连接
  </p>
  <p>
   syncookies在接收到客户端的syn报文时，计算出一个值，放到syn+ack报文中发出。当客户端返回ack报文时，取出该值验证，成功则建立连接，如下图：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670402721548-9093906f-07a1-40cc-870a-c370b057ee12.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   3）减少ack+syn报文的重传次数
  </p>
  <p>
   因为我们在收到syn攻击时，服务端会重传syn+ack报文到最大次数，才会断开连接。针对syn攻击的场景，我们可以减少ack+syn报文的重传次数，使处于syn_recv状态的它们更快断开连接
  </p>
  <p>
   修改重传次数：/proc/sys/net/ipv4/tcp_synack_retries
  </p>
  <p>
   <strong>
    2、全连接队列
   </strong>
  </p>
  <p>
   <strong>
    如何知道TCP全连接队列的大小？
   </strong>
  </p>
  <p>
   可以使用ss命令，来查看TCP全连接队列的情况
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670403926285-5df2a4e4-10ee-4d95-bd5b-2a5d5f1898ae.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    全连接队列溢出
   </strong>
  </p>
  <p>
   当服务端的全连接队列过小时，容易发生全连接队列溢出。发生全连接队列溢出，后续的请求就会别丢弃。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670403963548-fbd6a51e-365c-4e8d-b5d4-15a63d82bd9f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   Linux有个参数可以指定TCP全连接队列满了，会使用什么策略来回应客户端
  </p>
  <p>
   丢弃连接只是liunx的默认行为，我们还可以向客户端发送RST报文终止连接，告诉客户端连接失败
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670404032321-116c4ac2-53ce-4b84-aaa6-05860f39a84f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   tcp_abort_on_overflow共有两个值分别是0和1
  </p>
  <ul list="ube9882ce">
   <li fid="uc7662c31">
    0：如果全连接队列满了，那么服务端丢弃ack报文
   </li>
   <li fid="uc7662c31">
    1：如果全连接队列满了，那么服务端会想客户端发送RST报文，终止这个握手连接
   </li>
  </ul>
  <p>
   通常情况下设置为0更好，可以提高效率。
  </p>
  <p>
   如果设置为0的话，此时服务端全连接队列满了，客户端发送过来的ack报文，服务端丢弃。而此时客户端还会继续重传，如果此时服务端的全连接队列有空闲，那么就会接受重传的ack包，这样就能直接建立连接了。而设置为1的话，还需要重新连接。
  </p>
  <p>
   <strong>
    如何增大全连接队列呢？
   </strong>
  </p>
  <p>
   当全连接队列溢出后，我们需要增大全连接队列的长度，以提高请求容量。
  </p>
  <p>
   TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)，所以我们需要提高这两个参数的大小才能拿增大全连接队列。
  </p>
  <h3>
   具体哪两个api之间发生三次握手？
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    三次握手发生在哪个api调用的阶段？
   </span>
  </p>
  <p>
   问过的一些公司：字节(2022.08)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP三次握手发生在客户端connect和服务端accept两个API之间
  </p>
  <h3>
   SYN泛洪攻击怎么解决？
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    TCP的sync攻击
   </span>
  </p>
  <p>
   问过的一些公司：今日头条(2021.09)，腾讯(2021.08)，用友(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   当服务端不断收到syn包，但是没有收到ack回应包，此时服务端有大量请求处于syn_recv状态，
   <span class="lake-fontsize-12" style="background-color: rgb(249, 242, 244)">
    这就是所谓的syn洪泛，syn攻击，DDos攻击
   </span>
  </p>
  <p>
   <strong>
    抵御syn攻击方式
   </strong>
  </p>
  <p>
   <strong>
    1）增大半连接队列
   </strong>
  </p>
  <p>
   不能只增大tcp_max_syn_backlog,还需要一同增大somaconn和backlog，也就是增大全连接队列
  </p>
  <p>
   <strong>
    2）开启tcp_syncookies功能
   </strong>
  </p>
  <p>
   开启tcp_syncookies就可以在不使用syn半连接队列的情况下建立连接
  </p>
  <p>
   syncookies在接收到客户端的syn报文时，计算出一个值，放到syn+ack报文中发出。当客户端返回ack报文时，取出该值验证，成功则建立连接，如下图：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670402721548-9093906f-07a1-40cc-870a-c370b057ee12.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    3）减少ack+syn报文的重传次数
   </strong>
  </p>
  <p>
   因为我们在收到syn攻击时，服务端会重传syn+ack报文到最大次数，才会断开连接。针对syn攻击的场景，我们可以减少ack+syn报文的重传次数，使处于syn_recv状态的它们更快断开连接
  </p>
  <p>
   修改重传次数：/proc/sys/net/ipv4/tcp_synack_retries
  </p>
  <h3>
   三次握手有哪些报文？
  </h3>
  <p>
   问过的一些公司：有赞(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   第1个报文，
   <span class="lake-fontsize-12">
    请求连接消息：SYN
   </span>
  </p>
  <p>
   客户端
   <span class="lake-fontsize-12">
    把第一个SYN报文发送给服务端，表示向服务端发起连接
   </span>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   第2个保卫，
   <span class="lake-fontsize-12">
    SYN和ACK
   </span>
  </p>
  <p>
   服务器给客户端返回的确认消息。
  </p>
  <p>
   第3个报文，确认消息：ack
  </p>
  <p>
   服务器收到客户端
   <span class="lake-fontsize-12">
    的连接确认后，发送ACK段再次进行确认，确认会话的建立。
   </span>
  </p>
  <h3>
   三次握手流程出现错误怎么办？
  </h3>
  <p>
   可回答：1）三次握手，第三次失败了会怎么样，第二次失败了会怎么样？2）
   <span class="lake-fontsize-12">
    如果第三次握手没有回复会出现什么情况？
   </span>
  </p>
  <p>
   问过的一些公司：好未来(2022.08)，腾讯(2021.08)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    第一次握手
   </strong>
   <span class="lake-fontsize-12">
    ：客户端发送失败，客户端、服务器端都不会申请资源。
   </span>
  </p>
  <p>
   <strong>
    第二次握手
   </strong>
   <span class="lake-fontsize-12">
    ：服务器端回应客户端传输失败，客户端不会申请资源，服务器端申请了资源，但收不到客户端第三次握手时发送的请求，过一段时间释放资源。
   </span>
  </p>
  <p>
   <strong>
    第三次握手
   </strong>
   <span class="lake-fontsize-12">
    ：客户端回应服务器端传输失败，服务器端没有收到客户端回应，服务器端会多次发送回应给客户端，如果还是没有收到客户端的客户端回应，则释放资源，服务器端会发送RTS报文并主动关闭防止syn洪泛攻击。
   </span>
  </p>
  <p>
   当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的连接并回收资源，当主动方主动发送大量的syn数据包，但并不做出第三次握手响应，服务器端还是会分配相应的资源，就会使服务器端占用大量内存，这就是
   <strong>
    syn洪泛攻击
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <h3>
   TCP为什么是三次握手、四次挥手？
  </h3>
  <p>
   可回答：1）为什么建立三次、断开是四次？2）4次挥手为什么是4次，为什么要4次挥手？3）为什么要进行三次握手，但是断链的时候要进行四次挥手？4）为什么不能三次挥手；5）TCP三次握手是否能够减少为两次？
  </p>
  <p>
   问过的一些公司：海雀科技(2022.10)，OPPO(2022.09)，中金所(2022.09)，腾讯(2022.08)，百度(2022.08)，字节(2022.08)x3(2021.08)x4(2022.01)，大疆(2022.08)，美团(2022.09)(2022.08)x3(2021.08)，好未来(2022.08)，华为云(2022.08)，用友(2022.08)，OPPO提前批(2022.08)，阿里巴巴菜鸟(2022.08)，阿里巴巴杭州淘系(2022.08)，猿辅导(2022.08)，字节飞书(2022.04)，阿里(2021.09)，快手(2021.09)，招银网络(2021.09)，今日头条(2021.09)，多益(2021.09)，OPPO(2021.08)，转转(2021.08)，有赞(2021.08)，京东(2021.08)，小米(2021.08)，Shoope(2021.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP连接是用于保证可靠性和流量控
   <span class="lake-fontsize-12">
    制维护的某些状态信息。
   </span>
  </p>
  <p>
   我们从以下三个方面分析三次握手的原因：
  </p>
  <ul list="ue71e0c0f">
   <li fid="u209741c0">
    三次握手才可以阻止重复历史连接的初始化（主要原因）
   </li>
   <li fid="u209741c0">
    三次握手才可以同步双方的初始序列号
   </li>
   <li fid="u209741c0">
    三次握手才可以避免资源浪费
   </li>
  </ul>
  <p>
   <strong>
    原因一：避免历史连接
   </strong>
  </p>
  <p>
   简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。
  </p>
  <p>
   我们考虑一个场景，客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意！不是重传 SYN，重传的 SYN 的序列号是一样的）。
  </p>
  <p>
   看看三次握手是如何阻止历史连接的：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670340266180-13e1b47e-1aa0-4dc1-ae8d-e69cd2c21119.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   客户端连续发送多次 SYN （都是同一个四元组）建立连接的报文，在
   <strong>
    网络拥堵
   </strong>
   <span class="lake-fontsize-12">
    情况下：
   </span>
  </p>
  <ul list="u83827c9f">
   <li fid="u14f6b60f">
    一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个
    <span class="lake-fontsize-12">
     SYN + ACK
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     报文给客户端，此报文中的确认号是 91（90+1）。
    </span>
   </li>
   <li fid="u14f6b60f">
    客户端收到后，发现自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。
   </li>
   <li fid="u14f6b60f">
    服务端收到 RST 报文后，就会释放连接。
   </li>
   <li fid="u14f6b60f">
    后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。
   </li>
  </ul>
  <p>
   上述中的「旧 SYN 报文」称为历史连接，
   <strong>
    TCP 使用三次握手建立连接的最主要原因就是防止「历史连接」初始化了连接。
   </strong>
  </p>
  <p>
   如果是两次握手连接，就无法阻止历史连接
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。
  </p>
  <p>
   在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670340355364-8efc4045-dd1d-43b1-99fc-bfe215f03ca1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   可以看到，如果采用两次握手建立TCP连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。
  </p>
  <p>
   因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。
  </p>
  <p>
   所以，TCP使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。
  </p>
  <p>
   <strong>
    原因二：同步双方初始序列号
   </strong>
  </p>
  <p>
   TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：
  </p>
  <ul list="uae20bfd7">
   <li fid="uca8fb663">
    接收方可以去除重复的数据；
   </li>
   <li fid="uca8fb663">
    接收方可以根据数据包的序列号按序接收；
   </li>
   <li fid="uca8fb663">
    可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；
   </li>
  </ul>
  <p>
   可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的
   <span class="lake-fontsize-12">
    SYN
   </span>
   <span class="lake-fontsize-12">
    报文的时候，需要服务端回一个
   </span>
   <span class="lake-fontsize-12">
    ACK
   </span>
   <span class="lake-fontsize-12">
    应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。
   </span>
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670340488150-bd0a9dcd-f26d-4492-b9d9-433d51891d3e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   四次握手其实也能够可靠的同步双方的初始化序号，但由于
   <strong>
    第二步和第三步可以优化成一步
   </strong>
   <span class="lake-fontsize-12">
    ，所以就成了「三次握手」。
   </span>
  </p>
  <p>
   而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
  </p>
  <p>
   <strong>
    原因三：避免资源浪费
   </strong>
  </p>
  <p>
   如果只有「两次握手」，当客户端发生的SYN报文在网络中阻塞，客户端没有接收到ACK报文，就会重新发送SYN，由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的ACK报文，所以服务端每收到一个SYN就只能先主动建立一个连接，这会造成什么情况呢？
  </p>
  <p>
   如果客户端发送的SYN报文在网络中阻塞了，重复发送多次SYN报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670340556852-7bc79c15-22fa-4e15-9d0b-b7adee73eb72.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   综上：
  </p>
  <p>
   TCP 建立连接时，通过三次握手
   <strong>
    能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号
   </strong>
   <span class="lake-fontsize-12">
    。序列号能够保证数据包不重复、不丢弃和按序传输。
   </span>
  </p>
  <p>
   不使用「两次握手」和「四次握手」的原因：
  </p>
  <ul list="u980ebfc6">
   <li fid="u5ee7a600">
    「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
   </li>
   <li fid="u5ee7a600">
    「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。
   </li>
  </ul>
  <h3>
   TCP四次挥手最后一次ack如果客户端没收到怎么办？
  </h3>
  <p>
   问过的一些公司：腾讯(2022.05)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   这里应该指的是第三次挥手
  </p>
  <p>
   正常情况下，
   <span class="lake-fontsize-12">
    当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于
   </span>
   <span class="lake-fontsize-12" style="background-color: rgb(249, 242, 244)">
    CLOSE_WAIT
   </span>
   <span class="lake-fontsize-12">
    状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。
   </span>
  </p>
  <p>
   服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。
  </p>
  <p>
   如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由
   <span class="lake-fontsize-12" style="background-color: rgb(249, 242, 244)">
    tcp_orphan_retries
   </span>
   <span class="lake-fontsize-12">
    参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。
   </span>
  </p>
  <p>
   假设
   <span class="lake-fontsize-12" style="background-color: rgb(249, 242, 244)">
    tcp_orphan_retries
   </span>
   <span class="lake-fontsize-12">
    = 3，当第三次挥手一直丢失时
   </span>
  </p>
  <ul list="u54dfa34d">
   <li fid="ua189d6be">
    当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。
   </li>
   <li fid="ua189d6be">
    客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。
   </li>
  </ul>
  <h3>
   四次挥手套接字的状态转移
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    四次挥手的双方状态变化
   </span>
  </p>
  <p>
   问过的一些公司：快手(2021.09)，OPPO(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP四次挥手是一种用于终止TCP连接的协议。当一个TCP连接要终止时，它的两个端点都要遵循四次挥手的协议进行操作。四次挥手步骤包括：
  </p>
  <ol list="u4353f8ed">
   <li fid="ua4be9e73">
    主机A发送一个FIN给主机B，表示它已经没有数据要发送给B了。
   </li>
   <li fid="ua4be9e73">
    主机B收到FIN后，发送一个ACK给A，表示它已经收到了A的FIN。
   </li>
   <li fid="ua4be9e73">
    主机B发送一个FIN给主机A，表示它也没有数据要发送给A了。
   </li>
   <li fid="ua4be9e73">
    主机A收到FIN后，发送一个ACK给B，表示它已经收到了B的FIN，并结束整个连接。
   </li>
  </ol>
  <p>
   在四次挥手的过程中，套接字的状态会经历以下变化：
  </p>
  <ul list="uff27ebe7">
   <li fid="u6986405b">
    当主机A发送FIN时，它的套接字由ESTABLISHED状态变为FIN_WAIT_1状态。
   </li>
   <li fid="u6986405b">
    当主机A收到B的ACK时，它的套接字由FIN_WAIT_1状态变为FIN_WAIT_2状态。
   </li>
   <li fid="u6986405b">
    当主机B发送FIN时，它的套接字由ESTABLISHED状态变为CLOSE_WAIT状态。
   </li>
   <li fid="u6986405b">
    当主机A收到B的FIN时，它的套接字由FIN_WAIT_2状态变为TIME_WAIT状态。
   </li>
   <li fid="u6986405b">
    当主机A发送ACK时，它的套接字由TIME_WAIT状态变为CLOSED状态。
   </li>
   <li fid="u6986405b">
    当主机B收到A的ACK时，它的套接字由LAST_ACK状态变为CLOSED状态。
   </li>
  </ul>
  <h3>
   TCP三次握手之前，需要做什么？
  </h3>
  <p>
   问过的一些公司：字节飞书(2022.04)
  </p>
  <p>
   参考答案：
  </p>
  <p style="text-align: left">
   在握手之前进行了DNS查询（DNS 迭代查询）
  </p>
  <p style="text-align: left">
   1）操作系统会首先在本地缓存中查询IP
  </p>
  <p style="text-align: left">
   2）没有的话会去系统配置的DNS服务中去查询
  </p>
  <p style="text-align: left">
   3）如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
  </p>
  <p style="text-align: left">
   4）然后去该服务器查询 google 这个二级域名
  </p>
  <p style="text-align: left">
   5）接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
  </p>
  <p style="text-align: left">
   注意：DNS 是基于 UDP 做的查询。
  </p>
  <h3>
   TCP三次握手，序列号的作用，能不能没有序列号？
  </h3>
  <p>
   问过的一些公司：腾讯(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   Seq序号，占32位，是
   <strong>
    用来标识从TCP源端向目的端发送的字节流，对发起方发送数据时对此进行标记
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <h3>
   TCP长连接怎么实现的？
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    HTTP长连接还是短连接？2）HTTP长连接
   </span>
  </p>
  <p>
   问过的一些公司：好未来(2022.08)，字节(2021.09)，转转(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP协议中有长连接和短连接之分。
  </p>
  <p>
   短连接环境下，数据交互完毕后，主动释放连接。
  </p>
  <p>
   长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、死机、崩溃、重启，还是中间路由网络无故断开，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以服务器端要做到快速感知失败，减少无效链接操作，这就有了TCP的Keepalive（保活探测）机制。
  </p>
  <p>
   所以，
   <strong>
    TCP长连接可以说是基于Keepalive（保活探测）机制实现的
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   <strong>
    TCP Keepalive工作原理
   </strong>
  </p>
  <p>
   当一个 TCP 连接建立之后，启用 TCP Keepalive 的一端便会启动一个计时器，当这个计时器数值到达 0 之后（也就是经过tcp_keep-alive_time时间后，这个参数之后会讲到），一个 TCP 探测包便会被发出。这个 TCP 探测包是一个纯 ACK 包（规范建议，不应该包含任何数据，但也可以包含1个无意义的字节，比如0x0。），其 Seq号 与上一个包是重复的，所以其实探测保活报文不在窗口控制范围内。
  </p>
  <p>
   如果一个给定的连接在两小时内（默认时长）没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：
  </p>
  <ul list="ub723168a">
   <li fid="ue6bbb943">
    客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
   </li>
   <li fid="ue6bbb943">
    客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
   </li>
   <li fid="ue6bbb943">
    客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
   </li>
   <li fid="ue6bbb943">
    客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探测的响应。
   </li>
  </ul>
  <p>
   对于linux内核来说，应用程序若想使用TCP Keepalive，需要设置SO_KEEPALIVE套接字选项才能生效。
  </p>
  <p>
   有三个重要的参数：
  </p>
  <ul list="u3af271e0">
   <li fid="u73a4773d">
    tcp_keepalive_time，在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）。
   </li>
   <li fid="u73a4773d">
    tcp_keepalive_probes 在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次）
   </li>
   <li fid="u73a4773d">
    tcp_keepalive_intvl，在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。
   </li>
  </ul>
  <p>
   其他编程语言有相应的设置方法，这里只谈linux内核参数的配置。例如C语言中的setsockopt()函数，java的Netty服务器框架中也提供了相关接口。
  </p>
  <p>
   <strong>
    TCP Keepalive作用
   </strong>
  </p>
  <p>
   1）探测连接的对端是否存活
  </p>
  <p>
   在应用交互的过程中，可能存在以下几种情况：
  </p>
  <ul list="ud22d1045">
   <li fid="uf8ab7f37">
    客户端或服务器意外断电，死机，崩溃，重启。
   </li>
   <li fid="uf8ab7f37">
    中间网络已经中断，而客户端与服务器并不知道。
   </li>
  </ul>
  <p>
   利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。
  </p>
  <p>
   2）防止中间设备因超时删除连接相关的连接表
  </p>
  <p>
   中间设备如防火墙等，会为经过它的数据报文建立相关的连接信息表，并为其设置一个超时时间的定时器，如果超出预定时间，某连接无任何报文交互的话，
  </p>
  <p>
   中间设备会将该连接信息从表中删除，在删除后，再有应用报文过来时，中间设备将丢弃该报文，从而导致应用出现异常。
  </p>
  <p>
   <strong>
    TCP Keepalive可能导致的问题
   </strong>
  </p>
  <p>
   Keepalive 技术只是 TCP 技术中的一个可选项。因为不当的配置可能会引起一些问题，所以默认是关闭的。
  </p>
  <p>
   可能导致下列问题：
  </p>
  <ul list="u43497f63">
   <li fid="u3b8ef3cc">
    在短暂的故障期间，Keepalive设置不合理时可能会因为短暂的网络波动而断开健康的TCP连接
   </li>
   <li fid="u3b8ef3cc">
    需要消耗额外的宽带和流量
   </li>
   <li fid="u3b8ef3cc">
    在以流量计费的互联网环境中增加了费用开销
   </li>
  </ul>
  <h3>
   TCP如何保证有序？
  </h3>
  <p>
   问过的一些公司：快手(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP协议通过为每条信息添加顺序号来保证信息的有序性。
  </p>
  <p>
   每条信息都会包含一个序列号，用于指示这条信息在整个数据流中的顺序。当一端接收到的信息的序列号与预期的序列号不同时，它会等待接收到下一条预期的信息，直到收到预期的信息后才会将它们按照顺序传递给上层协议。这样，就可以保证信息的有序性。
  </p>
  <h3>
   UDP可以可靠传输吗？
  </h3>
  <p>
   可回答：1）UDP怎么实现像TCP一样的可靠传输？2）如何使用UDP完成可靠的传输？3）UDP的不稳定怎么解决呢？
  </p>
  <p>
   问过的一些公司：极致游戏(2022.10)，字节番茄小说(2022.09)，深信服(2022.09)，今日头条(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   通常情况下，UDP不提供可靠传输，但可以通过以下方式来实现像TCP一样的可靠传输：
  </p>
  <ol list="ua4cca644">
   <li fid="u5d293806">
    应用层重传：在应用层实现重传机制，当UDP收到的数据包丢失或错误时，应用层会再次发送数据包，直到收到确认为止。
   </li>
   <li fid="u5d293806">
    增加可靠性机制：在UDP协议上增加可靠性机制，包括检验和、重传、序列号、确认等，实现类似TCP的可靠传输。
   </li>
   <li fid="u5d293806">
    使用可靠传输层协议：在UDP的上层使用可靠传输层协议，如SCTP（Stream Control Transmission Protocol），实现可靠传输。
   </li>
  </ol>
  <h3>
   TCP怎么保证可靠连接（传输）？
  </h3>
  <p>
   可回答：1）TCP为什么可靠？2）TCP保证可靠性传输的手段有哪些？3）TCP如何保证数据包不丢、不重、不乱、完整性？4）TCP的可靠传输；5）TCP可靠性是如何实现的？6）
   <span class="lake-fontsize-12">
    TCP如何保证数据可靠性？7）TCP如何保证安全？
   </span>
  </p>
  <p>
   问过的一些公司：金山办公(2022.10)，海雀科技(2022.10)，字节(2022.09)(2022.07)(2021.10)(2021.09)，百度提前批(2022.08)，蔚来(2022.08)，大疆(2022.08)，快手(2022.08)x2，美团(2022.08)，字节飞书(2022.08)(2022.04)，中望(2022.08)，百度(2021.09)，今日头条(2021.09)，美团(2021.09)(2021.08)x2，腾讯(2021.08)，绿盟科技(2021.09)，Shoope(2021.07)，小米(2021.08)，字节抖音(2021.08)，趋势科技(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。
   </strong>
  </p>
  <p>
   校验和：字段长16位，是错误检查的字段，包括TCP头和TCP数据的内容计算得出，用于检查传输过程中出现的错误。
  </p>
  <p>
   序列号：字段长32位，是指TCP段数据的位置序号。根据序列号来判断是否存在重收、漏收、乱序等情况。
  </p>
  <p>
   确认应答：在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到的消息。这个消息叫做确认应答（ACK）。
  </p>
  <p>
   重发控制：如果某个报文段丢失，接收主机收到序号不连续的数据时，会为已经收到的数据返回确认应答。即使接收端收到的包序号不是连续的，也不会将数据丢弃，而是暂时保存至缓冲区。出现报文丢失时，同一个序号的确认应答将会被重复发送。如果发送端收到连续3次同一个确认应答，就会将对应的数据进行重发。这种机制比超时管理更高效，也被称为高速重发机制。
  </p>
  <p>
   连接管理：建立一个TCP连接需要发送3个包，这个过程叫作三次握手。断开一个TCP连接需要发送4个包，这个过程也称作四次挥手。
  </p>
  <p>
   窗口机制：通过可调节的窗口，TCP接收端可以告知希望的发送速度，控制数据流量。
  </p>
  <h3>
   TCP的拥塞控制
  </h3>
  <p>
   可回答：1）TCP/IP的拥塞控制；2）TCP的拥塞控制算法；3）介绍下拥塞控制算法；4）
   <span class="lake-fontsize-12">
    网络的拥塞控制有没有了解过？5）拥塞避免的方法
   </span>
  </p>
  <p>
   问过的一些公司：字节番茄小说(2022.09)，贝壳(2022.09)，字节抖音(2022.04)，字节(2022.09)(2022.08)x2(2022.07)(2022.03)(2022.01)(2021.10)(2021.09)，泰隆银行(2021.09)，猿辅导(2022.08)x2，腾讯(2022.08)，快手(2022.08)，翼支付(2022.08)，Momenta(2022.08)，民生科技(2022.08)，经纬恒润(2022.08)，腾讯音乐(2021.11)，今日头条(2021.09)，顺丰(2021.08)，转转(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    拥塞控制的目的是为了避免「发送方」的数据填满整个网络。通俗来说，就是
   </strong>
   <strong>
    防止过多的数据注入到网络中。
   </strong>
  </p>
  <p>
   <strong>
    为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。
   </strong>
  </p>
  <p>
   拥塞窗口cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。
  </p>
  <p>
   我们在前面提到过发送窗口swnd和接收窗口rwnd是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd=min(cwnd,rwnd)，也就是拥塞窗口和接收窗口中的最小值。
  </p>
  <p>
   拥塞窗口cwnd变化的规则：
  </p>
  <ul list="ud655d2af">
   <li fid="u30e69c2c">
    只要网络中没有出现拥塞，cwnd就会增大
   </li>
   <li fid="u30e69c2c">
    但网络中出现了拥塞，cwnd就减少
   </li>
  </ul>
  <p>
   拥塞控制主要是四个算法：
  </p>
  <ul list="u42184c20">
   <li fid="u9b4b37ff">
    慢启动
   </li>
   <li fid="u9b4b37ff">
    拥塞避免
   </li>
   <li fid="u9b4b37ff">
    拥塞发生
   </li>
   <li fid="u9b4b37ff">
    快速恢复
   </li>
  </ul>
  <p>
   <strong>
    1、慢启动
   </strong>
  </p>
  <p>
   TCP在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量。
  </p>
  <p>
   慢启动的算法记住一个规则就行：当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1。
  </p>
  <p>
   把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口cwnd就加倍。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。
  </p>
  <p>
   当cwnd &lt; ssthresh时，使用慢开始算法。
  </p>
  <p>
   当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
  </p>
  <p>
   当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞控制避免算法。
  </p>
  <p>
   <strong>
    2、拥塞避免
   </strong>
  </p>
  <p>
   让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。
  </p>
  <p>
   无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。
  </p>
  <p>
   <strong>
    3、
   </strong>
   <strong>
    快重传
   </strong>
  </p>
  <p>
   有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。
  </p>
  <p>
   快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。
  </p>
  <p>
   发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。
  </p>
  <p>
   <strong>
    4、快恢复
   </strong>
  </p>
  <p>
   当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。
  </p>
  <p>
   在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。采用这样的拥塞控制方法使得TCP的性能有明显的改进。
  </p>
  <h3>
   TCP的拥塞控制算法，QUIC是根据什么信息拥塞控制？为什么QUIC用rtt，而TCP用丢包却不用rtt控制？
  </h3>
  <p>
   问过的一些公司：快手(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP的拥塞控制算法主要包括慢启动、拥塞避免、快速恢复和快速重传等机制。
  </p>
  <p>
   QUIC是基于UDP协议的新一代传输协议，它也具有拥塞控制机制，但与TCP不同的是，QUIC使用了基于丢包率的拥塞控制算法。具体来说，QUIC在数据包中携带了额外的信息，包括数据包的发送时间戳、数据包的大小、接收端的反馈信息等，这些信息可以用来计算网络的丢包率，并根据丢包率来调整发送数据的速率。此外，QUIC还引入了前向纠错等技术，可以在一定程度上减少数据包的丢失和重传，提高传输的可靠性和效率。
  </p>
  <p>
   实际上，TCP也是使用了RTT（Round Trip Time）来控制拥塞窗口的大小。TCP协议通过测量从发送方到接收方的往返时间（即RTT），来估计当前网络的拥塞程度，从而控制数据包的发送速率。在TCP协议中，每次发送数据后，发送方会设置一个定时器，当定时器超时时，发送方会认为该数据包已经丢失，触发拥塞控制算法进行相应的调整，这就是TCP通过丢包来控制拥塞的机制。而且在TCP的拥塞控制算法中，使用了很多与RTT相关的机制，如TCP的慢启动算法就是通过动态调整拥塞窗口的大小来控制发送速率，并且在算法中使用了RTT的估计值来调整拥塞窗口的大小。
  </p>
  <p>
   相比之下，QUIC使用RTT来控制拥塞窗口的大小，而不是通过丢包来控制拥塞的机制。这是因为QUIC在设计时考虑到了实际网络环境中的问题，如网络拥塞、网络丢包、数据包乱序等，因此采用了一些新的机制来解决这些问题，如前向纠错、快速重传、拥塞控制算法等，从而提高了数据传输的效率和可靠性。而且QUIC还在设计时充分考虑了移动设备和无线网络的特点，具有更好的适应性和灵活性。因此，可以说QUIC是一种更为先进、高效、可靠的传输协议，可以适用于不同的网络环境和应用场景。
  </p>
  <h3>
   为什么要用三个连续重复确认是发生轻微拥塞？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   因为网络包有时会乱序，乱序的包一样会触发重复的 ACK，但是为了乱序而重传没有必要（会按照 seq 进行重组）。由于一般乱序的距离不会相差太大，比如 2 号包也许会跑到 4 号包后面，但不太可能跑到 6 号包后面，所以限定成 3 个或以上可以在很大程度上避免因乱序而触发快速重传。
  </p>
  <h3>
   TCP的流量控制
  </h3>
  <p>
   问过的一些公司：字节(2022.09)(2022.07)，贝壳(2022.09)，猿辅导(2022.08)x2，民生科技(2022.08)，经纬恒润(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   每个TCP连接的⼀侧主机都会有⼀个socket缓冲区，缓冲区会为每个连接设置接收缓存和发送缓存，当TCP建⽴连接后，从应⽤程序产⽣的数据就会到达接收⽅的接收缓冲区中，接收⽅的应⽤程序并不⼀定会⻢上读取缓冲区的数据，它需要等待操作系统分配时间⽚。如果此时发送⽅的应⽤程序产⽣数据过快，⽽接收⽅读取接收缓冲区的数据相对较慢的话，那么接收⽅中缓冲区的数据将会溢出。
  </p>
  <p>
   <strong>
    TCP通过流量控制服务(flow-control service)来消除缓冲区溢出的情况。流量控制是⼀个速度匹配服务，即发送⽅的发送速率与接受方应用程序的读取速率相匹配。
   </strong>
  </p>
  <p>
   TCP通过使用⼀个接收窗口(receive window)的变量来提供流量控制。接收窗口会给发送方⼀个指示到底还有多少可用的缓存空间。发送端会根据接收端的实际接受能力来控制发送的数据量。
  </p>
  <p>
   接收端主机向发送端主机通知自己可以接收数据的大小，发送端会发送不超过这个限度的数据，这个大小限度就是窗口大小，TCP的首部有⼀个接收窗口，这个字段就是用于流量控制，它⽤于指示接收方能够/愿意接收的字节数量。
  </p>
  <p>
   下面来看个案例，假设以下场景：
  </p>
  <ul list="u2a311d78">
   <li fid="u2ac01f3b">
    客户端是接收方，服务端是发送方
   </li>
   <li fid="u2ac01f3b">
    假设接收窗口和发送窗口相同，都为200
   </li>
   <li fid="u2ac01f3b">
    假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响
   </li>
  </ul>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684639820089-812b8bc5-d105-4260-8d6e-587dc4ddee6d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   根据上图的流量控制，说明下每个过程：
  </p>
  <ol list="ua2a04dfd">
   <li fid="uff4407a9">
    客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。
   </li>
   <li fid="uff4407a9">
    服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 Usable 减少为 120 字节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号是 321。
   </li>
   <li fid="uff4407a9">
    客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，RCV.NXT 也就指向 321，这意味着客户端期望的下一个报文的序列号是 321，接着发送确认报文给服务端。
   </li>
   <li fid="uff4407a9">
    服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法再继续发送数据。
   </li>
   <li fid="uff4407a9">
    客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，
    <span class="lake-fontsize-12">
     RCV.NXT
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     也就指向 441，接着发送确认报文给服务端。
    </span>
   </li>
   <li fid="uff4407a9">
    服务端收到对 80 字节数据的确认报文后，
    <span class="lake-fontsize-12">
     SND.UNA
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     指针往右偏移后指向 321，于是可用窗口
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     Usable
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     增大到 80。
    </span>
   </li>
   <li fid="uff4407a9">
    服务端收到对 120 字节数据的确认报文后，
    <span class="lake-fontsize-12">
     SND.UNA
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     指针往右偏移后指向 441，于是可用窗口
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     Usable
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     增大到 200。
    </span>
   </li>
   <li fid="uff4407a9">
    服务端可以继续发送了，于是发送了 160 字节的数据后，
    <span class="lake-fontsize-12">
     SND.NXT
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     指向 601，于是可用窗口
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     Usable
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     减少到 40。
    </span>
   </li>
   <li fid="uff4407a9">
    客户端收到 160 字节后，接收窗口往右移动了 160 字节，
    <span class="lake-fontsize-12">
     RCV.NXT
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     也就是指向了 601，接着发送确认报文给服务端。
    </span>
   </li>
   <li fid="uff4407a9">
    服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是
    <span class="lake-fontsize-12">
     SND.UNA
    </span>
    <span class="lake-fontsize-12">
     指针偏移了 160 后指向 601，可用窗口
    </span>
    <span class="lake-fontsize-12">
     Usable
    </span>
    <span class="lake-fontsize-12">
     也就增大至了 200。
    </span>
   </li>
  </ol>
  <h3>
   流量控制算法了解哪些？
  </h3>
  <p>
   问过的一些公司：好未来(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、流量控制算法简介
   </strong>
  </p>
  <p>
   流量控制在计算机领域称为过载保护。何为过载保护？所谓“过载”，即需求超过了负载能力;而“保护”则是指当“过载”发生了，采取必要的措施保护自己不受“伤害”。在计算机领域，尤其是分布式系统领域，“过载保护”是一个重要的概念。一个不具备“过载保护”功能的系统，是非常危险和脆弱的，很可能由于瞬间的压力激增，引起“雪崩效应”，导致系统的各个部分都同时崩溃，停止服务。这就好像在没有保险丝的保护下，电压突然变高，导致所有的电器都会被损坏一样，“过载保护”功能是系统的“保险丝”。
  </p>
  <p>
   如今互联网领域，也借鉴了这一思路扛住双十二， 控制网络数据传输的速率，使流量以比较均匀的速度向外发送。 最终实现优化性能，减少延迟和提高带宽等。
  </p>
  <p>
   <strong>
    2、漏桶算法
   </strong>
  </p>
  <p>
   漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684639884341-643a5b15-ac65-4dba-9c49-ef2ec60a8e0f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的参数，所以即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使某一个单独的流突发到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。
  </p>
  <p>
   而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法可以结合起来为网络流量提供更大的控制。
  </p>
  <p>
   3、
   <strong>
    令牌桶算法
   </strong>
  </p>
  <p>
   令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684639956615-f3e4bf01-6ef2-4080-b3df-e6dda556d5ad.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684640776008-9d0a8fb5-8f4e-4102-921b-e37e5c422220.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   令牌桶算法的基本过程如下：
  </p>
  <ul list="uadeb4568">
   <li fid="ub5420a39">
    假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中；
   </li>
   <li fid="ub5420a39">
    假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；
   </li>
   <li fid="ub5420a39">
    当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络；
   </li>
   <li fid="ub5420a39">
    如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外；
   </li>
   <li fid="ub5420a39">
    算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。
   </li>
   <li fid="ub5420a39">
    对于在流量限制外的数据包可以以不同的方式处理：
   </li>
   <li fid="ub5420a39">
    它们可以被丢弃；
   </li>
   <li fid="ub5420a39">
    它们可以排放在队列中以便当令牌桶中累积了足够多的令牌时再传输；
   </li>
   <li fid="ub5420a39">
    它们可以继续发送，但需要做特殊标记，网络过载的时候将这些特殊标记的包丢弃。
   </li>
  </ul>
  <p>
   漏桶和令牌桶的区别
  </p>
  <ul list="uaa0f71c7">
   <li fid="ubaf19acf">
    两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。
   </li>
   <li fid="ubaf19acf">
    在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的上限，所以它适合于具有突发特性的流量。
   </li>
  </ul>
  <p>
   令牌桶原理
  </p>
  <ul list="u45d1d86d">
   <li fid="ubc4e29e4">
    令牌桶是网络设备的内部存储池，而令牌则是以给定速率填充令牌桶的虚拟信息包。每个到达的令牌都会从数据队列领出相应的数据包进行发送，发送完数据后令牌被删除。
   </li>
   <li fid="ubc4e29e4">
    请求注解（RFC）中定义了两种令牌桶算法     单速率三色标记算法和双速率三色标记算法，其评估结果都是为报文打上红、黄、绿三色标记。
   </li>
   <li fid="ubc4e29e4">
    QoS会根据报文的颜色，设置报文的丢弃优先级，其中单速率三色标记比较关心报文尺寸的突发，而双速率三色标记则关注速率上的突发，两种算法都可工作于色盲模式和非色盲模式。以下结合这两种工作模式介绍一下RFC中所描述的这两种算法。
   </li>
  </ul>
  <p>
   <strong>
    单速率三色标记算法
   </strong>
  </p>
  <p>
   网络工程师任务小组（IETF）的RFC文件定义了单速率三色标记算法，评估依据以下3个参数：承诺访问速率(CIR)，即向令牌桶中填充令牌的速率；承诺突发尺寸(CBS)，即令牌桶的容量，每次突发所允许的最大流量尺寸（注：设置的突发尺寸必须大于最大报文长度）；超额突发尺寸(EBS)。
  </p>
  <p>
   一般采用双桶结构：C桶和E桶。Tc表示C桶中的令牌数，Te表示E桶中令牌数，两桶的总容量分别为CBS和EBS。初始状态时两桶是满的，即Tc和Te初始值分别等于CBS和EBS。令牌的产生速率是CIR，通常是先往C桶中添加令牌，等C桶满了，再往E桶中添加令牌，当两桶都被填满时，新产生的令牌将会被丢弃。
  </p>
  <p>
   色盲模式下，假设到达的报文长度为B。若报文长度B小于C桶中的令牌数Tc，则报文被标记为绿色，且C桶中的令牌数减少B；若Tc&lt;B &lt;Te，则标记为黄色，E和C桶中的令牌数均减少B；若B &gt;Te，标记为红色，两桶总令牌数都不减少。
  </p>
  <p>
   在非色盲模式下，若报文已被标记为绿色或B &lt;Tc，则报文被标记为绿色，Tc减少B；若报文已被标记为黄色或Tc&lt;B &lt;Te，则标记为黄色，且Te减少B；若报文已被标记为红色或B &gt;Te，则标记为红色，Tc和Te都不减少。
  </p>
  <p>
   <strong>
    双速率三色标记算法
   </strong>
  </p>
  <p>
   IETF的RFC文件定义了双速率三色算法，主要是根据4种流量参数来评估：CIR、CBS、峰值信息速率(PIR)，峰值突发尺寸(PBS)。前两种参数与单速率三色算法中的含义相同，PIR这个参数只在交换机上才有，路由器没有这个参数。该值必须不小于CIR的设置值，如果大于CIR，则速率限制在CIR于PRI之间的一个值。
  </p>
  <p>
   与单速率三色标记算法不同，双速率三色标记算法的两个令牌桶C桶和P桶填充令牌的速率不同，C桶填充速率为CIR，P桶为PIR；两桶的容量分别为CBS和PBS。用Tc和Tp表示两桶中的令牌数目，初始状态时两桶是满的，即Tc和Tp初始值分别等于CBS和PBS。
  </p>
  <p>
   色盲模式下，如果到达的报文速率大于PIR，超过Tp+Tc部分无法得到令牌，报文被标记为红色，未超过Tp+Tc而从P桶中获取令牌的报文标记为黄色，从C桶中获取令牌的报文被标记为绿色；当报文速率小于PIR，大于CIR时，报文不会得不到令牌，但超过Tp部分报文将从P桶中获取令牌，被标记为黄色报文，从C桶中获取令牌的报文被标记为绿色；当报文速率小于CIR时，报文所需令牌数不会超过Tc，只从C桶中获取令牌，所以只会被标记为绿色报文。
  </p>
  <p>
   在非色盲模式下，如果报文已被标记为红色或者超过Tp+Tc部分无法得到令牌的报文，被标记为红色；如果标记为黄色或者超过Tc未超过Tp部分报文记为黄色；如果报文被标记为绿或未超过Tc部分报文，被标记为绿色。
  </p>
  <h3>
   TCP连接突然断网会收到请求吗？
  </h3>
  <p>
   问过的一些公司：掌趣(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   如果 TCP 连接突然断网，那么通常情况下不会收到请求。这是因为 TCP 连接在断网时会进入超时状态，并触发重传机制，尝试重新连接。如果在超时时间内重新连接成功，那么 TCP 连接会恢复正常。否则，TCP 连接会被关闭，不会收到任何请求。
  </p>
  <p>
   当TCP连接突然断网时，它会检测到网络连接丢失，并采取相应的措施。如果是客户端断网，它会发送一个重传请求（RTO）给服务端，要求服务端重新发送丢失的数据。如果是服务端断网，它会等待一段时间，看看网络是否恢复，如果网络没有恢复，它会断开连接，并向客户端发送一个错误报文，表示连接失败。
  </p>
  <p>
   当然，如果断网时间过长，超过了 TCP 连接超时时间，那么可能会收到请求。但这种情况很少见，通常情况下，TCP 连接在断网时不会收到请求。
  </p>
  <h3>
   TCP数据包最大为什么是65495字节？
  </h3>
  <p>
   问过的一些公司：华为(2021.11)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP数据包的最大长度为65495字节，主要是
   <strong>
    受IP数据报的限制
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   IP数据报的总长度最大为65535字节，这个长度包括了IP首部和数据部分，而
   <strong>
    IP首部的长度一般为20字节
   </strong>
   <span class="lake-fontsize-12">
    ，所以数据部分的长度最大为65535-20=65515字节。
   </span>
  </p>
  <p>
   而
   <strong>
    TCP首部的长度一般为20字节
   </strong>
   <span class="lake-fontsize-12">
    ，所以TCP数据包的最大长度为65515-20=65495字节。
   </span>
  </p>
  <p>
   但是，实际上TCP数据包的长度一般比这个值小，因为网络中有些设备（如路由器）有最大传输单元（Maximum Transmission Unit，MTU）的限制，通常MTU的值小于65495字节。
  </p>
  <h3>
   TCP粘包如何产生的，如何解决？
  </h3>
  <p>
   可回答：1）了解TCP粘包吗？怎么解决？2）TCP的半包、粘包的解决方案；3）
   <span class="lake-fontsize-12">
    HTTP如何解决粘包问题的？
   </span>
  </p>
  <p>
   问过的一些公司：睿联视(2022.10)，海康威视(2022.09)，4399(2022.09)，阿里巴巴杭州淘系(2022.08)，米哈游(2022.08)，好未来(2022.08)，科大讯飞(2022.08)，蔚来(2022.08)，二元互动(2022.08)，Zoom(2022.08)x2，Shopee(2022.06)，momenta(2021.11)x2，欧科云链(2022.04)，美团(2021.09)，携程(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。
  </p>
  <p>
   要解决粘包问题，通常有以下几种方法：
  </p>
  <ol list="uf3c2b428">
   <li fid="u019e11fd">
    在数据包中添加特殊的分隔符，例如回车符、制表符等。在接收端，可以通过识别分隔符来区分数据包。
   </li>
   <li fid="u019e11fd">
    在数据包中添加长度信息。在接收端，可以通过长度信息来识别数据包的边界。
   </li>
   <li fid="u019e11fd">
    使用消息拆分机制。例如，在应用层，可以把大消息分成多个小的消息块，每个消息块都有自己的序号，接收端可以根据序号来组装消息。
   </li>
  </ol>
  <h3>
   TCP拆包
  </h3>
  <p>
   可回答：1）如何解决TCP数据拆包问题？
  </p>
  <p>
   问过的一些公司：4399(2022.09)，蔚来(2022.08)，二元互动(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   如果数据包长度太大，超过MSS（最大TCP报文长度，不包括TCP和IP的首部）的长度，TCP就会将报文分开传输，这样就会造成一个完整的数据报文在传输过程中被分成了几部分，这就是拆包。
  </p>
  <p>
   TCP拆包常见原因：
  </p>
  <ul list="uc96c1adc">
   <li fid="u5c9a42c2">
    要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
   </li>
   <li fid="u5c9a42c2">
    待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
   </li>
  </ul>
  <p>
   解决方案：
  </p>
  <ul list="ue7718950">
   <li fid="ueffab5fe">
    发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
   </li>
   <li fid="ueffab5fe">
    发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
   </li>
   <li fid="ueffab5fe">
    可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
   </li>
  </ul>
  <h3>
   TCP开源库？
  </h3>
  <p>
   问过的一些公司：momenta(2021.11)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   常见的TCP开源库有libevent、libuv和boost.asio等。这些库都提供了丰富的功能，可以帮助开发人员快速实现复杂的网络应用。
  </p>
  <p>
   libevent是一个事件通知库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue、IOCP等系统调用管理事件机制。
  </p>
  <p>
   libuv
   <span class="lake-fontsize-12">
    为开人员提供了一套事件循环和基于I/O(或其他活动)通知的回调函数，libuv 提供了一套核心的工具集，例如定时器，非阻塞网络编程的支持，异步访问文件系统，子进程以及其他功能。
   </span>
  </p>
  <p>
   Boost.Asio是一个跨平台的、主要用于网络和其他一些底层输入/输出编程的C++库，在网络通信、COM串行端口和文件上成功地抽象了输入输出的概念，使我们可以基于这些进行同步或者异步的输入输出编程，作为一个跨平台的库，Boost.Asio可以在大多数操作系统上使用，能同时支持数千个并发的连接，并且提供了一套可以支持传输控制协议(TCP)socket、用户数据报协议(UDP)socket和Internet控制消息协议(IMCP)socket的API，且我们还可以对其进行扩展以支持我们自己的协议。
  </p>
  <p>
   此外，还有一些操作系统，如Linux和Windows，提供了自己的TCP开源库。例如，Windows提供了Winsock库，Linux提供了Berkeley Socket接口，都可以用来开发TCP应用。
  </p>
  <h3>
   TCP的状态机，详细介绍
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    TCP状态机的切换
   </span>
  </p>
  <p>
   问过的一些公司：字节(2022.08)(2022.01)(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP
   <span class="lake-fontsize-12">
    在三次握手和四次挥手的过程中的几种状态，TCP的状态变迁如下图所示
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670600837487-5e547c04-45af-44ea-8da4-4de641be07f3.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   图中一共包括TCP的11个状态：
  </p>
  <ol list="u9f5ffcba">
   <li fid="uc78b1a8c">
    LISTEN：TCP正等待从对端TCP节点发来的连接请求
   </li>
   <li fid="uc78b1a8c">
    SYN_SENT：TCP发送一个SYN报文，代表应用程序执行了一个主动打开的操作，并等待对端回应以此完成连接的建立
   </li>
   <li fid="uc78b1a8c">
    SYN_RECV：之前处在LISTEN状态的TCP节点收到了对端发送的SYN报文，并已经通过发送SYN/ACK报文做出了相应（即，这个TCP报文同时设置了SYN和ACK位），正等到对端TCP节点发送一个ACK以此完成连接的建立，进入ESTABLISHED
   </li>
   <li fid="uc78b1a8c">
    ESTABLISHED：与对端TCP节点间的连接建立完成。数据报文此时可以再两个TCP节点间双向交换
   </li>
   <li fid="uc78b1a8c">
    FIN_WAIT1：应用程序关闭了连接。TCP节点发送一个FIN报文到对端，以此终止本段的连接，并等待对端发来的ACK。这个状态以及接下来的三种状态都与应用程序执行主动关闭有关——也就是说，首先关闭本段连接的应用程序
   </li>
   <li fid="uc78b1a8c">
    FIN_WAIT2：之前处在FIN_WAIT1状态的TCP节点现在已经收到了对端TCP节点发来的ACK（半关闭状态）
   </li>
   <li fid="uc78b1a8c">
    CLOSING：之前处在FIN_WAIT1状态的TCP节点正在等待对端发送ACK，但却收到了FIN。这表示对端也正在尝试执行一个主动关闭。（换句话说，这两个TCP节点几乎在同一时刻发送了FIN报文。即同时关闭）
   </li>
   <li fid="uc78b1a8c">
    TIME_WAIT：完成主动关闭后，TCP节点接收到了FIN报文。这表示对端执行了一个被动关闭。此时这个TCP节点将在TIME_WAIT状态中等待一段固定的时间，这是为了确保TCP连接能够可靠的终止，同时为了确保任何老的重复报文在重新建立同样的连接之前在网络中超时小时。当这个固定的时间段超时后，连接就关闭了，相关的内核资源得到释放。
   </li>
   <li fid="uc78b1a8c">
    CLOSE_WAIT：TCP节点从对端收到FIN报文后将处在CLOSE_WAIT状态。该状态以及接下来的一个状态都同应用程序执行的被动关闭有关，也就是第二个执行关闭操作的应用。
   </li>
   <li fid="uc78b1a8c">
    LAST_ACK：应用程序执行被动关闭，而之前处于CLOSE_WAIT状态的TCO节点发送一个FIN报文给对端，并等待对端的确认。当收到对端发来的确认ACK报文时，连接关闭，相关的内核资源都会得到释放。
   </li>
   <li fid="uc78b1a8c">
    LCLOSED：关闭状态。
   </li>
  </ol>
  <p>
   <strong>
    正常的TCP连接和断开状态切换介绍
   </strong>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684643087317-795654a9-27e0-478e-9fae-63ec7fdafc14.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如图所示，一个正常的TCP过程，状态变化为：
  </p>
  <p>
   <strong>
    服务器：
   </strong>
   <span class="lake-fontsize-12">
    CLOSED-- LISTEN--SYN_RCVD-- ESTABLISHED--CLOSE_WAIT-- LAST_ACK--CLOSED
   </span>
  </p>
  <p>
   <strong>
    客户：
   </strong>
   <span class="lake-fontsize-12">
    CLOSED-- SYN_SENT-- ESTABLISHED--FIN_WAIT1-- FIN_WAIT2--TIME_WAIT--CLOSED
   </span>
  </p>
  <p>
   当然上述过程并不绝对，因为服务器在这是被动方，客户是主动方，而实际情况中，虽然客户多数情况下是主动方，但是由于服务器可能要踢掉某个“僵尸”连接，而成为主动方。发生这样的情况，只需将上述的过程中的服务器与客户对调即可。
  </p>
  <h3>
   TCP慢启动
  </h3>
  <p>
   可回答：1）慢启动实现的具体过程
  </p>
  <p>
   问过的一些公司：经纬恒润(2022.08)，百度(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？
  </p>
  <p>
   慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。
  </p>
  <p>
   这里假定拥塞窗口
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    cwnd
   </span>
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    和发送窗口
   </span>
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    swnd
   </span>
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    相等，下面举个栗子：
   </span>
  </p>
  <ul list="u9c4743ab">
   <li fid="u2fa29d4c">
    连接建立完成后，一开始初始化
    <span class="lake-fontsize-12">
     cwnd = 1
    </span>
    <span class="lake-fontsize-12">
     ，表示可以传一个
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     MSS
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     大小的数据。
    </span>
   </li>
   <li fid="u2fa29d4c">
    当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个
   </li>
   <li fid="u2fa29d4c">
    当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个
   </li>
   <li fid="u2fa29d4c">
    当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。
   </li>
  </ul>
  <p>
   慢启动算法的变化过程如下图：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684643603402-9b62e5cf-ec86-4bce-ab78-575bafbdfcd4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   可以看出慢启动算法，发包的个数是
   <strong>
    指数性的增长
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   那慢启动涨到什么时候是个头呢？
  </p>
  <p>
   为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。
  </p>
  <ul list="uf22cdc47">
   <li fid="u66bdf035">
    当cwnd &lt; ssthresh时，使用慢开始算法。
   </li>
   <li fid="u66bdf035">
    当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
   </li>
   <li fid="u66bdf035">
    当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞控制避免算法。
   </li>
  </ul>
  <h3>
   TCP如何知道流读到哪了？
  </h3>
  <p>
   问过的一些公司：米哈游(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP通过维护一个序列号来确定数据包的位置。
  </p>
  <p>
   每个数据包都有一个序列号，该序列号表示数据包中的字节在整个流中的位置。当接收方接收到数据包时，它会检查数据包的序列号，并根据这个序列号来确定数据包在流中的位置。这样，TCP就可以知道流读到哪了。
  </p>
  <h3>
   TCP协议里面的seqNum是怎么初始化的？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP协议中的seqNum是由发送方初始化的。
  </p>
  <p>
   当发送方开始发送数据时，它会为第一个数据包分配一个seqNum。然后，对于每个后续的数据包，seqNum都会增加，以表示这些数据包在整个流中的位置。这样，发送方就可以通过seqNum来确定数据包在流中的位置，并将这些数据包发送到接收方。接收方也可以通过seqNum来确定数据包在流中的位置，并将这些数据包重新组装成完整的数据流。
  </p>
  <h3>
   什么标志能使TCP缓冲区满前就发送数据？
  </h3>
  <p>
   问过的一些公司：奇安信(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   PSH+URG
  </p>
  <p>
   <strong>
    URG（紧急位）
   </strong>
   <span class="lake-fontsize-12">
    ：当URG=1时，表明紧急指针字段有效，它告诉系统此报文中有紧急数据，应尽快传送（相当于高优先级的数据）。而不需要按原来的排队顺序来传送。
   </span>
  </p>
  <p>
   当URG=1时，发送应用进程告诉发送方的TCP有紧急数据要传送，于是紧急发送方就把紧急数据插入到本报文段数据的最前面，而紧急数据后面的数据依然是普通数据，这时要与首部中的紧急指针字段配合使用。
  </p>
  <p>
   <strong>
    PSH（推送位）
   </strong>
   <span class="lake-fontsize-12">
    ：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后就能收到对方的响应，这种情况下，可以使用推送操作，PSH=1时，立即创建一个报文段发送出去，接受方收到报文段的时候，就尽快的接受交付应用进程，而不再等到缓存满了再向上交付。
   </span>
  </p>
  <p>
   <strong>
    两者的区别
   </strong>
  </p>
  <p>
   当URG=1时，报文段中含有紧急数据，紧急指针指向包内数据段的某个字节（数据从第一字节到指针所指的数据就是紧急数据）接受端收到此报文后先处理紧急数据，不会经过缓冲区，但是通常我们大家的理解是TCP往上层交付数据的时候，要等到缓冲区满了才可以。
  </p>
  <p>
   当PSH=1的时候，接受端收到PSH为1的报文后就立即将接受缓冲区内数据向上交付给应用程序，则不会等到缓冲区的数据满了才交付，（但此时交付的还是缓冲区的数据）但是如果URG=1，是不用通过缓冲区而直接交付的。
  </p>
  <h3>
   TCP四次挥手为什么有Time_Wait状态？
  </h3>
  <p>
   可回答：1）TCP有个状态是Time_Wait，这个具体是在哪儿，作用是什么？2）为什么要time_wait？3）TIME_WAIT的作用；4）
   <span class="lake-fontsize-12">
    四次挥手的time_wait状态了解吗？
   </span>
   <span class="lake-fontsize-12">
    5）TIME_WAIT状态是什么？
   </span>
  </p>
  <p>
   问过的一些公司：字节基础架构北京(2022.10)，OPPO(2022.09)，字节飞书(2022.08)，好未来(2022.08)x2，腾讯(2022.05)，字节抖音(2022.04)，字节(2021.10)(2021.09)，momenta(2021.11)，字节番茄小说(2021.10)，拼多多(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    TIME_WAIT 是「主动关闭方」断开连接时的最后一个状态
   </strong>
   <span class="lake-fontsize-12">
    ，该状态会持续 *2MSL(Maximum Segment Lifetime)* 时长，之后进入CLOSED 状态。
   </span>
  </p>
  <p>
   <strong>
    设计 TIME_WAIT 状态，主要有两个原因（作用）：
   </strong>
  </p>
  <ul list="u703515cc">
   <li fid="u6bc4f9ef">
    <strong>
     防止历史连接中的数据，被后面相同四元组的连接错误的接收；
    </strong>
   </li>
   <li fid="u6bc4f9ef">
    <strong>
     保证「被动关闭连接」的一方，能被正确的关闭
    </strong>
   </li>
  </ul>
  <p>
   <strong>
    原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收
   </strong>
  </p>
  <p>
   我们知道，
   <strong>
    序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670343872168-686f2bd8-4f35-4d57-8e22-870e096dcc4a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ul list="u9e2bd006">
   <li fid="uda3aa617">
    服务端在关闭连接之前发送的
    <span class="lake-fontsize-12">
     SEQ = 301
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     报文，被网络延迟了。
    </span>
   </li>
   <li fid="uda3aa617">
    接着，服务端以相同的四元组重新打开了新连接，前面被延迟的
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     SEQ = 301
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。
    </span>
   </li>
  </ul>
  <p>
   为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    2MSL
   </span>
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    时长，这个时间
   </span>
   <strong>
    足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
   </strong>
  </p>
  <p>
   <strong>
    原因二：保证「被动关闭连接」的一方，能被正确的关闭
   </strong>
  </p>
  <p>
   如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。
  </p>
  <p>
   假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSED 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670343872037-5b9c25ca-6f0c-4009-b337-33450454ebd2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。
  </p>
  <p>
   为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670343871948-685a3d63-9cd3-4f14-bfcd-6a6d164683f2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。
  </p>
  <h3>
   close_wait和time_wait是什么？
  </h3>
  <p>
   可回答：1）第3次挥手后，主动关闭的一方会有一个TIME-WAIT的状态对吧，了解吗？2）
   <span class="lake-fontsize-12">
    TCP连接CloseWati和TimeWait状态
   </span>
  </p>
  <p>
   问过的一些公司：同花顺(2022.10)，字节(2021.08)，字节抖音(2021.08)，转转(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   close_wait和time_wait是TCP状态。
  </p>
  <p>
   当一个TCP连接处于close_wait状态时，它表示客户端已经发送了一个FIN包给服务器，表示它已经准备好关闭连接，但是远程端还没有发送应答，正在等待服务器的ACK应答。
  </p>
  <p>
   当一个TCP连接处于time_wait状态时，它表示服务器已经发送了一个FIN包给客户端，并且客户端已经发送了一个ACK报文表示它已经收到了服务器的FIN报文，并在等待2MSL（最大报文段生存期）时间后终止连接，在这段时间内，连接处于time_wait状态。
  </p>
  <p>
   这两个状态都表示TCP连接正在关闭。
  </p>
  <h3>
   TIME_WAIT状态原理，过多怎么办？
  </h3>
  <p>
   可回答：1）服务端有大量TIME_WAIT的原因，如何处理上述情况？
  </p>
  <p>
   问过的一些公司：好未来(2022.08)，大应科技(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   当一个连接在结束之后，服务器端会将该连接置于 TIME_WAIT 状态，这是为了确保所有的数据都已经被正确传输。这个状态会持续一段时间，通常是 30 秒到 4 分钟。
   <strong>
    如果服务器端有大量的 TIME_WAIT 连接，这可能表明服务器正在处理大量的短连接，或者连接正在被频繁建立和断开
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   要解决这个问题，可以考虑以下解决方案：
  </p>
  <ul list="u0e0fa104">
   <li fid="ucc8cab35">
    限制 TIME_WAIT 连接的数量。你可以通过修改操作系统的参数来限制 TIME_WAIT 连接的数量，以免它们占用过多的系统资源。
   </li>
   <li fid="ucc8cab35">
    对于频繁建立和断开的连接，尝试使用长连接。长连接可以节省建立连接和断开连接所需的时间和资源，并且可以提高服务器的性能。
   </li>
   <li fid="ucc8cab35">
    对于短连接，尝试重用连接。这样可以避免频繁地建立和断开连接，减少 TIME_WAIT 连接的数量。
   </li>
  </ul>
  <p>
   解决服务器端大量 TIME_WAIT 连接的问题，需要综合考虑多种因素，并通过不同的方法来进行调整和优化。
  </p>
  <h3>
   time_wait和close_wait的区别？
  </h3>
  <p>
   问过的一些公司：字节(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   close_wait状态表示客户端在等待服务器的响应，而time_wait状态表示服务器在等待客户端的响应。
  </p>
  <h3>
   实际开发中，如果出现大量的time-wait或close-wait，可能是什么原因？
  </h3>
  <p>
   可回答：1）在服务器端有大量连接出现了CLOSE-WAIT转态，可能是什么原因？
  </p>
  <p>
   问过的一些公司：金山办公(2022.10)，快手(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   如果是出现大量time-wait有可能是因为过多的短链接，close-wait可能是由于阻塞超时等。
  </p>
  <h3>
   断开连接中CLOSE-WAIT状态在哪一方？
  </h3>
  <p>
   问过的一些公司：金山办公(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   CLOSE-WAIT 状态是一种 TCP 协议中的状态，它表示在一条网络连接中，一方已经发送了一个关闭连接的请求，而另一方还没有响应。
  </p>
  <p>
   在这种情况下，接收到关闭连接请求的一方会进入 CLOSE-WAIT 状态，直到收到另一方的响应，或者在超时后自动关闭连接。
  </p>
  <p>
   因此，在一条网络连接中，CLOSE-WAIT 状态只会出现在接收到关闭连接请求的一方。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670652952013-cbfa992e-4d5d-407d-825d-c51b334b5f0c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    在TCP四次挥手中，CLOSE-WAIT 是出现在服务端。
   </strong>
  </p>
  <p>
   当server 收到client发过来的断开连接的FIN包以后，会进入CLOSE_WAIT状态，并向上层应用通告这个消息，同时返回ACK ，至此client到server的连接断开了。
  </p>
  <p>
   上层应用处理完相关的信息以后会向client发送FIN， 进入LAST_ACK状态，等待client返回ACK ,如果收到ACK，至此server到client的连接断开，server进入CLOSED状态。
  </p>
  <h3>
   一个主机上最多能有多少TCP连接？
  </h3>
  <p>
   问过的一些公司：奇安信(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    TCP连接的客户端机：
   </strong>
   <span class="lake-fontsize-12">
    每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。
   </span>
  </p>
  <p>
   <strong>
    TCP连接的服务器机：
   </strong>
   <span class="lake-fontsize-12">
    每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3.3K的内存。
   </span>
  </p>
  <h3>
   为什么time_wait有2MSL？
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    2MSL是什么？为什么等2MSL？2）
   </span>
   <span class="lake-fontsize-12">
    TCP四次挥手过程？为什么等待2MSL？
   </span>
  </p>
  <p>
   问过的一些公司：腾讯(2022.08)，有赞(2021.09)，字节(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP断开连接时的四次挥手中，客户端在发送最后的ACK后要进入TIME-WAIT状态，这个状态时长为2倍MSL。
  </p>
  <p>
   TIME-WAIT时长为2 MSL这主要有两个原因
  </p>
  <ul list="u17b0da03">
   <li fid="uff375c5c">
    尽量让服务端收到最后的ACK
   </li>
   <li fid="uff375c5c">
    确保当前连接的报文不会出现在下一次连接中
   </li>
  </ul>
  <p>
   参考《Unix 网络编程 卷1（第三版）》，专业一点的说法是
  </p>
  <ul list="u17775e0c">
   <li fid="u0179be88">
    可靠地实现TCP全双工连接的终止
   </li>
   <li fid="u0179be88">
    允许老的重复分节在网络中消逝
   </li>
  </ul>
  <h3>
   fin_wait2状态下是否可以进行接受数据和发送数据？
  </h3>
  <p>
   问过的一些公司：同程旅行(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   在 fin_wait2 状态中，TCP 连接可以接受数据，但是不能发送数据。
  </p>
  <p>
   fin_wait2 状态通常表示一个 TCP 连接正在等待最终的确认信息，以确定连接的另一端是否已经关闭。如果连接的另一端发送了这种确认信息，那么连接将进入 TIME_WAIT 状态。在这个状态中，连接将不再能够接受或发送数据。
  </p>
  <p>
   综上，在 fin_wait2 状态下，TCP 连接可以接受数据，但是不能发送数据。
  </p>
  <h3>
   你知道什么时候TCP会发送rst报文吗？
  </h3>
  <p>
   问过的一些公司：字节(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP的rst报文通常用于拒绝错误的连接请求或重置已经建立的连接。
  </p>
  <p>
   来看下以下几种情形：
  </p>
  <p>
   1）客户端尝试与服务器未对外提供服务的端口建立TCP连接，服务器将会直接向客户端发送reset报文。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670659744576-f103ec9f-f22e-46fe-a392-c7f73385e867.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   2）
   <span class="lake-fontsize-12">
    客户端和服务器的某一方在交互的过程中发生异常（如程序崩溃等），该方系统将向对端发送TCP reset报文，告之对方释放相关的TCP连接，如下图所示：
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670659870716-98144738-7808-4f7b-915c-cf895fc85963.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   3）
   <span class="lake-fontsize-12">
    接收端收到TCP报文，但是发现该TCP的报文，并不在其已建立的TCP连接列表内，则其直接向对端发送reset报文，如下图所示：
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670659894950-d2cbc77f-cf68-42b2-b9ef-e308a354b4d9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   4）
   <span class="lake-fontsize-12">
    在交互的双方中的某一方长期未收到来自对方的确认报文，则其在超出一定的重传次数或时间后，会主动向对端发送reset报文释放该TCP连接，如下图所示：
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670659919800-f3d795b1-1880-4955-a2b2-5d44b257852e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   5）有些应用开发者在设计应用系统时，会利用reset报文快速释放已经完成数据交互的TCP连接，以提高业务交互的效率，如下图所示：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670659955805-be63691d-dd20-4d37-a7bd-33ffaa843617.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   服务器端的TCP如果长时间没有通讯，可以自动断开吗？
  </h3>
  <p>
   问过的一些公司：欧科云链(2022.04)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   长时间不通信，服务端会给客户端发送一个TCP Keep-Alive来查看客户端是否还存活，如果客户端没有应答，服务端超时没有收到回复就会再次重新发送。连续发送三次后，服务端都没有收到应答，服务端就会主动断开连接。
  </p>
  <h3>
   服务端主动发起关闭还是客户端主动发起关闭TCP？
  </h3>
  <p>
   问过的一些公司：转转(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   在正常情况下，服务器端和客户端都可以主动发起关闭 TCP 连接。关闭 TCP 连接通常需要进行四次握手，之后就会关闭连接。
  </p>
  <p>
   总之，在TCP中，只要一端希望关闭TCP连接，它都应该主动发起关闭。
  </p>
  <h3>
   TCP如何保证不会接受重复的报文？
  </h3>
  <p>
   问过的一些公司：字节(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    TCP 使用序列号和确认号来确保不会接收重复的报文
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   每个 TCP 报文都有一个唯一的序列号，该序列号用于表示报文中包含的数据在传输过程中的相对位置。当接收方收到一个报文时，它会检查该报文的序列号，并根据序列号的值来确定该报文是否已经接收过。如果该报文的序列号在之前已经接收过，那么接收方会拒绝该报文，从而避免了重复接收的问题。
  </p>
  <p>
   另外，TCP 还使用确认号来确保报文按顺序接收。每个报文都会带有一个确认号，用于表示接收方已经接收到的报文的序列号值。当发送方发送一个报文时，它会根据接收方返回的确认号来确定哪些报文已经被接收方接收，并根据这些信息来决定下一步的发送行为。这样可以确保报文按顺序发送和接收，从而避免了重复接收的问题。
  </p>
  <p>
   总的来说，TCP 保证不会接收重复的报文主要有两个方面：序列号和确认号。序列号用于表示报文中包含的数据在传输过程中的相对位置，接收方会根据序列号的值来确定该报文是否已经接收过。确认号则用于确保报文按顺序接收，发送方会根据接收方返回的确认号来确定哪些报文已经被接收方接收，并根据这些信息来决定下一步的发送行为。通过这些方式，TCP 可以保证不会接收重复的报文，从而保证了传输过程的可靠性。
  </p>
  <h3>
   UDP传输过程中存在的主要问题是什么？
  </h3>
  <p>
   问过的一些公司：好未来(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    丢失和乱序
   </strong>
   <span class="lake-fontsize-12">
    ：因为UDP不提供ACK、序列号等机制，所以是没有办法知道是否有报文丢失以及接收方到达等报文顺序是否和发送方发送的报文数据一样；
   </span>
  </p>
  <p>
   <strong>
    差错
   </strong>
   <span class="lake-fontsize-12">
    ：对于差错问题则是可以通过校验和等检测到，但是不提供差错纠正；
   </span>
  </p>
  <p>
   <strong>
    数据完整性
   </strong>
   <span class="lake-fontsize-12">
    ：UDP协议头部虽然有16位的校验和，但是IPv4并不强制执行，也就是说UDP无法抱枕数据的完整性。
   </span>
  </p>
  <h3>
   用TCP和用HTTP有些什么区别？
  </h3>
  <p>
   问过的一些公司：美团(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   TCP（传输控制协议）和HTTP（超文本传输协议）都是网络通信的协议。 TCP 是一种基础的网络协议，主要用于定义传输数据时的基本方式，例如如何建立连接、如何确定数据包的传输顺序、如何检测和修复数据传输中的错误等。
  </p>
  <p>
   相比之下，HTTP 是一种应用层协议，用于定义浏览器和服务器之间如何交互以传输数据。例如，HTTP 定义了浏览器如何发送请求到服务器，服务器如何返回响应，以及这两个过程中传输的数据格式。
  </p>
  <p>
   简单来说，TCP 是传输数据时的基础协议，TCP的任务是保证连接的可靠，它只管连接，它不管连接后要传什么数据。而 HTTP 是传输数据时的应用层协议，HTTP的任务是与服务器交换信息，它不管怎么连到服务器和保证数据正确的事情。在实际应用中，HTTP 通常会使用 TCP 来传输数据，因为 TCP 可以确保数据传输的可靠性。
  </p>
  <h3>
   介绍下HTTP，HTTPS
  </h3>
  <p>
   可回答：1）HTTP是啥？2）有没有了解过HTTPS？3）谈一谈HTTP，HTTPS；4）HTTP是那一层的协议；5）HTTP，HTTPS理解
  </p>
  <p>
   问过的一些公司：Zoom(2022.09)，百度(2022.08)，好未来(2022.08)，蔚来数字化业务(2022.08)，用友(2022.08)，字节(2021.12)，招银网络(2021.09)，今日头条(2021.09)，转转(2021.08)，小米(2021.08)，同盾科技(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、HTTP
   </strong>
  </p>
  <p>
   HTTP 是一种超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范（浏览器和服务器之间数据传输的规则）。HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80。
  </p>
  <p>
   HTTP 主要内容分为三部分，
   <strong>
    超文本(Hypertext)、传输(Transfer)、协议(Protocol)
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <ul list="u5aa19bdc">
   <li fid="uedcf6e79">
    <strong>
     超文本
    </strong>
    就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。
   </li>
   <li fid="uedcf6e79">
    上面这些概念可以统称为数据，
    <strong>
     传输
    </strong>
    <span class="lake-fontsize-12">
     就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为 请求方 ，把接到二进制数据包的一方称为 应答方 。
    </span>
   </li>
   <li fid="uedcf6e79">
    而
    <strong>
     协议
    </strong>
    <span class="lake-fontsize-12">
     指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议。只不过是网络协议。
    </span>
   </li>
  </ul>
  <p>
   HTTP 通信过程
  </p>
  <ol list="ue43e6f8f">
   <li fid="u3db10a63">
    服务器在 80 端口等待客户的请求。
   </li>
   <li fid="u3db10a63">
    浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
   </li>
   <li fid="u3db10a63">
    服务器接收来自浏览器的 TCP 连接。
   </li>
   <li fid="u3db10a63">
    浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
   </li>
   <li fid="u3db10a63">
    关闭 TCP 连接。
   </li>
  </ol>
  <p>
   HTTP 特点：
  </p>
  <ul list="ub7de06bf">
   <li fid="u7f51825a">
    <strong>
     支持客户-服务器模式
    </strong>
   </li>
   <li fid="u7f51825a">
    <strong>
     简单快速
    </strong>
    <span class="lake-fontsize-12">
     ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
    </span>
   </li>
   <li fid="u7f51825a">
    <strong>
     灵活
    </strong>
    <span class="lake-fontsize-12">
     ：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。
    </span>
   </li>
   <li fid="u7f51825a">
    <strong>
     无连接
    </strong>
    <span class="lake-fontsize-12">
     ：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
    </span>
   </li>
   <li fid="u7f51825a">
    <strong>
     无状态
    </strong>
    <span class="lake-fontsize-12">
     ：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
    </span>
   </li>
  </ul>
  <p>
   HTTP 优点：
  </p>
  <ul list="u55db7c84">
   <li fid="uf78bac51">
    http的灵活性高，可扩展性强。从http1.0到http1.1再到http2.x，http协议一直在进行扩展新的属性。
   </li>
   <li fid="uf78bac51">
    可靠传输。因为http协议是基于tcp协议的一种应用层协议，tcp协议就是可靠传输协议。
   </li>
   <li fid="uf78bac51">
    请求应答，有来有回。
   </li>
   <li fid="uf78bac51">
    无状态的。每一个请求都是相互独立的，默认不需要保存上下文的信息，处理速度快。
   </li>
  </ul>
  <p>
   HTTP 缺点：
  </p>
  <ul list="u9a4231b8">
   <li fid="u3cf8fc69">
    明文传输不安全
   </li>
   <li fid="u3cf8fc69">
    复用一个TCP连接，会发生对头阻塞情况。
   </li>
   <li fid="u3cf8fc69">
    无状态的，因此无法做连续多个步骤的操作。例如：加入购物出，结算，支付。每次都需要验证身份信息，但是无状态所以无法连续。解决办法就是利用会话技术(Cookie、Session)。
   </li>
  </ul>
  <p>
   <strong>
    2、HTTPS
   </strong>
  </p>
  <p>
   HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。可以理解成HTTPS = HTTP + SSL/TLS。默认端口号是 443。
  </p>
  <p>
   HTTPS 协议的主要作用：
  </p>
  <ul list="u4843eace">
   <li fid="ubef70711">
    一种是建立一个信息安全通道，来保证数据传输的安全
   </li>
   <li fid="ubef70711">
    另一种就是确认网站的真实性
   </li>
  </ul>
  <p>
   HTTPS（Hypertext Transfer Protocol Secure）就是一种对于HTTP协议的安全包装。它使用加密来保护在网络中传输的数据，并确保只有特定的客户端和服务器之间的通信才能被读取。这有助于防止数据在传输过程中被第三方窃取或篡改。
  </p>
  <p>
   客户端在使用HTTPS方式与Web服务器通信时的步骤：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670735174884-77c7fc87-85a2-40ee-bc36-52e6e9b3c7c4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ol list="u47159bef">
   <li fid="ub226e4b3">
    客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
   </li>
   <li fid="ub226e4b3">
    Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
   </li>
   <li fid="ub226e4b3">
    客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。
   </li>
   <li fid="ub226e4b3">
    客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
   </li>
   <li fid="ub226e4b3">
    Web服务器利用自己的私钥解密出会话密钥。
   </li>
   <li fid="ub226e4b3">
    Web服务器利用会话密钥加密与客户端之间的通信。
   </li>
  </ol>
  <p>
   HTTPS加密、解密、验证及数据传输过程如下（详细版本）：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670735674321-8530e9ca-95a1-4cfb-8f5a-b65e44b77745.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ol list="u6667ffaf">
   <li fid="uebcd8f92">
    客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。
   </li>
   <li fid="uebcd8f92">
    采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书（证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书 ，当然了是要钱的，安全级别越高价格越贵）。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
   </li>
   <li fid="uebcd8f92">
    服务器响应客户端请求，将证书传递给客户端。 证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。（Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。）
   </li>
   <li fid="uebcd8f92">
    客户端解析证书并对其进行验证。 如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
   </li>
   <li fid="uebcd8f92">
    如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
   </li>
   <li fid="uebcd8f92">
    客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
   </li>
   <li fid="uebcd8f92">
    服务器在收到随机码 KEY 之后会使用私钥B将其解密。 经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
   </li>
   <li fid="uebcd8f92">
    服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。
   </li>
   <li fid="uebcd8f92">
    双方使用对称加密愉快地传输所有数据。
   </li>
  </ol>
  <p>
   HTTPS 优点：
  </p>
  <ul list="u909aaa18">
   <li fid="u84debd1a">
    使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器;
   </li>
   <li fid="u84debd1a">
    HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
   </li>
   <li fid="u84debd1a">
    HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
   </li>
   <li fid="u84debd1a">
    谷歌曾在2014年8月份调整搜索引整算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。
   </li>
  </ul>
  <p>
   HTTPS 缺点：
  </p>
  <ul list="u8f99d23b">
   <li fid="u012d7048">
    HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电:
   </li>
   <li fid="u012d7048">
    HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响;
   </li>
   <li fid="u012d7048">
    SSL证书需要钱，功能越强大的证书费用越高，个人网站，小网站没有必要一般不会用。
   </li>
   <li fid="u012d7048">
    SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
   </li>
   <li fid="u012d7048">
    HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
   </li>
  </ul>
  <p>
   HTTPS 采用的是
   <strong>
    对称加密
   </strong>
   <span class="lake-fontsize-12">
    和
   </span>
   <strong>
    非对称加密
   </strong>
   <span class="lake-fontsize-12">
    结合的「混合加密」方式：
   </span>
  </p>
  <ul list="ud767ad34">
   <li fid="u587757e4">
    在通信建立前采用
    <strong>
     非对称加密
    </strong>
    <span class="lake-fontsize-12">
     的方式交换「会话秘钥」，后续就不再使用非对称加密。
    </span>
   </li>
   <li fid="u587757e4">
    在通信过程中全部使用
    <strong>
     对称加密
    </strong>
    <span class="lake-fontsize-12">
     的「会话秘钥」的方式加密明文数据。
    </span>
   </li>
  </ul>
  <h3>
   HTTP每次建立连接都要断开吗？
  </h3>
  <p>
   可回答：1）HTTP传输完一次消息还需要重写连接吗？
  </p>
  <p>
   问过的一些公司：Zoom(2022.09)，阿里菜鸟(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP是一种无状态的应用层协议，它可以使用短连接或长连接来传输数据。
  </p>
  <p>
   在HTTP/1.0中，默认使用的是短连接，也就是说，每次HTTP请求都要建立和断开TCP连接。
  </p>
  <p>
   在HTTP/1.1中，默认使用的是长连接，引入了持久连接，也称为HTTP连接重用，也就是说，TCP连接可以复用，不用每次都重新建立和断开。
  </p>
  <h3>
   HTTP和HTTPS的区别？
  </h3>
  <p>
   可回答：1）HTTP和HTTPS发送时候的区别？2）HTTPS对比HTTP
  </p>
  <p>
   问过的一些公司：海雀科技(2022.10)，奇安信(2022.09)，东软(2022.09)，最右(2022.09)，科大讯飞(2022.08)x2，阿里巴巴菜鸟(2022.08)，字节(2022.08)x2(2022.07)(2021.09)，阿里巴巴杭州淘系(2022.08)，TP-LINK成都(2022.08)，趋势科技(2022.08)，美团(2022.08)，最右提前批(2022.08)，杭州品铂(2022.08)，东方财富(2022.08)，影石(2022.08)，阿里社招(2022.05)，字节飞书(2022.04)，字节番茄小说(2022.04)，字节抖音(2022.04)(2021.08)，京东(2022.04)x2，腾讯音乐(2021.11)，兴业数金(2021.09)，农行西安软开(2021.09)，广联达(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS则是解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。
  </p>
  <p>
   HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输。
  </p>
  <p>
   HTTP的端口号是80，HTTPS的端口号是443。
  </p>
  <p>
   HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
  </p>
  <h3>
   HTTPS的请求方式与HTTP有什么不同？
  </h3>
  <p>
   问过的一些公司：广联达(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输。
  </p>
  <h3>
   HTTPS请求安全问题
  </h3>
  <p>
   问过的一些公司：字节飞书(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS是一种基于传输层安全协议（TLS/SSL）的HTTP协议，使用公钥加密和私钥解密来保护数据的安全性和完整性。相比于HTTP，HTTPS具有更高的安全性，可以有效地防止中间人攻击和数据窃取等安全问题。
  </p>
  <p>
   不过，HTTPS请求仍然存在一些安全问题，例如：
  </p>
  <ol list="u8ec40d10">
   <li fid="ue6ebe422">
    证书认证问题：HTTPS依赖于证书机构（CA）颁发的数字证书来保证通信的安全性。但是，如果证书机构不可信或证书被篡改，则可能存在安全隐患。
   </li>
   <li fid="ue6ebe422">
    中间人攻击：中间人攻击是指攻击者在客户端和服务器之间插入自己的设备或软件，以窃取敏感信息。HTTPS可以有效防止中间人攻击，但是如果攻击者拥有合法证书，也能够欺骗用户，因此证书的安全性非常重要。
   </li>
   <li fid="ue6ebe422">
    SSL Strip 攻击：SSL Strip 攻击是一种针对 HTTPS 的中间人攻击，攻击者会将 HTTPS 请求强制转换为 HTTP 请求，然后截获和篡改通信内容。
   </li>
   <li fid="ue6ebe422">
    会话劫持：会话劫持是指攻击者在用户登录时窃取用户的会话信息，并利用该信息冒充用户登录系统。HTTPS可以通过会话管理和会话加密来防止会话劫持攻击。
   </li>
  </ol>
  <h3>
   HTTPS是怎么保障安全的？
  </h3>
  <p>
   问过的一些公司：禾赛科技(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS 使用 SSL/TLS 协议用作加密和安全认证，可以理解成HTTPS = HTTP + SSL/TLS。
  </p>
  <p>
   HTTPS 采用的是
   <strong>
    对称加密
   </strong>
   <span class="lake-fontsize-12">
    和
   </span>
   <strong>
    非对称加密
   </strong>
   <span class="lake-fontsize-12">
    结合的「混合加密」方式：
   </span>
  </p>
  <ul list="ud0a9ec77">
   <li fid="u587757e4">
    在通信建立前采用
    <strong>
     非对称加密
    </strong>
    <span class="lake-fontsize-12">
     的方式交换「会话秘钥」，后续就不再使用非对称加密。
    </span>
   </li>
   <li fid="u587757e4">
    在通信过程中全部使用
    <strong>
     对称加密
    </strong>
    <span class="lake-fontsize-12">
     的「会话秘钥」的方式加密明文数据。
    </span>
   </li>
  </ul>
  <h3>
   HTTP的缓存机制
  </h3>
  <p>
   问过的一些公司：字节(2021.10)(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   当客户端向服务器发起一条请求，服务器会返回该请求的对应资源到客户端，此时客户端可以对这个信息进行处理，在本地存储一个副本，当下次在进行同一个请求的时候，就可以直接从本地的缓存中直接返回结果给客户端显示，这个过程也就是HTTP的缓存机制。
  </p>
  <p>
   HTTP缓存可以简单的划分成两种类型：强缓存（200）与协商缓存（304）
  </p>
  <p>
   <strong>
    强缓存（200）
   </strong>
   <span class="lake-fontsize-12">
    ：如果请求的资源来本地缓存中还没有过期，就直接使用本地的副本，无需请求。强缓存的过期时间由Expires和Cache-Control来控制。
   </span>
  </p>
  <p>
   <strong>
    协商缓存（304）
   </strong>
   <span class="lake-fontsize-12">
    ：请求从客户端发起，请求前先从本地缓存中取出该缓存的一个标识，然后向服务器发送验证请求，如果服务器没有更新资源，则让客户端使用本地缓存即可。否则返回新的资源。使用Last-Modified和E-tag。
   </span>
  </p>
  <p>
   <strong>
    强缓存（200）
   </strong>
  </p>
  <p>
   1）缓存命中情况
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684651086386-12184468-fe4b-4a8f-a362-1708a2a370c4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   2）缓存未命中情况
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684651130369-4dce3bd1-e87c-485d-b96e-8dc0e53e72c8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    协商缓存（304）
   </strong>
  </p>
  <p>
   1）缓存命中情况
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684651174363-c31efdec-d857-4432-99fc-c74d39e5cf34.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   这里协商缓存缓存命中情况，是和服务器协商。这里服务器通知客户端资源没有更新，也就是说可以使用之前你缓存的数据，服务器会返回状态码304，标识资源未变。
  </p>
  <p>
   2）缓存未命中情况
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684651207746-0cfac115-5174-4001-9785-d55e7724c1f0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   协商缓存未命中，标识和服务器协商失败，服务器会返回一个新的资源和对应的字符串标识。新资源有新的最后一次修改时间和服务器中的唯一标识。
  </p>
  <p>
   <strong>
    HTTP缓存机制流程
   </strong>
   <span class="lake-fontsize-12">
    ：
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684652141448-d5948584-0b1e-44f9-a8d6-35620a6f46da.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ol list="ub9150673">
   <li fid="ucbcd2aca">
    服务器收到请求时，会在200 OK中回送该资源的Last-Modified和ETag头。客户端收到信息后，判断响应报文头部的Cache-Controll是否是no-store，如果不是则支持浏览器缓存，就新建缓存。否则，禁止缓存。
   </li>
   <li fid="ucbcd2aca">
    客户端将该资源保存在cache中，并记录该资源的Last-Modified和ETag的值。
   </li>
   <li fid="ucbcd2aca">
    当客户端需要发送相同的请求时，根据Date + Cache-control来判断是否缓存过期
   </li>
   <li fid="ucbcd2aca">
    如果过期了，先判断缓存中对应的资源是否有响应头Etag，有就会在请求中携带If-None-Match；然后判断该资源的缓存中是否有Last-Modified的响应头，如果有会再请求中携带If-Modified-Since。需要注意的是，只有两个都有才会向服务器请求文件是否变动的请求，否则就直接请求资源。
   </li>
   <li fid="ucbcd2aca">
    两个头的值分别是响应中Last-Modified和ETag头的值。
   </li>
   <li fid="ucbcd2aca">
    服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。
   </li>
   <li fid="ucbcd2aca">
    否则服务器返回新的数据和缓存规则，客户端再重新存储缓存。
   </li>
  </ol>
  <p>
   注意：当指定cache-control：no-store，缓存都无效。
  </p>
  <h3>
   HTTP状态码
  </h3>
  <p>
   可回答：1）HTTP常见的状态码；2）HTTP协议的状态响应码
  </p>
  <p>
   问过的一些公司：海康威视(2022.09)，OPPO(2022.09)，百度(2022.08)，字节(2022.08)(2021.10)(2021.09)x2，美团(2022.08)x2，米哈游(2022.08)x2，快手(2022.08)，好未来(2022.08)，经纬恒润(2022.08)，蔚来(2022.07)，招银网络(2021.09)，字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670748327599-f5212566-1f9f-4a62-8593-54951eda494d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    1xx
   </strong>
   <span class="lake-fontsize-12">
    类状态码属于
   </span>
   <strong>
    提示信息
   </strong>
   <span class="lake-fontsize-12">
    ，是协议处理中的一种中间状态，实际用到的比较少。
   </span>
  </p>
  <p>
   <strong>
    2xx
   </strong>
   <span class="lake-fontsize-12">
    类状态码表示服务器
   </span>
   <strong>
    成功
   </strong>
   <span class="lake-fontsize-12">
    处理了客户端的请求，也是我们最愿意看到的状态。
   </span>
  </p>
  <ul list="ua83e44ff">
   <li fid="ub30289cd">
    「
    <strong>
     200 OK
    </strong>
    <span class="lake-fontsize-12">
     」是最常见的成功状态码，表示一切正常。如果是非
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     HEAD
    </span>
    <span class="lake-fontsize-12">
    </span>
    <span class="lake-fontsize-12">
     请求，服务器返回的响应头都会有 body 数据。
    </span>
   </li>
   <li fid="ub30289cd">
    「
    <strong>
     204 No Content
    </strong>
    <span class="lake-fontsize-12">
     」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
    </span>
   </li>
   <li fid="ub30289cd">
    「
    <strong>
     206 Partial Content
    </strong>
    <span class="lake-fontsize-12">
     」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
    </span>
   </li>
  </ul>
  <p>
   <strong>
    3xx
   </strong>
   <span class="lake-fontsize-12">
    类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是
   </span>
   <strong>
    重定向
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <ul list="ueeafcb55">
   <li fid="u065dab0e">
    「
    <strong>
     301 Moved Permanently
    </strong>
    <span class="lake-fontsize-12">
     」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
    </span>
   </li>
   <li fid="u065dab0e">
    「
    <strong>
     302 Found
    </strong>
    <span class="lake-fontsize-12">
     」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
    </span>
   </li>
  </ul>
  <p>
   301 和 302 都会在响应头里使用字段
   <span class="lake-fontsize-12">
   </span>
   <span class="lake-fontsize-12">
    Location
   </span>
   <span class="lake-fontsize-12">
    ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
   </span>
  </p>
  <ul list="u95755c29">
   <li fid="u9a1ea499">
    「
    <strong>
     304 Not Modified
    </strong>
    <span class="lake-fontsize-12">
     」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
    </span>
   </li>
  </ul>
  <p>
   <strong>
    4xx
   </strong>
   <strong>
   </strong>
   <span class="lake-fontsize-12">
    类状态码表示客户端发送的
   </span>
   <strong>
    报文有误
   </strong>
   <span class="lake-fontsize-12">
    ，服务器无法处理，也就是错误码的含义。
   </span>
  </p>
  <ul list="ub6f62e51">
   <li fid="u608e4f38">
    「
    <strong>
     400 Bad Request
    </strong>
    <span class="lake-fontsize-12">
     」表示客户端请求的报文有错误，但只是个笼统的错误。
    </span>
   </li>
   <li fid="u608e4f38">
    「
    <strong>
     403 Forbidden
    </strong>
    <span class="lake-fontsize-12">
     」表示服务器禁止访问资源，并不是客户端的请求出错。
    </span>
   </li>
   <li fid="u608e4f38">
    「
    <strong>
     404 Not Found
    </strong>
    <span class="lake-fontsize-12">
     」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
    </span>
   </li>
  </ul>
  <p>
   <strong>
    5xx
   </strong>
   <span class="lake-fontsize-12">
    类状态码表示客户端请求报文正确，但是
   </span>
   <strong>
    服务器处理时内部发生了错误
   </strong>
   <span class="lake-fontsize-12">
    ，属于服务器端的错误码。
   </span>
  </p>
  <ul list="ucd4ac04b">
   <li fid="u6243ac5a">
    「
    <strong>
     500 Internal Server Error
    </strong>
    <span class="lake-fontsize-12">
     」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
    </span>
   </li>
   <li fid="u6243ac5a">
    「
    <strong>
     501 Not Implemented
    </strong>
    <span class="lake-fontsize-12">
     」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
    </span>
   </li>
   <li fid="u6243ac5a">
    「
    <strong>
     502 Bad Gateway
    </strong>
    <span class="lake-fontsize-12">
     」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
    </span>
   </li>
   <li fid="u6243ac5a">
    「
    <strong>
     503 Service Unavailable
    </strong>
    <span class="lake-fontsize-12">
     」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。
    </span>
   </li>
  </ul>
  <h3>
   499和502出现的原因是什么？
  </h3>
  <p>
   问过的一些公司：字节(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    499
   </strong>
   <span class="lake-fontsize-12">
    响应状态码通常是由于客户端请求有误（例如参数不正确）导致服务器拒绝处理请求时返回。
   </span>
  </p>
  <p>
   <strong>
    502
   </strong>
   <span class="lake-fontsize-12">
    响应状态码通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
   </span>
  </p>
  <h3>
   301和302有什么区别？
  </h3>
  <p>
   问过的一些公司：美团(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   301响应状态码表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
  </p>
  <p>
   302响应状态码表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
  </p>
  <h3>
   HTTP持久链接？
  </h3>
  <p>
   问过的一些公司：招银网络(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP持久链接是指在通信双方建立一个持久性的链接，用于进行多个HTTP请求/响应交换。
  </p>
  <p>
   持久连接的特点是，只要任意一端没有明确提出断开链接，则保持TCP连接状态。
  </p>
  <p>
   持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外减少开销的那部分时间，使HTTP请求和相应能够更早地结束，这样Web页面的显示速度也就响应的提高了。
  </p>
  <p>
   在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化，除了服务器端，客户端也需要支持持久连接。
  </p>
  <h3>
   HTTP是哪一层的协议，其传输层协议是什么？
  </h3>
  <p>
   问过的一些公司：美团(2022.09)(2022.08)(2021.08)x2，猿辅导(2022.08)，TP-LINK成都(2022.08)，字节番茄小说(2021.10)，诺瓦星云(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP是应用层协议。它的传输层协议通常是TCP协议，但也可以使用其他协议，例如TLS。
  </p>
  <h3>
   HTTP 1.0、1.1、2区别
  </h3>
  <p>
   可回答：1）HTTP1、2、3特性？2）
   <span class="lake-fontsize-12">
    HTTP1/2/3介绍
   </span>
  </p>
  <p>
   问过的一些公司：极致游戏(2022.10)，青书(2022.10)，快手(2022.09)，字节提前批(2022.08)，字节(2022.08)(2021.09)，滴滴(2022.08)，猿辅导(2022.08)，4399(2022.08)，字节(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、HTTP 1.0
   </strong>
  </p>
  <p>
   <strong>
    HTTP 1.0 相比于HTTP 0.9，除了GET，还引入了POST和HEAD方法
   </strong>
   <span class="lake-fontsize-12">
    ，丰富了浏览器与服务器的互动手段。此时不仅可以传输文字，还能传输图像、视频、二进制文件。
   </span>
  </p>
  <p>
   HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
  </p>
  <p>
   TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。
  </p>
  <p>
   <strong>
    2、
   </strong>
   <strong>
    HTTP1.1
   </strong>
  </p>
  <p>
   <strong>
    HTTP 1.1相比于HTTP 1.0，最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用。
   </strong>
  </p>
  <p>
   客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。
  </p>
  <p>
   一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。
  </p>
  <p>
   支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
  </p>
  <p>
   HTTP 1.1 还提供了与身份认证、状态管理和 Cache 缓存等机制相关的请求头和响应头
  </p>
  <p>
   此外，还新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 。
  </p>
  <p>
   也就是说到目前为止，在HTTP中已经有了8中指令：
  </p>
  <p>
   GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
  </p>
  <ul list="ubaa64b5a">
   <li fid="ufeed829f">
    GET：从指定的资源请求数据。在发送数据时，get 方法会向 url 添加数据，只允许 ascii 码，安全性较差，数据在 url 中对所有人可见。
   </li>
   <li fid="ufeed829f">
    HEAD：类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。
   </li>
   <li fid="ufeed829f">
    POST：向指定资源提交数据进行处理请求，数据被包含在请求体中，对长度无要求。数据不会显示在 url 中，安全性高。
   </li>
   <li fid="ufeed829f">
    PUT：从客户端向服务器传送的数据取代指定的文档的内容。
   </li>
   <li fid="ufeed829f">
    DELETE ：请求服务器删除指定的页面。
   </li>
   <li fid="ufeed829f">
    OPTIONS： 允许客户端查看服务器的性能。
   </li>
   <li fid="ufeed829f">
    TRACE： 回显服务器收到的请求，主要用于测试或诊断。
   </li>
   <li fid="ufeed829f">
    CONNECT： HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
   </li>
  </ul>
  <p>
   HTTP1.1 增加 host 字段，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
  </p>
  <p>
   HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
  </p>
  <p>
   <strong>
    3、HTTP 2
   </strong>
  </p>
  <p>
   HTTP 2 协议是基于 HTTPS 的，所以 HTTP 2 的安全性也是有保障的。
  </p>
  <p>
   <strong>
    HTTP 2 引入了压缩头（Header），如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分，并提供了多路复用和服务器推送等新特性，进一步提高了性能。
   </strong>
  </p>
  <p>
   HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。
  </p>
  <p>
   HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。
  </p>
  <p>
   HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送。
  </p>
  <p>
   <strong>
    4、HTTP 3
   </strong>
  </p>
  <p>
   HTTP 3将使用QUIC协议，它是一种基于UDP的传输层协议，比传统的TCP协议更快，更稳定，并提供了一些新的特性，例如双向流、拥塞控制和加密
  </p>
  <h3>
   HTTP1.1和2.0有啥区别呢？
  </h3>
  <p>
   问过的一些公司：小米(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP 1.1 是基于请求/响应模型的，也就是说，客户端发送一个请求给服务器，服务器接收到请求后会进行处理，并返回一个响应。HTTP 2.0 则采用了更高效的多路复用技术，允许客户端和服务器在单个 TCP 连接上进行多个并行请求/响应操作，从而提高了传输效率。
  </p>
  <p>
   HTTP 1.1 采用的是文本格式的请求和响应报文，因此它比较容易被人阅读和理解。而 HTTP 2.0 则使用了二进制格式的报文，这样可以更快速地进行编解码操作，但是不利于人类阅读。
  </p>
  <p>
   HTTP 1.1 默认使用 TCP 来传输数据，并且需要为每个请求/响应操作建立一个新的 TCP 连接，这对于网络性能造成了一定的影响。而 HTTP 2.0 则使用了长连接，可以有效地减少 TCP 连接建立和维护的开销，减小对网络性能的影响。
  </p>
  <p>
   HTTP 1.1 使用的是传统的阻塞式 I/O 模型，因此在处理请求和响应时可能会存在等待的情况。而 HTTP 2.0 采用了非阻塞 I/O 模型，可以更快速地处理请求和响应。
  </p>
  <p>
   HTTP 1.1 中，客户端和服务器之间的通信是基于文本的，而且存在大量的重复数据。而 HTTP 2.0 则使用了压缩技术，减少了传输的数据量，并提高了传输效率。
  </p>
  <h3>
   HTTP1.0与HTTP2.0区别
  </h3>
  <p>
   问过的一些公司：奇安信(2022.09)，最右(2022.09)，最右提前批(2022.08)，蔚来数字化业务(2022.08)，华人运通(2022.03)，完美(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   传输格式：HTTP1.0是基于文本的协议，HTTP2.0是基于二进制的协议。二进制格式更容易解析，更高效，更紧凑，更安全。
  </p>
  <p>
   连接复用：HTTP1.0每次请求都需要建立一个TCP连接，而HTTP2.0只需要一个TCP连接就可以发送多个请求，避免了连接的开销和延迟。
  </p>
  <p>
   头部压缩：HTTP1.0的头部信息是冗余的，占用了很多带宽。HTTP2.0使用HPACK算法对头部进行压缩，减少了数据传输的大小。
  </p>
  <p>
   服务器推送：HTTP1.0只能由客户端发起请求，服务器只能被动响应。HTTP2.0允许服务器主动向客户端推送资源，提高了页面加载的速度。
  </p>
  <p>
   流控制和优先级：HTTP1.0没有对请求和响应进行优先级排序和流量控制的机制。HTTP2.0引入了流的概念，每个流都有一个唯一的标识符和优先级信息，可以根据客户端和服务器的需求动态调整数据传输的顺序和速率。
  </p>
  <h3>
   HTTP2.0相比于1.0的优化
  </h3>
  <p>
   可回答：1）HTTP2的新特性
  </p>
  <p>
   问过的一些公司：Zoom(2022.09)，猿辅导(2022.08)，字节(2022.08)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   头部压缩：HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。
  </p>
  <p>
   二进制格式：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。
  </p>
  <p>
   多路复用：HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
  </p>
  <p>
   <strong>
    面试官：
   </strong>
   <span class="lake-fontsize-12">
    其实还有一个数据流的处理，这个可以去了解一下
   </span>
  </p>
  <p>
   HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。
  </p>
  <h3>
   HTTP 2.0的优化
  </h3>
  <p>
   问过的一些公司：疯狂游戏(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP 2.0协议是基于HTTPS的，所以HTTP 2.0的安全性也是有保障的。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669998418772-400fa928-598e-49e6-964d-531defbded46.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   HTTP 2.0协议相比HTTP 1.1协议的优化如下：
  </p>
  <ul list="u87d26556">
   <li fid="u071db263">
    头部压缩
   </li>
   <li fid="u071db263">
    二进制格式
   </li>
   <li fid="u071db263">
    并发传输
   </li>
   <li fid="u071db263">
    服务器主动推送资源
   </li>
  </ul>
  <p>
   <strong>
    1、头部压缩
   </strong>
  </p>
  <p>
   <strong>
    HTTP 2.0会进行头部压缩，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
   </strong>
  </p>
  <p>
   这就是所谓的HPACK算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
  </p>
  <p>
   <strong>
    2、二进制格式
   </strong>
  </p>
  <p>
   HTTP 2.0不再像HTTP 1.1里的纯文本形式的报文，而是
   <strong>
    全面采用了二进制格式
   </strong>
   <span class="lake-fontsize-12">
    ，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧（HeadersFrame）和数据帧（DataFrame）。
   </span>
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669998618654-a0a358e4-cae1-4eca-837f-deb955907545.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这
   <strong>
    增加了数据传输的效率
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   3、并发传输
  </p>
  <p>
   HTTP 1.1的实现是基于请求-响应模型的。同一个连接中，HTTP完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了队头阻塞的问题。
  </p>
  <p>
   而HTTP 2.0在这方面进行优化，引出了Stream概念，多个Stream复用在一条TCP连接。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669998723658-74ba3e07-51ee-4230-a740-99af3706e0f0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   从上图可以看到，1个TCP连接包含多个Stream，Stream里可以包含1个或多个Message，Message对应HTTP 1.0中的请求或响应，由HTTP头部和包体构成。Message里包含一条或者多个Frame，Frame是HTTP 2.0最小单位，以二进制压缩格式存放HTTP 1.0中的内容（头部和包体）。
  </p>
  <p>
   <strong>
    针对不同的HTTP请求用独一无二的StreamID来区分，接收端可以通过StreamID有序组装成HTTP消息，不同Stream的帧是可以乱序发送的，因此可以并发不同的Stream，也就是HTTP 2.0可以并行交错地发送请求和响应。
   </strong>
  </p>
  <p>
   4、服务器主动推送资源
  </p>
  <p>
   HTTP 2.0还在一定程度上改善了
   <strong>
    传统的「请求-应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息。
   </strong>
  </p>
  <p>
   客户端和服务器双方都可以建立Stream，Stream ID也是有区别的，客户端建立的Stream必须是奇数号，而服务器建立的Stream必须是偶数号。
  </p>
  <p>
   比如下图，Stream1是客户端向服务端请求的资源，属于客户端建立的Stream，所以该Stream的ID是奇数（数字1）；Stream2和4都是服务端主动向客户端推送的资源，属于服务端建立的Stream，所以这两个Stream的ID是偶数（数字2和4）。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669998845205-bed0777b-84fb-43dd-8fc3-c0de12df92ab.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_42%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   再比如，客户端通过HTTP 1.1请求从服务器那获取到了HTML文件，而HTML可能还需要依赖CSS来渲染页面，这时客户端还要再发起获取CSS文件的请求，需要两次消息往返，如下图左边部分：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1669998863133-02a5a98f-0b47-42f3-9fd8-ebcac3cc46c8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如上图右边部分，在HTTP 2.0中，客户端在访问HTML时，服务器可以直接主动推送CSS文件，减少了消息传递的次数。
  </p>
  <h3>
   HTTP3为什么用UDP？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP/2 虽然具有多个流并发传输的能力，但是传输层是 TCP 协议，于是存在以下缺陷：
  </p>
  <ul list="u196c07af">
   <li fid="u380339fd">
    <strong>
     队头阻塞
    </strong>
    ，HTTP/2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；
   </li>
   <li fid="u380339fd">
    <strong>
     TCP 和 TLS 握手时延
    </strong>
    <span class="lake-fontsize-12">
     ，TCL 三次握手和 TLS 四次握手，共有 3-RTT 的时延；
    </span>
   </li>
   <li fid="u380339fd">
    <strong>
     连接迁移需要重新连接
    </strong>
    <span class="lake-fontsize-12">
     ，移动设备从 4G 网络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；
    </span>
   </li>
  </ul>
  <p>
   <strong>
    HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。
   </strong>
  </p>
  <p>
   QUIC 协议的特点：
  </p>
  <ul list="u8e52a5a4">
   <li fid="ua4d4884c">
    <strong>
     无队头阻塞
    </strong>
    ，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；
   </li>
   <li fid="ua4d4884c">
    <strong>
     建立连接速度快
    </strong>
    <span class="lake-fontsize-12">
     ，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。
    </span>
   </li>
   <li fid="ua4d4884c">
    <strong>
     连接迁移
    </strong>
    <span class="lake-fontsize-12">
     ，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；
    </span>
   </li>
  </ul>
  <p>
   另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。
  </p>
  <h3>
   怎么用UDP实现HTTP协议？
  </h3>
  <p>
   问过的一些公司：极致游戏(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   UDP协议是一种无连接的传输层协议，它不保证传输的可靠性，但是传输效率高。如果要用UDP实现HTTP协议，
   <span class="lake-fontsize-12">
    但是需要自己编写实现数据的分片、传输、重组和重传等机制，这会大大增加开发难度和复杂度，并且无法保证和TCP协议相同的稳定性和可靠性。
   </span>
  </p>
  <p>
   有一种协议QUIC（Quick UDP Internet Connections），它是基于UDP协议的，但是也具备了TCP协议的优点，比如连接机制、重传机制、多路复用、流量控制等。QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT5。HTTP 3.0就是基于QUIC协议的。
  </p>
  <h3>
   HTTP3的新特性
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。
   </strong>
  </p>
  <p>
   QUIC 协议的特点：
  </p>
  <ul list="u92bd0bcb">
   <li fid="u4f49e84b" style="text-align: justify">
    <strong>
     实现了类似 TCP 的流量控制、传输可靠性的功能
    </strong>
    。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
   </li>
   <li fid="u4f49e84b" style="text-align: justify">
    <strong>
     集成了 TLS 加密功能
    </strong>
    <span class="lake-fontsize-12">
     。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
    </span>
   </li>
   <li fid="u4f49e84b" style="text-align: justify">
    <strong>
     实现了 HTTP/2 中的多路复用功能
    </strong>
    <span class="lake-fontsize-12">
     。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。
    </span>
   </li>
   <li fid="u4f49e84b" style="text-align: justify">
    <strong>
     实现了快速握手功能
    </strong>
    <span class="lake-fontsize-12">
     。因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。
    </span>
   </li>
  </ul>
  <h3>
   HTTP结构
  </h3>
  <p>
   问过的一些公司：字节抖音(2021.08)x2
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP请求由
   <strong>
    请求行、请求头部、空行和请求体
   </strong>
   <span class="lake-fontsize-12">
    四个部分组成。
   </span>
  </p>
  <h3>
   HTTP报文格式
  </h3>
  <p>
   可回答：1）HTTP的请求报文和响应报文各有哪几部分组成？2）说说HTTP请求报文包含什么？3）HTTP的request、response的具体格式；4）
   <span class="lake-fontsize-12">
    HTTP请求的结构(请求行，请求头，请求体)，分别放了什么？5）
   </span>
   <span class="lake-fontsize-12">
    HTTP请求头的一些参数
   </span>
  </p>
  <p>
   问过的一些公司：睿联(2022.10)，招银科技(2022.09)，字节提前批(2022.08)，科大讯飞(2022.08)，美团(2022.08)，同盾科技(2022.08)，字节国际化电商(2022.04)，字节(2021.09)，招银网络(2022.03)，快手(2021.09)，小米(2021.08)，诺瓦星云(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP请求由
   <strong>
    请求行、请求头部、空行和请求体
   </strong>
   <span class="lake-fontsize-12">
    四个部分组成。
   </span>
  </p>
  <ul list="u6f5c4e91">
   <li fid="u7999d23e">
    <strong>
     请求行
    </strong>
    ：包括请求方法，访问的资源URL，使用的HTTP版本。
    <span class="lake-fontsize-12" style="background-color: rgb(255, 238, 232)">
     GET
    </span>
    <span class="lake-fontsize-12">
     和
    </span>
    <span class="lake-fontsize-12" style="background-color: rgb(255, 238, 232)">
     POST
    </span>
    <span class="lake-fontsize-12">
     是最常见的HTTP方法，除此以外还包括
    </span>
    <span class="lake-fontsize-12" style="background-color: rgb(255, 238, 232)">
     DELETE、HEAD、OPTIONS、PUT、TRACE
    </span>
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
   <li fid="u7999d23e">
    <strong>
     请求头
    </strong>
    <span class="lake-fontsize-12">
     ：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有
    </span>
    <span class="lake-fontsize-12" style="background-color: rgb(255, 238, 232)">
     cookie、host、connection、accept-language、accept-encoding、user-agent
    </span>
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
   <li fid="u7999d23e">
    <strong>
     请求体
    </strong>
    <span class="lake-fontsize-12">
     ：用户的请求数据如用户名，密码等。
    </span>
   </li>
  </ul>
  <p>
   请求报文示例：
  </p>
  <pre><code class="language-java" lang="java">POST /xxx HTTP/1.1 请求行 
Accept:image/gif.image/jpeg, 请求头部 
Accept-Language:zh-cn 
Connection:Keep-Alive 
Host:localhost 
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) 
Accept-Encoding:gzip,deflate 

username=dabin 请求体</code></pre>
  <p>
   HTTP响应也由四个部分组成，分别是：
   <strong>
    状态行、响应头、空行和响应体
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <ul list="u5886b891">
   <li fid="u27610733">
    <strong>
     状态行
    </strong>
    ：协议版本，状态码及状态描述。
   </li>
   <li fid="u27610733">
    <strong>
     响应头
    </strong>
    <span class="lake-fontsize-12">
     ：响应头字段主要有
    </span>
    <span class="lake-fontsize-12" style="background-color: rgb(255, 238, 232)">
     connection、content-type、content-encoding、content-length、set-cookie、Last-Modified、Cache-Control、Expires
    </span>
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
   <li fid="u27610733">
    <strong>
     响应体
    </strong>
    <span class="lake-fontsize-12">
     ：服务器返回给客户端的内容。
    </span>
   </li>
  </ul>
  <p>
   响应报文示例：
  </p>
  <pre><code class="language-java" lang="java">HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;
    &lt;body&gt;响应体&lt;/body&gt;
&lt;/html&gt;</code></pre>
  <h3>
   HTTP的头部包含哪些？
  </h3>
  <p>
   可回答：1）
   <span class="lake-fontsize-12">
    用过哪些请求头，知道哪些请求头？2）
   </span>
   <span class="lake-fontsize-12">
    讲一下你知道的请求头
   </span>
  </p>
  <p>
   问过的一些公司：科大讯飞(2022.08)，蔚来数字化业务(2022.08)，趋势科技(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    HTTP请求头：
   </strong>
  </p>
  <ul list="u0f792e7d">
   <li fid="u5b84df03">
    Accept：指定客户端能够接收的内容类型。
   </li>
   <li fid="u5b84df03">
    Accept-Charset：浏览器可以接受的字符编码集。
   </li>
   <li fid="u5b84df03">
    Accept-Encoding：指定浏览器可以支持的web服务器返回内容压缩编码类型。
   </li>
   <li fid="u5b84df03">
    Accept-Language：浏览器可接受的语言。
   </li>
   <li fid="u5b84df03">
    Accept-Ranges：可以请求网页实体的一个或者多个子范围字段。
   </li>
   <li fid="u5b84df03">
    AuthorizationHTTP：授权的授权证书。
   </li>
   <li fid="u5b84df03">
    Cache-Control：指定请求和响应遵循的缓存机制。
   </li>
   <li fid="u5b84df03">
    Connection：表示是否需要持久连接。（HTTP 1.1默认进行持久连接）
   </li>
   <li fid="u5b84df03">
    CookieHTTP：请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。
   </li>
   <li fid="u5b84df03">
    Content-Length：请求的内容长度。
   </li>
   <li fid="u5b84df03">
    Content-Type：请求的与实体对应的MIME信息。
   </li>
   <li fid="u5b84df03">
    Date：请求发送的日期和时间。
   </li>
   <li fid="u5b84df03">
    Expect：请求的特定的服务器行为。
   </li>
   <li fid="u5b84df03">
    From：发出请求的用户的Email。
   </li>
   <li fid="u5b84df03">
    Host：指定请求的服务器的域名和端口号。
   </li>
   <li fid="u5b84df03">
    If-Match：只有请求内容与实体相匹配才有效。
   </li>
   <li fid="u5b84df03">
    If-Modified-Since：如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码。
   </li>
   <li fid="u5b84df03">
    If-None-Match：如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变。 If-Range：如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。
   </li>
   <li fid="u5b84df03">
    If-Unmodified-Since：只在实体在指定时间之后未被修改才请求成功。
   </li>
   <li fid="u5b84df03">
    Max-Forwards：限制信息通过代理和网关传送的时间。
   </li>
   <li fid="u5b84df03">
    Pragma：用来包含实现特定的指令。
   </li>
   <li fid="u5b84df03">
    Proxy-Authorization：连接到代理的授权证书。
   </li>
   <li fid="u5b84df03">
    Range：只请求实体的一部分，指定范围。
   </li>
   <li fid="u5b84df03">
    Referer：先前网页的地址，当前请求网页紧随其后，即来路。
   </li>
   <li fid="u5b84df03">
    TE：客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息。
   </li>
   <li fid="u5b84df03">
    Upgrade：向服务器指定某种传输协议以便服务器进行转换（如果支持）。
   </li>
   <li fid="u5b84df03">
    User-AgentUser-Agent：的内容包含发出请求的用户信息。
   </li>
   <li fid="u5b84df03">
    Via：通知中间网关或代理服务器地址，通信协议。
   </li>
   <li fid="u5b84df03">
    Warning：关于消息实体的警告信息。
   </li>
  </ul>
  <p>
   <strong>
    HTTP相应头：
   </strong>
  </p>
  <ul list="u169cfd76">
   <li fid="ucf2de5ed">
    Accept-Ranges：表明服务器是否支持指定范围请求及哪种类型的分段请求。
   </li>
   <li fid="ucf2de5ed">
    Age：从原始服务器到代理缓存形成的估算时间（以秒计，非负）。
   </li>
   <li fid="ucf2de5ed">
    Allow：对某网络资源的有效的请求行为，不允许则返回405。
   </li>
   <li fid="ucf2de5ed">
    Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型。
   </li>
   <li fid="ucf2de5ed">
    Content-Encodingweb：服务器支持的返回内容压缩编码类型。。
   </li>
   <li fid="ucf2de5ed">
    Content-Language：响应体的语言。
   </li>
   <li fid="ucf2de5ed">
    Content-Length：响应体的长度。
   </li>
   <li fid="ucf2de5ed">
    Content-Location：请求资源可替代的备用的另一地址。
   </li>
   <li fid="ucf2de5ed">
    Content-MD5：返回资源的MD5校验值。
   </li>
   <li fid="ucf2de5ed">
    Content-Range：在整个返回体中本部分的字节位置。
   </li>
   <li fid="ucf2de5ed">
    Content-Type：返回内容的MIME类型。
   </li>
   <li fid="ucf2de5ed">
    Date：原始服务器消息发出的时间。
   </li>
   <li fid="ucf2de5ed">
    ETag：请求变量的实体标签的当前值。
   </li>
   <li fid="ucf2de5ed">
    Expires：响应过期的日期和时间。
   </li>
   <li fid="ucf2de5ed">
    Last-Modified：请求资源的最后修改时间。
   </li>
   <li fid="ucf2de5ed">
    Location：用来重定向接收方到非请求URL的位置来完成请求或标识新的资源。
   </li>
   <li fid="ucf2de5ed">
    Pragma：包括实现特定的指令，它可应用到响应链上的任何接收方。
   </li>
   <li fid="ucf2de5ed">
    Proxy-Authenticate：它指出认证方案和可应用到代理的该URL上的参数。
   </li>
   <li fid="ucf2de5ed">
    refresh：应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）
   </li>
   <li fid="ucf2de5ed">
    Retry-After：如果实体暂时不可取，通知客户端在指定时间之后再次尝试。
   </li>
   <li fid="ucf2de5ed">
    Serverweb：服务器软件名称。
   </li>
   <li fid="ucf2de5ed">
    Set-Cookie：设置Http Cookie。
   </li>
   <li fid="ucf2de5ed">
    Trailer：指出头域在分块传输编码的尾部存在。
   </li>
   <li fid="ucf2de5ed">
    Transfer-Encoding：文件传输编码。
   </li>
   <li fid="ucf2de5ed">
    Vary：告诉下游代理是使用缓存响应还是从原始服务器请求。
   </li>
   <li fid="ucf2de5ed">
    Via：告知代理客户端响应是通过哪里发送的。
   </li>
   <li fid="ucf2de5ed">
    Warning：警告实体可能存在的问题。
   </li>
   <li fid="ucf2de5ed">
    WWW-Authenticate：表明客户端请求实体应该使用的授权方案。
   </li>
  </ul>
  <h3>
   请求头和请求体怎么区分的?
  </h3>
  <p>
   问过的一些公司：小米(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    请求头、请求体
   </strong>
   <span class="lake-fontsize-12">
    ​
   </span>
  </p>
  <ul list="u43311396">
   <li fid="u7999d23e">
    <strong>
     请求头
    </strong>
    ：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有
    <span class="lake-fontsize-12" style="background-color: rgb(255, 238, 232)">
     cookie、host、connection、accept-language、accept-encoding、user-agent
    </span>
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
   <li fid="u7999d23e">
    <strong>
     请求体
    </strong>
    <span class="lake-fontsize-12">
     ：用户的请求数据如用户名，密码等。
    </span>
   </li>
  </ul>
  <p>
   请求报文示例：
  </p>
  <pre><code class="language-java" lang="java">POST /xxx HTTP/1.1 请求行 
Accept:image/gif.image/jpeg, 请求头部 
Accept-Language:zh-cn 
Connection:Keep-Alive 
Host:localhost 
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) 
Accept-Encoding:gzip,deflate 

username=dabin 请求体</code></pre>
  <h3>
   HTTP请求的过程
  </h3>
  <p>
   可回答：1）HTTP请求是怎么解析的？
  </p>
  <p>
   问过的一些公司：阿里菜鸟(2022.09)，字节(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、浏览器根据域名解析IP地址
   </strong>
  </p>
  <p>
   浏览器根据访问的域名找到其IP地址，DNS查找过程如下：
  </p>
  <ol list="u8e5b2e19">
   <li fid="u6ec583ab">
    浏览器缓存：首先搜索浏览器自身的DNS缓存（缓存的时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否是有域名对应的条目，而且没有过期，如果有且没有过期则解析到此结束。
   </li>
   <li fid="u6ec583ab">
    系统缓存：如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。
   </li>
   <li fid="u6ec583ab">
    路由器缓存：如果系统缓存也没有找到，则会向路由器发送查询请求。
   </li>
   <li fid="u6ec583ab">
    ISP（互联网服务提供商） DNS缓存：如果在路由缓存也没找到，最后要查的就是ISP缓存DNS的服务器。
   </li>
  </ol>
  <p>
   <strong>
    2、浏览器与WEB服务器建立一个TCP连接
   </strong>
  </p>
  <p>
   发起TCP的3次握手
  </p>
  <p>
   <strong>
    3、浏览器给WEB服务器发送一个HTTP请求
   </strong>
  </p>
  <p>
   建立TCP连接后发起http请求
  </p>
  <p>
   一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671031896264-c37d0da1-5d6d-4f5b-890d-a046544b6780.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    4、服务器响应http请求，浏览器得到返回response
   </strong>
  </p>
  <p>
   服务器端响应HTTP请求，浏览器得到HTML代码
  </p>
  <p>
   HTTP响应报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684653255904-28536dc9-2f9d-44a7-9b07-15cc1af2891c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    5、浏览器解析response，并请求其它的资源（如js、css、图片等）
   </strong>
  </p>
  <p>
   浏览器拿到HTML文件后，开始解析HTML代码，遇到静态资源时，就向服务器端去请求下载。
  </p>
  <p>
   <strong>
    6、关闭TCP连接，浏览器对页面进行渲染
   </strong>
  </p>
  <p>
   浏览器利用自己内部的工作机制，把请求到的静态资源和HTML代码进行渲染，呈现给用户。
  </p>
  <h3>
   TCP和HTTP的KeepAlive的区别
  </h3>
  <p>
   问过的一些公司：快手(2022.08)，招银网络(2022.03)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、什么是KeepAlive
   </strong>
  </p>
  <p>
   TCP的KeepAlive和HTTP的Keep-Alive是完全不同的概念，不能混为一谈。实际上HTTP的KeepAlive写法是Keep-Alive，跟TCP的KeepAlive写法上也有不同。
  </p>
  <p>
   TCP的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方端掉的时候，没有断掉的定时发送几次心跳包，如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。那么这对服务器资源的影响是很大的。
  </p>
  <p>
   HTTP的keep-alive一般我们都会带上中间的横杠，普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。
  </p>
  <p>
   <strong>
    2、
   </strong>
   <strong>
    TCP和HTTP的KeepAlive的作用（区别）
   </strong>
  </p>
  <p>
   <strong>
    HTTP协议的Keep-Alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求/响应。
   </strong>
  </p>
  <p>
   <strong>
    TCP的KeepAlive机制意图在于保活、心跳，检测连接错误。
   </strong>
   <span class="lake-fontsize-12">
    当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。
   </span>
  </p>
  <p>
   记住HTTP的Keep-Alive和TCP的KeepAlive不是一回事。
  </p>
  <p>
   tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。而http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。
  </p>
  <p>
   <strong>
    3、TCP的
   </strong>
   <strong>
    KeepAlive
   </strong>
  </p>
  <p>
   1）为什么要有
   <span class="lake-fontsize-12">
    KeepAlive
   </span>
  </p>
  <p>
   链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。
  </p>
  <p>
   TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。
  </p>
  <p>
   2）
   <span class="lake-fontsize-12">
    怎么开启KeepAlive？
   </span>
  </p>
  <p>
   KeepAlive并不是默认开启的，在Linux系统上没有一个全局的选项去开启TCP的KeepAlive。需要开启KeepAlive的应用必须在TCP的socket中单独开启。Linux Kernel有三个选项影响到KeepAlive的行为：
  </p>
  <ul list="u13ce6dab">
   <li fid="u5cadd416">
    tcp_keepalive_time 7200// 距离上次传送数据多少时间未收到新报文判断为开始检测，单位秒，默认7200s
   </li>
   <li fid="u5cadd416">
    tcp_keepalive_intvl 75// 检测开始每多少时间发送心跳包，单位秒，默认75s
   </li>
   <li fid="u5cadd416">
    tcp_keepalive_probes 9// 发送几次心跳包对方未响应则close连接，默认9次
   </li>
  </ul>
  <p>
   TCP socket也有三个选项和内核对应，通过setsockopt系统调用针对单独的socket进行设置：
  </p>
  <ul list="u5647c3e2">
   <li fid="u2538223c">
    TCPKEEPCNT: 覆盖 tcpkeepaliveprobes
   </li>
   <li fid="u2538223c">
    TCPKEEPIDLE: 覆盖 tcpkeepalivetime
   </li>
   <li fid="u2538223c">
    TCPKEEPINTVL: 覆盖 tcpkeepalive_intvl
   </li>
  </ul>
  <p>
   3）
   <span class="lake-fontsize-12">
    KeepAlive的不足和局限性
   </span>
  </p>
  <p>
   其实，tcp自带的keepalive还是有些不足之处的。
  </p>
  <p>
   <strong>
    keepalive只能检测连接是否存活，不能检测连接是否可用。
   </strong>
   <span class="lake-fontsize-12">
    例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层keepalive包。
   </span>
  </p>
  <p>
   TCP keepalive 机制依赖于操作系统的实现,灵活性不够，默认关闭，且默认的 keepalive 心跳时间是 两个小时, 时间较长。
  </p>
  <p>
   代理(如socks proxy)、或者负载均衡器，会让tcp keep-alive失效
  </p>
  <p>
   <strong>
    4、
   </strong>
   <strong>
    HTTP的Keep-Alive
   </strong>
  </p>
  <p>
   1）HTTP为什么需要Keep-Alive？
  </p>
  <p>
   通常一个网页可能会有很多组成部分，除了文本内容，还会有诸如：js、css、图片等静态资源，有时还会异步发起AJAX请求。只有所有的资源都加载完毕后，我们看到网页完整的内容。然而，一个网页中，可能引入了几十个js、css文件，上百张图片，如果每请求一个资源，就创建一个连接，然后关闭，代价实在太大了。
  </p>
  <p>
   基于此背景，我们希望连接能够在
   <strong>
    短时间内
   </strong>
   <span class="lake-fontsize-12">
    得到复用，在加载同一个网页中的内容时，尽量的复用连接，这就是HTTP协议中keep-alive属性的作用。
   </span>
  </p>
  <ul list="ueb2798be">
   <li fid="u69a07070">
    HTTP的Keep-Alive是
    <strong>
     HTTP1.1
    </strong>
    <span class="lake-fontsize-12">
     中
    </span>
    <strong>
     默认开启
    </strong>
    <span class="lake-fontsize-12">
     的功能。通过headers设置"Connection: close "关闭
    </span>
   </li>
   <li fid="u69a07070">
    在HTTP1.0中是
    <strong>
     默认关闭
    </strong>
    <span class="lake-fontsize-12">
     的。通过headers设置"Connection: Keep-Alive"开启。
    </span>
   </li>
  </ul>
  <p>
   对于客户端来说，不论是浏览器，还是手机App，或者我们直接在Java代码中使用HttpUrlConnection，只是负责在请求头中设置Keep-Alive。Keep-Alive属性保持连接的
   <strong>
    时间长短是由服务端决定的
   </strong>
   <span class="lake-fontsize-12">
    ，通常配置都是在
   </span>
   <strong>
    几十秒左右。
   </strong>
  </p>
  <p>
   TCP连接建立之后，HTTP协议使用TCP传输HTTP协议的请求(Request)和响应(Response)数据，一次完整的HTTP事务如下图：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671032763058-bb8f8b9d-57de-435f-a802-081664be8734.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   从图中可以发现一个完整的HTTP事务，有链接的建立，请求的发送，响应接收，断开链接这四个过程，早期通过HTTP协议传输的数据以文本为主，一个请求可能就把所有要返回的数据取到，但是，现在要展现一张完整的页面需要很多个请求才能完成，如图片.JS.CSS等，如果每一个HTTP请求都需要新建并断开一个TCP，这个开销是完全没有必要的。
  </p>
  <p>
   开启HTTP Keep-Alive之后，能复用已有的TCP链接，当前一个请求已经响应完毕，服务器端没有立即关闭TCP链接，而是等待一段时间接收浏览器端可能发送过来的第二个请求，通常浏览器在第一个请求返回之后会立即发送第二个请求，如果某一时刻只能有一个链接，同一个TCP链接处理的请求越多，开启KeepAlive能节省的TCP建立和关闭的消耗就越多。
  </p>
  <p>
   当然通常会启用多个链接去从服务器器上请求资源，但是开启了Keep-Alive之后，仍然能加快资源的加载速度。HTTP/1.1之后默认开启Keep-Alive, 在HTTP的头域中增加Connection选项。当设置为Connection:keep-alive表示开启，设置为Connection:close表示关闭。
  </p>
  <p>
   2）什么是
   <span class="lake-fontsize-12">
    Keep-Alive模式
   </span>
  </p>
  <p>
   HTTP协议采用请求-应答模式，有普通的非KeepAlive模式，也有KeepAlive模式。
  </p>
  <p>
   非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。
  </p>
  <p>
   3）如何启用或者关闭Keep-Alive模式？
  </p>
  <p>
   <strong>
    浏览器发起建议，服务器视情况统一。
   </strong>
  </p>
  <p>
   （1）http 1.0中默认是关闭的，如果客户端浏览器支持Keep-Alive，那么就在HTTP请求头中添加一个字段
   <strong>
    Connection: Keep-Alive
   </strong>
   <span class="lake-fontsize-12">
    ，当服务器收到附带有Connection: Keep-Alive的请求时，它也会在响应头中添加一个同样的字段来使用Keep-Alive。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过Keep-Alive规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。
   </span>
  </p>
  <p>
   也有可能是Keep-Alive
  </p>
  <pre><code class="language-java" lang="java">Keep-Alive: timeout=5, max=100
timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接</code></pre>
  <p>
   （2）http 1.1中默认启用Keep-Alive， 默认情况下所在HTTP1.1中所有连接都被保持，除非在请求头或响应头中指明要关闭：Connection: Close ，这也就是为什么Connection: Keep-Alive字段再没有意义的原因。另外，还添加了一个新的字段Keep-Alive:，因为这个字段并没有详细描述用来做什么，可忽略它
  </p>
  <p>
   目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。
  </p>
  <p>
   4）
   <span class="lake-fontsize-12">
    启用Keep-Alive的优点
   </span>
  </p>
  <p>
   从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是RFC 2616 上的总结：
  </p>
  <ol list="ua197b62e">
   <li fid="u775996b9">
    TCP连接更少，这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。
   </li>
   <li fid="u775996b9">
    网络拥塞也减少了，拿到响应的延时也减少了
   </li>
   <li fid="u775996b9">
    错误处理更优雅：不会粗暴地直接关闭连接，而是report，retry
   </li>
  </ol>
  <p>
   5）
   <span class="lake-fontsize-12">
    Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？
   </span>
  </p>
  <p>
   对于非持续连接，浏览器可以通过连接是否关闭来界定请求或响应实体的边界；而对于持续连接，这种方法显然不奏效。有时，尽管我已经发送完所有数据，但浏览器并不知道这一点，它无法得知这个打开的连接上是否还会有新数据进来，只能傻傻地等了。
  </p>
  <h3>
   HTTPS握手过程
  </h3>
  <p>
   问过的一些公司：东方财富(2022.08)，经纬恒润(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
  </p>
  <p>
   具体流程请看下图。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671166228595-76d024fd-4115-4ab9-9696-5f1535aa4e72.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    1、客户端发起HTTPS请求
   </strong>
  </p>
  <p style="text-align: left">
   这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。
  </p>
  <p>
   <strong>
    2、服务端的配置
   </strong>
  </p>
  <p style="text-align: left">
   采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
  </p>
  <p>
   <strong>
    3、传送证书
   </strong>
  </p>
  <p style="text-align: left">
   这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
  </p>
  <p>
   <strong>
    4、客户端解析证书
   </strong>
  </p>
  <p style="text-align: left">
   这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
  </p>
  <p>
   <strong>
    5、传送加密信息
   </strong>
  </p>
  <p style="text-align: left">
   这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
  </p>
  <p>
   <strong>
    6、服务段解密信息
   </strong>
  </p>
  <p style="text-align: left">
   服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
  </p>
  <p>
   <strong>
    7、传输加密后的信息
   </strong>
  </p>
  <p style="text-align: left">
   这部分信息是服务段用私钥加密后的信息，可以在客户端被还原
  </p>
  <p>
   <strong>
    8、客户端解密信息
   </strong>
  </p>
  <p style="text-align: left">
   客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。
  </p>
  <h3>
   HTTP三次握手
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   参考TCP三次握手过程即可
  </p>
  <h3>
   HTTP请求方式
  </h3>
  <p>
   可回答：1）HTTP请求类型有哪些？2）HTTP的请求方式有哪些？
  </p>
  <p>
   问过的一些公司：青书(2022.10)，苏小妍(2022.09)，汉得信息(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP请求类型有九种，分别是：
  </p>
  <p>
   1. GET：请求指定的页面信息，并返回实体主体。
  </p>
  <p>
   2. HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
  </p>
  <p>
   3. POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。
  </p>
  <p>
   4. PUT：从客户端向服务器传送的数据取代指定的文档的内容。
  </p>
  <p>
   5. DELETE：请求服务器删除指定的页面。
  </p>
  <p>
   6. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
  </p>
  <p>
   7. OPTIONS：允许客户端查看服务器的性能。
  </p>
  <p>
   8. TRACE：回显服务器收到的请求，主要用于测试或诊断。
  </p>
  <p>
   9. PATCH：请求局部更新某个资源，比如修改一个文件的一部分内容。
  </p>
  <h3>
   HTTP有哪些方法？
  </h3>
  <p>
   问过的一些公司：大连东软(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   1、GET：用于获取指定的资源
  </p>
  <p>
   2、POST：用于向服务器发送数据，以便进行处理
  </p>
  <p>
   3、PUT：用于向服务器上传文件
  </p>
  <p>
   4、DELETE：用于删除指定的资源
  </p>
  <p>
   5、HEAD：用于获取指定资源的元数据
  </p>
  <p>
   6、OPTIONS：用于获取服务器支持的HTTP请求方法
  </p>
  <p>
   7、TRACE：用于跟踪服务器处理请求的过程
  </p>
  <p>
   8、CONNECT：用于建立隧道，以便进行SSL加密传输
  </p>
  <h3>
   HTTPS会话秘钥
  </h3>
  <p>
   问过的一些公司：东方财富(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS使用了非对称加密和对称加密两种加密方式：
  </p>
  <ul list="u894ccc48">
   <li fid="u9c509d79">
    非对称加密：在 HTTPS 握手阶段，客户端会向服务器发送一个用于密钥交换的公钥，服务器使用该公钥将随机生成的会话密钥进行加密，传回给客户端。这个公钥是基于服务器的数字证书生成的，客户端可以使用相应的私钥进行解密。因此，HTTPS的握手阶段使用了非对称加密。
   </li>
   <li fid="u9c509d79">
    对称加密：HTTPS握手完成后，客户端和服务器会根据协商好的会话密钥进行对称加密通信。这个会话密钥只有客户端和服务器知道，其他人无法得知。因此，HTTPS的通信阶段使用了对称加密。
   </li>
  </ul>
  <p>
   HTTPS的通信过程中，使用对称加密加密数据可以保证数据的机密性和完整性，而使用非对称加密交换对称加密密钥可以保证传输过程中密钥的安全性。
  </p>
  <h3>
   HTTPS连接流程
  </h3>
  <p>
   可回答：1）一次HTTPS具体流程？2）HTTPS协议链接建立流程是什么？3）
   <span class="lake-fontsize-12">
    HTTPS的通信过程？4）发送HTTPS请求之后的全套流程
   </span>
  </p>
  <p>
   问过的一些公司：百度(2022.08)(2021.08)，TP-LINK成都(2022.08)，字节(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   客户端在使用HTTPS方式与Web服务器通信时的步骤：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670735174884-77c7fc87-85a2-40ee-bc36-52e6e9b3c7c4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ol list="u30913307">
   <li fid="ub226e4b3">
    客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
   </li>
   <li fid="ub226e4b3">
    Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
   </li>
   <li fid="ub226e4b3">
    客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。
   </li>
   <li fid="ub226e4b3">
    客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
   </li>
   <li fid="ub226e4b3">
    Web服务器利用自己的私钥解密出会话密钥。
   </li>
   <li fid="ub226e4b3">
    Web服务器利用会话密钥加密与客户端之间的通信。
   </li>
  </ol>
  <p>
   HTTPS加密、解密、验证及数据传输过程如下（详细版本）：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1670735674321-8530e9ca-95a1-4cfb-8f5a-b65e44b77745.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ol list="u7a867a8a">
   <li fid="uebcd8f92">
    客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。
   </li>
   <li fid="uebcd8f92">
    采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书（证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书 ，当然了是要钱的，安全级别越高价格越贵）。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
   </li>
   <li fid="uebcd8f92">
    服务器响应客户端请求，将证书传递给客户端。 证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。（Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。）
   </li>
   <li fid="uebcd8f92">
    客户端解析证书并对其进行验证。 如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
   </li>
   <li fid="uebcd8f92">
    如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
   </li>
   <li fid="uebcd8f92">
    客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
   </li>
   <li fid="uebcd8f92">
    服务器在收到随机码 KEY 之后会使用私钥B将其解密。 经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
   </li>
   <li fid="uebcd8f92">
    服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。
   </li>
   <li fid="uebcd8f92">
    双方使用对称加密愉快地传输所有数据。
   </li>
  </ol>
  <h3>
   HTTP过程
  </h3>
  <p>
   可回答：1）HTTP一次完整的请求
  </p>
  <p>
   问过的一些公司：海雀科技(2022.10)，大连东软(2022.10)，招银科技(2022.09)，TP-LINK成都(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP通信过程：
  </p>
  <ol list="u2a52a96b">
   <li fid="u3db10a63">
    服务器在 80 端口等待客户的请求。
   </li>
   <li fid="u3db10a63">
    浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
   </li>
   <li fid="u3db10a63">
    服务器接收来自浏览器的 TCP 连接。
   </li>
   <li fid="u3db10a63">
    浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
   </li>
   <li fid="u3db10a63">
    关闭 TCP 连接。
   </li>
  </ol>
  <h3>
   HTTPS的证书是怎么认证的？
  </h3>
  <p>
   问过的一些公司：好未来(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   我们先来看看数字证书是什么，一个数字证书通常包含了：
  </p>
  <ul list="u05d22269">
   <li fid="u226f7790">
    公钥；
   </li>
   <li fid="u226f7790">
    持有者信息；
   </li>
   <li fid="u226f7790">
    证书认证机构（CA）的信息；
   </li>
   <li fid="u226f7790">
    CA 对这份文件的数字签名及使用的算法；
   </li>
   <li fid="u226f7790">
    证书有效期；
   </li>
   <li fid="u226f7790">
    还有一些其他额外信息；
   </li>
  </ul>
  <p>
   数字证书的作用：用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。
  </p>
  <p>
   我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？
  </p>
  <p>
   为了让服务端的公钥被大家信任，服务端的证书都是由 CA （
   <em>
    Certificate Authority
   </em>
   <span class="lake-fontsize-12">
    ，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。
   </span>
  </p>
  <p>
   之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。
  </p>
  <p>
   <strong>
    数字证书签发和验证流程
   </strong>
  </p>
  <p>
   如下图图所示，为数字证书签发和验证流程：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671265131153-ed0848f9-e91d-4586-86b2-93d266d1fe95.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_38%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    CA 签发证书的过程
   </strong>
   <span class="lake-fontsize-12">
    ，如上图左边部分：
   </span>
  </p>
  <ul list="ua811c3ea">
   <li fid="u9434117c">
    首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
   </li>
   <li fid="u9434117c">
    然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
   </li>
   <li fid="u9434117c">
    最后将 Certificate Signature 添加在文件证书上，形成数字证书；
   </li>
  </ul>
  <p>
   <strong>
    客户端校验服务端的数字证书的过程
   </strong>
   <span class="lake-fontsize-12">
    ，如上图右边部分：
   </span>
  </p>
  <ul list="u640228a9">
   <li fid="uafe16dd7">
    首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
   </li>
   <li fid="uafe16dd7">
    通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
   </li>
   <li fid="uafe16dd7">
    最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。
   </li>
  </ul>
  <h3>
   HTTPS如何保证数据完整性？
  </h3>
  <p>
   问过的一些公司：最右(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS通过SSL/TLS协议来保证数据的完整性，SSL/TLS协议在传输数据时会使用加密算法，并使用数字签名来验证数据的完整性。加密算法可以保证数据在传输过程中不被篡改，而数字签名则可以确保数据的完整性。
  </p>
  <h3>
   HTTPS如何保证安全的？
  </h3>
  <p>
   问过的一些公司：百度(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP是明文传输，在传输过程中，信息都是可见的，存在一定的风险性。
  </p>
  <p>
   HTTP安全上存在以下三个风险：
  </p>
  <ul list="u2039d2e2">
   <li fid="u35ef42b1">
    窃听风险，
    第三方劫持请求后可以获取通信内容。对于一些敏感数据，这是不被允许的
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
   <li fid="u35ef42b1">
    篡改风险，
    <span class="lake-fontsize-12">
     第三方劫持请求后可以篡改通信内容。例如银行系统中，张三本来要给李四转账，第三方劫持请求后篡改了请求数据，将收款方改为自己，导致用户资金流失。
    </span>
   </li>
   <li fid="u35ef42b1">
    冒充风险，
    <span class="lake-fontsize-12">
     第三方可以冒充客户端发送数据。由于是明文传输，没有「加签/验签」操作，服务端无法保证请求来源的合法性。
    </span>
   </li>
  </ul>
  <p>
   HTTPS 在 HTTP 与 TCP 层之间加入了 SSL（（Secure Sockets Layer）译为「安全套接字协议」）/TLS （（Transport Layer Security）译为「传输层安全性协议」）协议，来解决上述的风险，保证安全。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671262841334-9601e161-52d6-4bc6-87a2-27efbb5d3108.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   SSL/TLS协议处于「传输层」和「应用层」之间，主要作用是对网络连接进行加解密。
  </p>
  <p>
   SSL/TLS协议的解决方式如下：
  </p>
  <p>
   <strong>
    1、防窃听风险：加密
   </strong>
  </p>
  <p>
   HTTPS使用安全的加密算法，比如AES，RSA，SHA等，来加密传输的数据，从而保证数据的安全性。一般对称加密算法（比如AES、SM4）是用来加密数据，非对称加密算法（比如RSA、SM2）用来加密对称算法的秘钥，杂凑算法（比如SHA、SM3）用来验证。
  </p>
  <blockquote>
   <p>
    <strong>
     其实加密算法很好理解，特别是现在国密算法发展也很好，后续考虑出一期专门讲国密算法的文章。
    </strong>
   </p>
  </blockquote>
  <p>
   <strong>
    2、防篡改风险：加签
   </strong>
  </p>
  <p>
   这部分可以使用RSA或SM2算法来完成，主要是起一个签名验签的作用，确保数据没有被篡改。
  </p>
  <p>
   <strong>
    3、防冒充风险：证书
   </strong>
  </p>
  <p>
   一个数字证书通常包含了：
  </p>
  <ul list="uf8b5b222">
   <li fid="u6ab917f8">
    公钥；
   </li>
   <li fid="u6ab917f8">
    持有者信息；
   </li>
   <li fid="u6ab917f8">
    证书认证机构（CA）的信息；
   </li>
   <li fid="u6ab917f8">
    CA 对这份文件的数字签名及使用的算法；
   </li>
   <li fid="u6ab917f8">
    证书有效期；
   </li>
   <li fid="u6ab917f8">
    还有一些其他额外信息。
   </li>
  </ul>
  <p>
   当服务端要把公钥发送给客户端时，不是直接发送公钥，而是先把公钥发送给CA，CA根据公钥生成一份「证书」给到服务端，服务端将证书给客户端。客户端拿到证书后去CA验证证书的合法性，确保证书是服务端下发的。
  </p>
  <p>
   CA就类似于「公证处」，也是一台服务器，它自己本身也有一套密钥对。它的工作就是根据服务端的公钥生成证书，然后帮助客户端来验证证书的合法性。
  </p>
  <p>
   证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。
  </p>
  <h3>
   为什么HTTPS使用混合加密的方式?
  </h3>
  <p>
   可回答：1）HTTPS加密的机制了解过吗？2）HTTPS的加密算法是哪些？3）
   <span class="lake-fontsize-12">
    HTTPS加密过程，为什么不是非对称加密？
   </span>
  </p>
  <p>
   问过的一些公司：字节番茄小说(2022.04)，苏州空天院(2022.08)，最右提前批(2022.08)，美团(2022.08)，阿里社招(2022.05)，字节抖音(2022.04)(2021.08)，京东(2022.04)x2，字节(2021.09)，腾讯音乐(2021.11)，用友(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、混合加密：对称算法和非对称算法
   </strong>
  </p>
  <p>
   HTTPS使用的是混合加密的方式。
   <span class="lake-fontsize-12">
    通过混合加密的⽅式可以保证信息的机密性，解决了窃听的⻛险。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671272647803-d6990ed2-f73b-4abe-a737-ea1fb1e147e1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。采⽤「混合加密」的⽅式的原因：对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。
  </p>
  <p>
   <strong>
    2、摘要（杂凑）算法
   </strong>
  </p>
  <p>
   摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671272928231-8121679b-bf11-4ae2-aa6b-0b4762644292.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。
  </p>
  <p>
   <strong>
    3、小结
   </strong>
  </p>
  <p>
   使用的是混合加密方式，主要使用的是三种类型的算法，对称算法：比如AES、SM4等，非对称算法：比如RSA、SM2等，摘要算法：比如Hash、SM3算法。
  </p>
  <p>
   一般对称算法（加解密秘钥相同）是用来加密数据，也就是加密明文；非对称算法用来加密对称算法的秘钥，非对称算法虽然速度快，但是不适合加密大量的数据；摘要算法一般使用验证数据完整性，验证是否有被修改。
  </p>
  <h3>
   HTTPS加密协议有哪些？
  </h3>
  <p>
   问过的一些公司：金山办公(2022.10)，快手(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS协议的主要功能基本都依赖于TLS/SSL协议。
  </p>
  <p>
   TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684653376540-f60d6e95-6493-448b-9e9c-766b8df159ad.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
   ​
  </p>
  <h3>
   HTTPS加密的是什么？
  </h3>
  <p>
   问过的一些公司：米哈游(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS使用的是混合加密方式。对称算法是加密明文数据，非对称算法是加密对称算法秘钥，摘要（杂凑）算法是用来
   <span class="lake-fontsize-12">
    验证数据完整性，验证数据是否有被修改。
   </span>
  </p>
  <h3>
   HTTP协议和TCP协议的关系是什么？
  </h3>
  <p>
   问过的一些公司：招银网络(2022.03)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP
   <span class="lake-fontsize-12">
    协议是应用层协议，主要是解决如何包装数据。而
   </span>
   <span class="lake-fontsize-12">
    TCP
   </span>
   <span class="lake-fontsize-12">
    协议是传输层协议，主要解决数据如何在网络中传输。
   </span>
  </p>
  <p>
   通俗点说，
   <span class="lake-fontsize-12">
    HTTP
   </span>
   <span class="lake-fontsize-12">
    的任务是与服务器交换信息，它不管怎么连到服务器和保证数据正确的事情。而
   </span>
   <span class="lake-fontsize-12">
    TCP
   </span>
   <span class="lake-fontsize-12">
    的任务是保证连接的可靠，
   </span>
   <span class="lake-fontsize-12">
    为了做到这些，在初次连接时要进行3次握手，以保证确实连接到了目标机器，但是
   </span>
   <span class="lake-fontsize-12">
    它只管连接，它不管连接后要传什么数据。
   </span>
  </p>
  <p>
   <strong>
    一般情况下，
   </strong>
   <strong>
    HTTP协议是建立在TCP协议之上，它可以利用TCP协议提供的可靠性来传输数据。
   </strong>
  </p>
  <p>
   但是在某些情况下，http可以不通过tcp实现，那就不需要3次握手。
  </p>
  <p>
   比如，做一把遥控咖啡壶，遥控器和壶通过红外直接连接，通过htcpcp（RFC2324定义的超文本咖啡壶控制协议）与咖啡壶交互。字符直接调制到红外上，此时htcpcp应用层下面直接是物理层，当然不存在3次握手了，连ip地址和mac地址也不存在。
  </p>
  <p>
   HTTP属于TCP/IP协议族，所以绝大多数情况下HTTP下面是TCP。强行构造例外也不是绝对不行（比如上面的小案例），但这样做是不实用的。
  </p>
  <h3>
   为什么HTTPS还会有被抓包的风险？
  </h3>
  <p>
   问过的一些公司：最右提前批(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。
  </p>
  <p>
   但是，我们可以通过抓包工具来抓包。它的原理其实是模拟一个中间人。
  </p>
  <ul list="uc89bbda5">
   <li fid="u99b14a5f">
    <strong>
     中间人攻击
    </strong>
    ：中间人攻击是指攻击者可以拦截双方的通信，把自己植入到双方中间，截取双方的信息。
   </li>
  </ul>
  <p>
   通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。
  </p>
  <h3>
   HTTP和RPC的区别？
  </h3>
  <p>
   问过的一些公司：字节(2022.09)，猿辅导(2022.08)x2，经纬恒润(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP
   <span class="lake-fontsize-12">
    是指从客户端到服务器端的请求消息，
   </span>
   <span class="lake-fontsize-12">
    RPC
   </span>
   <span class="lake-fontsize-12">
    是远程过程调用协议。
   </span>
  </p>
  <p>
   HTTP是一种应用层协议，它定义了客户端和服务器之间的通信模型。它允许客户端发出请求，服务器返回响应。它是一种基于文本的协议，因此它可以用于传输任何类型的数据。
  </p>
  <p>
   RPC是远程过程调用的缩写，它是一种通信协议，允许远程程序调用（RPC）。它允许程序调用另一个程序，而无需了解其位置或细节，只需知道它的函数签名和参数类型即可。它使用消息传递系统，如XML-RPC或SOAP，以便在不同的计算机之间进行通信。
  </p>
  <p>
   <strong>
    HTTP和RPC的区别
   </strong>
  </p>
  <p style="text-align: justify">
   <strong>
    传输协议
   </strong>
  </p>
  <p style="text-align: justify">
   RPC：可以基于TCP协议，也可以基于HTTP协议
  </p>
  <p style="text-align: justify">
   HTTP：基于HTTP协议
  </p>
  <p style="text-align: justify">
   <strong>
    传输效率
   </strong>
  </p>
  <p style="text-align: justify">
   RPC：使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率
  </p>
  <p style="text-align: justify">
   HTTP：如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理
  </p>
  <p style="text-align: justify">
   <strong>
    性能消耗
   </strong>
  </p>
  <p style="text-align: justify">
   RPC：可以基于thrift实现高效的二进制传输
  </p>
  <p style="text-align: justify">
   HTTP：大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能
  </p>
  <p style="text-align: justify">
   <strong>
    负载均衡
   </strong>
  </p>
  <p style="text-align: justify">
   RPC：基本都自带了负载均衡策略
  </p>
  <p style="text-align: justify">
   HTTP：需要配置Nginx，HAProxy来实现
  </p>
  <p style="text-align: justify">
   <strong>
    服务治理
   </strong>
  </p>
  <p style="text-align: justify">
   RPC：能做到自动通知，不影响上游
  </p>
  <p style="text-align: justify">
   HTTP：需要事先通知，修改Nginx/HAProxy配置
  </p>
  <p style="text-align: justify">
   RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。
  </p>
  <h3>
   RPC在哪一层实现？
  </h3>
  <p>
   问过的一些公司：猿辅导(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   会话层
  </p>
  <h3>
   HTTP和RPC分别运行的协议，HTTP和RPC的序列化？
  </h3>
  <p>
   问过的一些公司：字节(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p style="text-align: justify">
   RPC：可以基于TCP协议，也可以基于HTTP协议
  </p>
  <p style="text-align: justify">
   HTTP：基于HTTP协议
  </p>
  <p style="text-align: justify">
   不管是 RPC 或者 HTTP，只要传输的内容是「对象」，要想在接收方还原出一摸一样的「对象」，那就需要序列化和反序列化。
  </p>
  <p style="text-align: justify">
   <strong>
    1、什么是序列化和反序列化
   </strong>
  </p>
  <p style="text-align: justify">
   RPC 能帮助我们的应用透明地完成远程调用，即调用其他服务器的函数就像调用本地方法一样。发起调用请求的那一方叫做调用方，被调用的一方叫做服务提供方。
  </p>
  <p>
   调用方和服务提供方一般是不同的服务器，所以就需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 协议来传输。同时， HTTP 协议也是建立在 TCP 之上的。
  </p>
  <p>
   网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象，而对象是肯定没法直接在网络中传输的，需要提前把「对象转成二进制数据」进行网络传输，这个转换过程就做序列化。相反，服务提供方收到网络数据后，需要将「二进制数据转成对象」，这个转换过程就叫做反序列化。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671460823091-0fcf37fd-bff2-4a69-855c-9446a628ba28.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p style="text-align: justify">
   总结来说，
   <strong>
    序列化就是将对象转换成二进制数据的过程，以方便传输或存储。而反序列就是将二进制转换为对象的过程。
   </strong>
  </p>
  <p style="text-align: justify">
   <strong>
    2、序列化的原因
   </strong>
  </p>
  <p style="text-align: justify">
   1）结构化的数据不利于网络的传输(为了应用层网络通信的方便)。
  </p>
  <p style="text-align: justify">
   2）为了方便上层使用内部成员，将应用层和网络进行了解耦。
  </p>
  <p style="text-align: justify">
   <strong>
    3、RPC序列化
   </strong>
  </p>
  <p style="text-align: justify">
   我们先来看看
   <span class="lake-fontsize-12">
    RPC的通信流程
   </span>
  </p>
  <p style="text-align: justify">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671460921240-70f43774-fdbd-4484-a266-77f05d75de30.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_52%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p style="text-align: justify">
   比如发快递，我们要发一个需要自行组装的物件。发件人发之前，会把物件拆开装箱，这就好比序列化；这时候快递员来了，不能磕碰呀，那就要打包，这就好比将序列化后的数据进行编码，封装成一个固定格式的协议；过了两天，收件人收到包裹了，就会拆箱将物件拼接好，这就好比是协议解码和反序列化。
  </p>
  <p style="text-align: justify">
   因为网络传输的数据必须是二进制数据，所以
   <strong>
    在 RPC 调用中，对入参对象与返回值对象进行序列化与反序列化是一个必须的过程
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p style="text-align: justify">
   <strong>
    4、HTTP序列化
   </strong>
  </p>
  <p style="text-align: justify">
   当客户端与服务端进行数据交互时，发送方需要通过JSON将对象转换成二进制数据发送到网络，接收方需要通过JSON将接收到的二进制数据转换成对象。
  </p>
  <h3>
   HTTPS中的S代表什么？介于拿两层之间起作用？对于应用层透明吗？
  </h3>
  <p>
   问过的一些公司：字节(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    HTTPS 的目的是将这些内容加密，确保信息传输安全
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
   <strong>
    最后一个字母 S 指的是 SSL/TLS 协议
   </strong>
   <span class="lake-fontsize-12">
    ，它位于 HTTP 协议与 TCP/IP 协议中间，它是一个单独的协议，并且可以与应用层上其他协议进行搭配使用比如telenet，ftp等协议。这一层协议加在了传输层与应用层之间，它使通通信更加安全，通信可以互相验证对方身份，并且保证了数据传输完整性，对通信数据进行了加密，即使被攻击者截取到了数据流，也很难解析出有用的信息。
   </span>
  </p>
  <p>
   HTTPS对于客户端和服务器来讲，应用层协议还是HTTP，只是加了一个SSL层来做加密解密的逻辑，
   <strong>
    对应用层来说是透明的
   </strong>
   <span class="lake-fontsize-12">
    ，在网络上传输的都是加密的请求和加密的响应，从而达到安全传输的目的。
   </span>
  </p>
  <h3>
   说一下HTTP如何启动传输Gzip
  </h3>
  <p>
   问过的一些公司：快手(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   浏览器发送Http request 给Web服务器,  request 中有Accept-Encoding: gzip, deflate。 (告诉服务器， 浏览器支持gzip压缩)
  </p>
  <p>
   Web服务器接到request后， 生成原始的Response, 其中有原始的Content-Type和Content-Length。
  </p>
  <p>
   Web服务器通过Gzip，来对Response进行编码， 编码后header中有Content-Type和Content-Length(压缩后的大小)， 并且增加了Content-Encoding:gzip.  然后把Response发送给浏览器。
  </p>
  <p>
   浏览器接到Response后，根据Content-Encoding:gzip来对Response 进行解码。 获取到原始response后， 然后显示出网页。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671463265906-2eb7c57b-50be-4bf6-b062-aede7cc0329d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   URL地址
  </h3>
  <p>
   问过的一些公司：字节(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   URL（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。
  </p>
  <p>
   URL地址一般由三部分组成：
  </p>
  <ul list="u14631796">
   <li fid="u6e9c5332">
    客户端与服务器之间的通信协议；
   </li>
   <li fid="u6e9c5332">
    存有该资源的服务器名称；
   </li>
   <li fid="u6e9c5332">
    资源在服务器上具体的存放位置。
   </li>
  </ul>
  <h3>
   HTTPS默认port
  </h3>
  <p>
   问过的一些公司：百度(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   443
  </p>
  <h3>
   HTTP2.0是怎么做到多路复用的呢？
  </h3>
  <p>
   问过的一些公司：蔚来数字化业务(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP 1.X 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传。但
   <strong>
    HTTP 2.0 是基于二进制流的。有两个非常重要的概念，分别是帧（frame）和流（stream）
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <ul list="u2eaaf8da">
   <li fid="u50e9443b" style="text-align: left">
    帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流。
   </li>
   <li fid="u50e9443b" style="text-align: left">
    流就是多个帧组成的数据流。
   </li>
  </ul>
  <p style="text-align: left">
   将
   <strong>
    HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <ul list="u1169e4bc">
   <li fid="u69fcac2c" style="text-align: left">
    并行交错地发送多个请求，请求之间互不影响。
   </li>
   <li fid="u69fcac2c" style="text-align: left">
    并行交错地发送多个响应，响应之间互不干扰。
   </li>
   <li fid="u69fcac2c" style="text-align: left">
    使用一个连接并行发送多个请求和响应。
   </li>
  </ul>
  <p style="text-align: left">
   简单的来说：
   <strong>
    在同一个TCP连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应。
   </strong>
  </p>
  <p style="text-align: left">
   之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求。
  </p>
  <p>
   我们再来看一张图：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671465140344-498b3034-8967-4129-b894-5cd7dc804342.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   HTTP/1.1协议的请求-响应模型大家都是熟悉的，我们用“HTTP消息”来表示一个请求-响应的过程，那么HTTP/1.1中的消息是“管道串形化”的：只有等一个消息完成之后，才能进行下一条消息。
  </p>
  <p>
   而HTTP/2中多个消息交织在了一起，这无疑提高了“通信”的效率。这就是
   <strong>
    多路复用：在一个HTTP的连接上，多路“HTTP消息”同时工作
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <h3>
   从输入url到显示页面的过程
  </h3>
  <p>
   可回答：1）在浏览器中输⼊url地址-&gt;&gt;会发生什么过程？2）在浏览器上输入一个URL，到最终页面呈现经历了哪些过程？3）从网页端输入url，到后端的过程，都经过了哪些协议？4）得到网页的IP地址之后是如何建立连接的？5）浏览器打开网页的全过程；6）浏览器输入网址后到后端服务器之间经历了哪些层、哪些节点、协议、数据转换？
  </p>
  <p>
   问过的一些公司：字节基础架构北京(2022.10)，去哪儿北京(2022.10)，海雀科技(2022.10)，极致游戏(2022.10)，天翼云(2022.10)，成都蚂蚁(2022.09)，阿里(2022.09)，阿里菜鸟(2022.09)，掌趣(2022.09)，美团(2022.09)(2021.08)x4，好未来(2022.09)，奇安信(2022.09)，百度提前批(2022.08)，字节飞书(2022.08)x2，字节(2022.08)(2021.12)，翼支付(2022.08)，猿辅导(2022.08)，科大讯飞(2022.08)，OPPO(2022.08)，大应科技(2022.08)，米哈游(2022.08)，联想战略分析(2022.08)，快手(2022.08)(2021.09)，用友(2022.08)，蔚来(2022.07)，麦吉太文(2021.11)，阿里蚂蚁金服(2021.11)，今日头条(2021.09)，转转(2021.08)，腾讯(2021.08)，有赞(2021.08)，趋势科技(2021.08)，顺丰(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   （1）解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
  </p>
  <p>
   （2）缓存判断：
   <span class="lake-fontsize-12">
    浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
   </span>
  </p>
  <p>
   （3）DNS解析：
   <span class="lake-fontsize-12">
    下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
   </span>
  </p>
  <p>
   （4）获取MAC地址：
   <span class="lake-fontsize-12">
    当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
   </span>
  </p>
  <p>
   （5）TCP三次握手：
   <span class="lake-fontsize-12">
    下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
   </span>
  </p>
  <p>
   （6）HTTPS握手：
   <span class="lake-fontsize-12">
    如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
   </span>
  </p>
  <p>
   （7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
  </p>
  <p>
   （8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
  </p>
  <p>
   （9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
  </p>
  <h3>
   网址输入到渲染过程中使用的协议？
  </h3>
  <p>
   问过的一些公司：海雀科技(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   DNS：获取域名对应IP
  </p>
  <p>
   TCP（传输控制协议）：与服务器建立 连接
  </p>
  <p>
   IP：建立TCP连接时，使用IP协议在网络层发送数据
  </p>
  <p>
   OPSF（开放式最短路径优先）：IP数据包在路由器之间进行路由选择
  </p>
  <p>
   ARP（地址解析协议）：路由器在与服务器通信时，将IP地址转换为MAC地址
  </p>
  <p>
   HTTP：TCP建立完成后，使用HTTP协议访问网页
  </p>
  <h3>
   url输入以后每一层都负责了什么工作？
  </h3>
  <p>
   问过的一些公司：字节抖音(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   在浏览器输入URL后，OSI模型中每一层都负责了以下工作：
  </p>
  <p>
   应用层：负责提供具体的网络服务，如HTTP、FTP、DNS等。在这一层，浏览器会根据URL中的域名，通过DNS协议，查找对应的IP地址，并通过HTTP协议，向服务器发送请求报文。
  </p>
  <p>
   表示层：负责处理数据的表达方式，如编码、加密、压缩等。在这一层，浏览器和服务器会协商数据的格式和编码方式。
  </p>
  <p>
   会话层：负责建立、管理和终止会话。在这一层，浏览器和服务器会通过握手和认证等方式，建立一个可靠的通信会话。
  </p>
  <p>
   传输层：负责提供端到端的可靠数据传输服务，如TCP、UDP等。在这一层，浏览器会根据IP地址和端口号，通过TCP协议，与服务器建立一个双向的连接，并通过序号、确认号、重传等机制，保证数据的完整性和有序性。
  </p>
  <p>
   网络层：负责提供逻辑地址（IP地址）和路由选择功能，如IP、ICMP、ARP等。在这一层，浏览器会根据IP地址，通过路由器等设备，寻找到达服务器的最佳路径，并通过分片、组装等方式，将数据包发送到目的地。
  </p>
  <p>
   数据链路层：负责提供物理地址（MAC地址）和错误检测功能，如以太网、PPP等。在这一层，浏览器会根据MAC地址，通过交换机等设备，将数据帧发送到相邻的节点，并通过CRC等方式，检测数据帧的错误。
  </p>
  <p>
   物理层：负责提供比特流的传输服务，如电缆、光纤等。在这一层，浏览器会将数据帧转换为电信号或光信号，并通过物理介质进行传输。
  </p>
  <h3>
   DNS解析出错，怎么排查错误？
  </h3>
  <p>
   问过的一些公司：字节(2021.12)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671466162770-b1b87a00-a3a9-4be8-af93-c13f38123efd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   DNS是哪层的协议？
  </h3>
  <p>
   问过的一些公司：字节(2021.10)，字节番茄小说(2021.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   应用层协议，主要用来获取域名对应IP
  </p>
  <h3>
   DNS用的是什么协议？
  </h3>
  <p>
   问过的一些公司：字节(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   DNS主要作用就是将主机域名转换为IP地址。当用户主机的DNS客户端接收到应用程序的这种转换请求时（例如调用gethostbyname()系统函数），那么就会向网络中发送一个DNS查询报文。需要了解的是，DNS请求和回答报文的下层都是使用UDP数据报经过53端口发送的。
  </p>
  <p>
   那么为什么使用UDP（User Datagram Protocol）这样面向无连接的，尽最大能力交付的不可靠数据连接，而不是使用TCP（Transmission Control Protocol）这样的面向连接的可靠数据连接。
  </p>
  <p>
   因为相比较与TCP来说，一次UDP域名服务器的交换可以短到只有两个报文，一个查询报文、一个响应报文。一次TCP交换则至少包含九个传送报文：三次握手初始化TCP会话、一个查询报文、一个响应报文、四次挥手的TCP中断连接（或许是八个报文，毕竟连接建立时第二个ACK报文是可以携带数据的，谁知道呢，反正也比两个报文要多）。所以
   <strong>
    考虑到效率的原因，TCP连接的开销更大，故而采用UDP作为DNS的传输层协议
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   当然还有另外一点需要注意，整个DNS服务体系中，并不是只有UDP一种协议存在，上述域名解析时使用的是UDP，但是
   <strong>
    在区域传送时还是使用TCP
   </strong>
   <span class="lake-fontsize-12">
    。辅域名服务器会定时（一般是三小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。
   </span>
   <strong>
    区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多，
   </strong>
   <strong>
    使用TCP更加可靠。
   </strong>
  </p>
  <p>
   综上所述。
  </p>
  <p>
   <strong>
    DNS 既使用 TCP 又使用 UDP。
   </strong>
   <span class="lake-fontsize-12">
    当
   </span>
   <strong>
    进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP
   </strong>
   <span class="lake-fontsize-12">
    ，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。
   </span>
  </p>
  <p>
   <strong>
    当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，此时使用 UDP
   </strong>
   <span class="lake-fontsize-12">
    。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。
   </span>
  </p>
  <h3>
   说一下DNS解析过程
  </h3>
  <p>
   可回答：1）DNS解析的数据结构；2）DNS说的细一点具体怎么实现的；3）
   <span class="lake-fontsize-12">
    DNS机制；4）
   </span>
   <span class="lake-fontsize-12">
    DNS是怎么用域名查找到ip地址的，具体流程
   </span>
  </p>
  <p>
   问过的一些公司：海雀科技(2022.10)，阿里菜鸟(2022.09)，美团(2022.08)，东方财富(2022.08)，百度(2021.09)，大应科技(2022.08)，字节(2021.08)(2021.09)，小米(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、什么是DNS以及它的作用
   </strong>
  </p>
  <p>
   <strong>
    DNS是计算机域名系统
   </strong>
   <span class="lake-fontsize-12">
    （Domain Name System 或 Domain Name Service）的缩写，它是由解析器和域名服务器组成的，
   </span>
   <strong>
    作用是把域名转换成为网络可以识别的IP地址
   </strong>
   <span class="lake-fontsize-12">
    。比如我们上网时输入的
   </span>
   <span class="lake-fontsize-12">
    www.XXXX.com
   </span>
   <span class="lake-fontsize-12">
    会自动转换成为202.108.xxx.xxx（IP地址）。
   </span>
  </p>
  <p>
   <strong>
    2、DNS解析过程
   </strong>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684653463851-ac5a6c39-3cc2-4c3f-b71d-77b5a0f3ce9f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   当用户在浏览器中输入www.baidu.com的时候，DNS解析大概会有以下过程：
  </p>
  <ol list="u8a3acd2e">
   <li fid="u9599d313">
    首先浏览器会检查自身缓存是否解析过这个域名的IP地址，如果有即缓存命中，那么解析结束；
   </li>
   <li fid="u9599d313">
    如果浏览器缓存中没有，那么浏览器会检查操作系统缓存中是否有相应的解析过的结果。而操作系统也有一个域名解析的过程。像我们熟悉的hosts文件，如果用户在这里定义了一个域名对应的IP地址，那么浏览器会首先使用这里定义的IP地址；
   </li>
   <li fid="u9599d313">
    如果此时还没有命中域名，才会真正地去请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不是很远，并且这台服务器的性能很好，一般这里会缓存域名解析的结果。大约80%的域名解析到这里就完成了；
   </li>
   <li fid="u9599d313">
    如果LDNS仍然没有命中，那么LDNS就会向根域名服务器（Root Server）发起域名请求解析；
   </li>
   <li fid="u9599d313">
    根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com、.cn、.org等）地址；
   </li>
   <li fid="u9599d313">
    此时LDNS再发送请求到上一步返回的gTLD的IP地址；
   </li>
   <li fid="u9599d313">
    接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器；
   </li>
   <li fid="u9599d313">
    Name Server根据映射关系表找到目标IP地址，并将其返回给LDNS；
   </li>
   <li fid="u9599d313">
    LDNS缓存这个域名和对应的IP；
   </li>
   <li fid="u9599d313">
    LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。
   </li>
  </ol>
  <p>
   <strong>
    3、DNS的递归查询和迭代查询
   </strong>
  </p>
  <p>
   <strong>
    1）递归查询
   </strong>
  </p>
  <p>
   如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。
  </p>
  <p>
   我们以一个例子来了解DNS递归查询的工作原理，假设图中的主机 (IP地址为m.xyz.com) 想知道域名y.abc.com的IP地址。
  </p>
  <p>
   递归查询过程如下：
  </p>
  <ol list="u87785079">
   <li fid="u09fae4e6">
    主机首先向其本地域名服务器进行递归查询。
   </li>
   <li fid="u09fae4e6">
    本地域名服务器收到递归查询的委托后，也采用递归查询的方式向某个根域名服务器查询。
   </li>
   <li fid="u09fae4e6">
    根域名服务器收到递归查询的委托后，也采用递归查询的方式向某个顶级域名服务器查询。
   </li>
   <li fid="u09fae4e6">
    顶级域名服务器收到递归查询的委托后，也采用递归查询的方式向某个权限域名服务器查询。
   </li>
  </ol>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671511018575-6f846527-fffe-44bd-9cca-a7042a0b9859.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   当查询到域名对应的IP地址后，查询结果会在之前受委托的各域名服务器之间传递，最终传回给用户主机。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671511053550-6f8e3830-3098-4ea9-82cc-b1cda5afeec4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    2）迭代查询
   </strong>
  </p>
  <p>
   当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。
  </p>
  <p>
   迭代查询过程如下：
  </p>
  <ol list="u779632ac">
   <li fid="u7a699ab3">
    主机首先向其本地域名服务器进行递归查询。
   </li>
   <li fid="u7a699ab3">
    本地域名服务器采用迭代查询，它先向某个根域名服务器查询。
   </li>
   <li fid="u7a699ab3">
    根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器的IP地址。
   </li>
   <li fid="u7a699ab3">
    本地域名服务器向顶级域名服务器进行迭代查询。
   </li>
   <li fid="u7a699ab3">
    顶级域名服务器告诉本地域名服务器，下一次应查询的权限域名服务器的IP地址。
   </li>
   <li fid="u7a699ab3">
    本地域名服务器向权限域名服务器进行迭代查询。
   </li>
   <li fid="u7a699ab3">
    权限域名服务器告诉本地域名服务器所查询的域名的IP地址。
   </li>
   <li fid="u7a699ab3">
    本地域名服务器最后把查询的结果告诉主机。
   </li>
  </ol>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671511327359-f85f3b64-e111-44f8-8c9b-e7b505a4799b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   由于递归查询对于被查询的域名服务器负担太大，通常采用以下模式：
   <strong>
    从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。
   </strong>
  </p>
  <h3>
   DNS缓存
  </h3>
  <p>
   问过的一些公司：东方财富(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、什么是DNS缓存
   </strong>
  </p>
  <p>
   当我们第一次访问某个网站时，DNS在返回对应的IP地址后，系统会将这个记录临时存储下来，并为其设定一个有效期限（TTL），在有效期限内再次访问该网站，系统会直接将该结果返回，而无需求助DNS系统进行全球查询。这个临时储存下来的记录就是DNS缓存。如果超过DNS缓存的有效期限再次对该网站，系统会自动再次询问DNS服务器以获得最新的结果。
  </p>
  <p style="text-align: justify">
   <strong>
    2、DNS缓存的作用
   </strong>
  </p>
  <p style="text-align: justify">
   DNS域名解析（一般）采用的是UDP协议通讯，受外部网络环境的影响较大，尤其是在有丢包的情况下会产生较高的时延，严重影响用户上网体验，而DNS缓存机制就是在这种背景下产生的。
  </p>
  <p style="text-align: justify">
   DNS缓存可以在用户发起请求时，直接将记录结果返回，不需要委托递归服务器进行全球查询，这样就极大提升了DNS域名解析效率，减小了多次查询所带来的时延问题。此外，由于不必每次都请求权威解析服务器进行查询，所以缓存机制还能大幅节省权威服务器的性能消耗，减轻权威服务器的请求压力。
  </p>
  <p style="text-align: justify">
   <strong>
    3、DNS缓存的缺点
   </strong>
  </p>
  <p style="text-align: justify">
   DNS缓存虽然能够在一定程度上提升域名解析的速度，但同样也存在一些弊端，如DNS缓存需要消耗一定的系统资源，增加了域名系统的复杂性。此外TTL值的设置对于平衡DNS解析速度和精度产生了较大影响。如果TTL值较短，能够在较短时间内刷新最新解析记录，但会对解析服务器造成较大压力；如果TTL过大，则可能导致地址变更时，用户无法及时获得最新记录，从而导致站点不可达或者访问到错误网站，影响正常业务开展，并增加DNS被劫持的风险。
  </p>
  <p style="text-align: justify">
   <strong>
    3、DNS缓存使用中的问题
   </strong>
  </p>
  <p style="text-align: justify">
   由于DNS缓存机制存在以上弊端，所以如果DNS缓存设置使用不当，反而会适得其反出现以下几个方面的问题给用户正常访问带来负面影响。
  </p>
  <p style="text-align: justify">
   （1）缓存刷新不受控
  </p>
  <p style="text-align: justify">
   当域名发生变更时，无法刷新全球递归服务器缓存和客户端上DNS缓存中的记录，在缓存TTL值是小钱，客户发起请求仍会按照缓存记录的原有映射关系发起请求，只有当递归服务器和客户端上的缓存失效后，才会重新发起请求。在此过程中，因为域名解析到错误IP会产生很大的安全风险。
  </p>
  <p style="text-align: justify">
   （2）解析权和缓存值被修改
  </p>
  <p style="text-align: justify">
   一些小运营商出于成本考虑，经常会将域名转发到其他运营商进行解析，并将收到的域名缓存值修改为较大值，这样就会带来两个方面问题：
  </p>
  <ul list="ub5acf727">
   <li fid="u4ec3488e" style="text-align: justify">
    权威DNS接收到的请求 IP 地址不是客户所在运营商 IP 地址，客户的请求可能会被引导至错误的线路，导致客户访问慢；
   </li>
   <li fid="u4ec3488e" style="text-align: justify">
    企业域名发生改变后将等待更长的超时时间才能正常访问业务，同样会给客户带来较差的体验。
   </li>
  </ul>
  <p style="text-align: justify">
   因此，为了消除DNS缓存带来的种种问题，企业在设置域名解析时应做好解析速度和安全性之间的平衡，设置好合适的TTL值，而对于客户端来说，经常性地清理DNS缓存，保证实时获取最新解析记录，则可以有效避免上述问题。
  </p>
  <h3>
   DNS解析在网络不好的情况下怎么办？
  </h3>
  <p>
   问过的一些公司：百度(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   DNS解析在网络不好的情况下可能会出现以下问题：
  </p>
  <ul list="uf9c51e2a">
   <li fid="ucdab9772">
    解析速度慢：DNS解析需要向DNS服务器发送请求并等待响应，如果网络不好，请求和响应的延迟会增加，导致解析速度变慢。
   </li>
   <li fid="ucdab9772">
    解析失败：如果DNS服务器无法访问或响应超时，DNS解析将失败，导致无法访问目标网站。
   </li>
  </ul>
  <p>
   为了避免这些问题，可以采取以下措施：
  </p>
  <ul list="u31162cdb">
   <li fid="u053f5ec7">
    更换本地DNS的方法：您可以修改本地网络连接的TCP/IP协议，使用其他的DNS服务器地址，如8.8.8.8和8.8.4.4，这是谷歌提供的公共DNS服务器。
   </li>
   <li fid="u053f5ec7">
    修改HOSTS文件的方法：您可以在本地系统中找到HOSTS文件，它是一个记录域名和IP地址对应关系的文件，您可以在其中添加您想访问的域名和IP地址，这样就可以绕过DNS解析的过程。
   </li>
   <li fid="u053f5ec7">
    清除DNS缓存信息的方法：您可以在命令行窗口中输入ipconfig /flushdns命令，来清除本地系统中缓存的DNS信息，这样就可以避免使用过期或错误的DNS记录。
   </li>
  </ul>
  <h3>
   GET和POST的区别
  </h3>
  <p>
   可回答：1）HTTP请求post和get的区别？
  </p>
  <p>
   问过的一些公司：苏小妍(2022.09)，字节(2022.08)(2021.10)，阿里巴巴杭州淘系(2022.08)，快手(2022.08)，米哈游(2022.08)，经纬恒润(2022.08)，字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   1、url可见性：get，参数url可见；post，url参数不可见
  </p>
  <p>
   2、数据传输上：get，通过拼接url进行传递参数；post，通过body体传输参数
  </p>
  <p>
   3、缓存性：get请求是可以缓存的；post请求不可以缓存
  </p>
  <p>
   4、后退页面的反应：get请求页面后退时，不产生影响；post请求页面后退时，会重新提交请求
  </p>
  <p>
   5、安全性：因为get会在url携带参数，post参数是在请求体，所以post比get安全一点
  </p>
  <h3>
   用get和post传输的时候有个编码，那个编码的作用是什么
  </h3>
  <p>
   问过的一些公司：字节(2021.10)，汉得信息(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   GET和POST传输的时候，通常需要对数据进行编码，以保证数据的完整性和安全性。编码的作用有以下几点：
  </p>
  <ul list="u1a196374">
   <li fid="u7055f6f6">
    防止数据中的特殊字符被误解或丢失，如空格、&amp;、=等。
   </li>
   <li fid="u7055f6f6">
    保持数据的一致性，避免不同的字符集或语言造成的乱码问题。
   </li>
   <li fid="u7055f6f6">
    保护数据的隐私，防止敏感信息被泄露或篡改。
   </li>
  </ul>
  <p>
   不同的编码方式有不同的规则和适用场景，常见的编码方式有：
  </p>
  <ul list="ua36a43f6">
   <li fid="u85040afd">
    URL编码：将数据中的特殊字符转换为%加上两位十六进制数，如空格转换为%20。URL编码适用于GET请求，因为GET请求会将数据附加在URL后面。
   </li>
   <li fid="u85040afd">
    表单编码：将数据中的特殊字符转换为+或%加上两位十六进制数，如空格转换为+。表单编码适用于POST请求，因为POST请求会将数据放在请求体中。
   </li>
   <li fid="u85040afd">
    JSON编码：将数据转换为JSON格式的字符串，如{“name”:“张三”,“age”:18}。JSON编码适用于传输复杂的数据结构，如数组、对象等。
   </li>
  </ul>
  <h3>
   GET和POST都是幂等的吗？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   安全和幂等的概念：
  </p>
  <ul list="u9a07880d">
   <li fid="ue69fccc1">
    在HTTP协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
   </li>
   <li fid="ue69fccc1">
    所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
   </li>
  </ul>
  <p>
   如果从RFC规范定义的语义来看：
  </p>
  <p>
   <strong>
    GET方法就是安全且幂等的
   </strong>
   <span class="lake-fontsize-12">
    ，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中GET请求可以保存为书签。
   </span>
  </p>
  <p>
   <strong>
    POST
   </strong>
   <span class="lake-fontsize-12">
    因为是「新增或提交数据」的操作，会修改服务器上的资源，
   </span>
   <strong>
    所以是不安全的
   </strong>
   <span class="lake-fontsize-12">
    ，且多次提交数据就会创建多个资源，
   </span>
   <strong>
    所以不是幂等的
   </strong>
   <span class="lake-fontsize-12">
    。所以，浏览器一般不会缓存POST请求，也不能把POST请求保存为书签。
   </span>
  </p>
  <p>
   综上所述：
  </p>
  <ul list="u79486ca8">
   <li fid="u5a3489d3">
    GET的语义是请求获取指定的资源。
    <strong>
     GET方法是安全、幂等、可被缓存的
    </strong>
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
   <li fid="u5a3489d3">
    POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。
    <strong>
     POST不安全，不幂等，（大部分实现）不可缓存
    </strong>
    <span class="lake-fontsize-12">
     。
    </span>
   </li>
  </ul>
  <p>
   上面是从RFC规范定义的语义来分析的。
  </p>
  <p>
   但是实际过程中，开发者不一定会按照RFC规范定义的语义来实现GET和POST方法。比如：
  </p>
  <ul list="uddb1a51e">
   <li fid="u6cc5e1ac">
    可以用GET方法实现新增或删除数据的请求，这样实现的GET方法自然就不是安全和幂等。
   </li>
   <li fid="u6cc5e1ac">
    可以用POST方法实现查询数据的请求，这样实现的POST方法自然就是安全和幂等。
   </li>
  </ul>
  <h3>
   HTTP的post请求报文的组成结构
  </h3>
  <p>
   问过的一些公司：睿联(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   HTTP的POST请求报文由报文首部和报文主体两部分组成。
  </p>
  <p>
   报文首部包含了请求方式、请求的URL、HTTP协议版本、请求头、请求实体等信息，以及其他一些控制和标记信息，例如Cache-control、Cookie、User-Agent、Content-Type等等。
  </p>
  <p>
   报文主体则是请求需要发送的数据，也就是请求的参数，例如表单数据、JSON数据等等。在POST请求中，请求参数是放在请求体中传递的。
  </p>
  <p>
   POST请求报文的组成结构如下：
  </p>
  <ul list="u586a7700">
   <li fid="u4bbf8151">
    请求行：包含请求方法（POST）、请求资源的URI和HTTP协议版本。
   </li>
   <li fid="u4bbf8151">
    请求头：包含一些与请求相关的信息，如Host、User-Agent、Content-Type、Content-Length等。
   </li>
   <li fid="u4bbf8151">
    空行：用于分隔请求头和请求体。
   </li>
   <li fid="u4bbf8151">
    请求体：包含要发送给服务器的数据，如表单数据、JSON数据、文件数据等。
   </li>
  </ul>
  <p>
   下面是一个POST请求报文的示例：
  </p>
  <pre><code class="language-json" lang="json">POST /api/login HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Content-Length: 21
Connection: keep-alive
Referer: http://www.example.com/login.html

username=admin&amp;password=123456</code></pre>
  <h3>
   登录的时候用什么保存状态？
  </h3>
  <p>
   问过的一些公司：字节(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   session和cookie
  </p>
  <h3>
   一个MTU最大是1500字节，那么最多包含多少的数据？
  </h3>
  <p>
   问过的一些公司：字节(2022.01)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ip头部字节大小为20~60，最多数据即1500-20=1480
  </p>
  <h3>
   路由器和交换机区别
  </h3>
  <p>
   可回答：1）路由器和交换机
  </p>
  <p>
   问过的一些公司：猿辅导(2022.08)，中望(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    路由器（Router）是连接两个或多个网络的硬件设备，在网络间起网关的作用
   </strong>
   <span class="lake-fontsize-12">
    ，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。
   </span>
  </p>
  <p>
   <strong>
    交换机
   </strong>
   <span class="lake-fontsize-12">
    （Switch）意为“开关”，
   </span>
   <strong>
    是一种用于电（光）信号转发的网络设备
   </strong>
   <span class="lake-fontsize-12">
    。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。其他常见的还有电话语音交换机、光纤交换机等。
   </span>
  </p>
  <p>
   <strong>
    路由器工作在第三层（网络层）
   </strong>
   <span class="lake-fontsize-12">
    ，
   </span>
   <strong>
    交换机工作在第二层（链路层）
   </strong>
   <span class="lake-fontsize-12">
    （根据OSI模型的网络体系划分，自底向上）。
   </span>
  </p>
  <p>
   路由器寻址依靠IP地址寻址、转发，交换机依靠 MAC 地址过滤、转发。
  </p>
  <ul list="u2422a7a6">
   <li fid="uef59fa01">
    路由器内有一份路由表，里面有它的寻址信息（就像是一张地图），它收到网络层的数据报后，会根据路由表和选路算法将数据报转发到下一站（可能是路由器、交换机、目的主机）
   </li>
   <li fid="uef59fa01">
    交换机内有一张MAC表，里面存放着和它相连的所有设备的MAC地址，它会根据收到的数据帧的首部信息内的目的MAC地址在自己的表中查找，如果有就转发，如果没有就放弃
   </li>
  </ul>
  <p>
   交换机用于连接局域网，数据包在局域网内网的数据转发，路由器用于连接局域网和外网，数据包可以在不同局域网转发。
  </p>
  <p>
   交换机负责具体的数据包传输，路由器不负责包的实际传输，路由器只封装好要传输的数据包，然后交给交换机去传输（不一定是交换机，可能是其他传输技术），用java比喻大概简单理解为路由器是抽象类，定义好传输的数据包格式，交换机是具体实现类，也可以有其他实现类
  </p>
  <p>
   交换机没有MAC地址和IP地址，路由器有MAC地址和IP地址（指纯碎的交换机和路由器，三层交换机是可以有IP地址的，路由器也有内置交换机功能的）
  </p>
  <h3>
   路由器在哪层
  </h3>
  <p>
   问过的一些公司：字节提前批(2022.08)，华为(2022.05)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   路由器工作在OSI七层模型的第三层
   <strong>
    网络层
   </strong>
   <span class="lake-fontsize-12">
    ，根据IP地址寻址，可以处理TCP/IP协议。
   </span>
  </p>
  <h3>
   路由器的转发原理
  </h3>
  <p>
   问过的一些公司：华为(2022.05)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   当一个数据来到路由器，路由器将基于数据包中的目标IP地址，查看本地的路由表。之后，若表中存在记录，则将无条件按照表中的记录进行转发；若表中不存在记录，则路由器将直接丢弃该数据包。
  </p>
  <h3>
   路由转发表有什么内容
  </h3>
  <p>
   问过的一些公司：华为(2022.05)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   路由表包含路由选择的必要信息，主要内容如下：
  </p>
  <ol list="u38271bcb">
   <li fid="ud527aa7a">
    <strong>
     目的 IP 地址
    </strong>
    ：IP 包的目的地址。
   </li>
   <li fid="ud527aa7a">
    ​
    <strong>
     子网掩码
    </strong>
    <span class="lake-fontsize-12">
     ：表示目的 IP 地址有多少位是网络位。
    </span>
   </li>
   <li fid="ud527aa7a">
    ​
    <strong>
     网关
    </strong>
    <span class="lake-fontsize-12">
     ：IP 包下一跳的 IP 地址。
    </span>
   </li>
   <li fid="ud527aa7a">
    ​
    <strong>
     网络接口
    </strong>
    <span class="lake-fontsize-12">
     ：IP 包从哪个路由器接口发送出去。
    </span>
   </li>
   <li fid="ud527aa7a">
    <strong>
     度量值
    </strong>
    <span class="lake-fontsize-12">
     ：当有多条到达目的地的不同路径时，度量值越小表示优先级越高。
    </span>
   </li>
  </ol>
  <p>
   五个内容组成一条路由表项。
  </p>
  <h3>
   对于socket编程，accept方法是干什么的，在三次握手中属于第几次？
  </h3>
  <p>
   问过的一些公司：腾讯(2022.05)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   accept函数负责从客户端“连接”的队列中返回一个最近的新连接。
  </p>
  <p>
   accept过程发生在三次握手之后，三次握手完成后，客户端和服务器就建立了tcp连接并可以进行数据交互了。这时可以调用accept函数获得此连接。
  </p>
  <h3>
   网络协议有了解吗？
  </h3>
  <p>
   问过的一些公司：招银网络(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   我们用手机连接上网的时候，会用到许多网络协议。从手机连接 WiFi 开始，使用的是 802.11 （即 WLAN ）协议，通过 WLAN 接入网络；手机自动获取网络配置，使用的是 DHCP 协议，获取配置后手机才能正常通信。这时手机已经连入局域网，可以访问局域网内的设备和资源，但还不能使用互联网应用，例如：微信、抖音等。想要访问互联网，还需要在手机的上联网络设备上实现相关协议，即在无线路由器上配置 NAT、 PPPOE 等功能，再通过运营商提供的互联网线路把局域网接入到互联网中，手机就可以上网玩微信、刷抖音了。
  </p>
  <p>
   简单来说，就是手机、无线路由器等设备通过多种网络协议实现通信。
   <strong>
    网络协议就是为了通信各方能够互相交流而定义的标准或规则，设备只要遵循相同的网络协议就能够实现通信
   </strong>
   <span class="lake-fontsize-12">
    。那网络协议又是谁规定的呢？ ISO 制定了一个国际标准OSI ， 其中的 OSI 参考模型常被用于网络协议的制定。
   </span>
  </p>
  <p>
   <strong>
    常见网络协议：
   </strong>
  </p>
  <p>
   <strong>
    1、TCP/IP协议
   </strong>
  </p>
  <p>
   即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。
  </p>
  <p>
   <strong>
    2、UDP协议
   </strong>
  </p>
  <p>
   UDP（用户数据报协议）是不具有可靠性的协议，它是一种无连接的协议，可靠性功能交给上层的应用去完成。
  </p>
  <p>
   <strong>
    3、HTTP协议
   </strong>
  </p>
  <p>
   HTTP协议是一个超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。
  </p>
  <p>
   <strong>
    4、HTTPS协议
   </strong>
  </p>
  <p>
   从名称上看，HTTPS比HTTP多了一个S，多了secure安全性这个概念。实际上，HTTPS并不是一个新的应用层协议，它是HTTP+TLS/SSL协议组合而成，而安全性的保证就是TLS/SSL所做的工作。也就是说，HTTPS就是身批了一层SSL的HTTP。
  </p>
  <p>
   <strong>
    5、FTP协议
   </strong>
  </p>
  <p>
   文件传输协议，是 TCP/IP 协议组中的协议之一，是一种提供网络之间共享文件的协议，它可以在计算机之间可靠、高效地传送文件。FTP 协议包括两个组成部分，其一为 FTP 服务器，其二为 FTP 客户端。
  </p>
  <p>
   <strong>
    6、ARP协议
   </strong>
  </p>
  <p>
   地址解析协议，是根据目的设备的 IP 地址来查询对应 MAC 地址的协议。
  </p>
  <p>
   <strong>
    7、ICMP协议
   </strong>
  </p>
  <p>
   互联网控制消息协议，ICMP 的主要功能包括，确认 IP 包是否成功送达目的地址，通知发送过程中 IP 包被丢弃的原因。
  </p>
  <h3>
   HTTPS里面的SSL/TLS协议的基本流程是怎样的？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    简洁版：
   </strong>
  </p>
  <p>
   客户端向服务器索要并验证服务器的公钥；双方协商生产「会话秘钥」；双方采用「会话秘钥」进行加密通信。
  </p>
  <p>
   <strong>
    详细版：
   </strong>
  </p>
  <p>
   通信流程图如下：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671608482973-ba94d6cd-3377-43bf-8f9a-85b557d6a5fe.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   在进行通信前，首先会进行HTP的三次握手，握手完成后，再进行TLS的握手过程
  </p>
  <ol list="uf0128234">
   <li fid="u0e03f92e">
    ClientHello：客户端通过向服务器发送hello消息来发起握手过程。这个消息中会夹带着客户端支持的TLS版本号(TL51.0、TL51.2、TLS1.3)、客户端支持的密码套件、以及一串客户端随机数。
   </li>
   <li fid="u0e03f92e">
    ServerHello：在客户端发送hello消息后，服务器会发送一条消息，这条消息包含了服务器的SSL证书、服务器选择的密码套件和服务器生成的随机数。
   </li>
   <li fid="u0e03f92e">
    认证(Authentication)：客户端的证书颁发机构会认证SSL证书，然后发送Certificate报文，报文中包含公开密钥证书。最后服务器发送ServerHelloDone作为hello请求的响应。第一部分握手阶段结束。
   </li>
   <li fid="u0e03f92e">
    加密阶段：在第一个阶段握手完成后，客户端会发送ClientKeyExchange作为响应，这个响应中包含了一种称为The premaster secret的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送ChangeCipherSpec,告诉服务端使用私钥解密这个premaster secret的字符串，然后客户端发送Finished告诉服务端自己发送完成了。
   </li>
   <li fid="u0e03f92e">
    实现了安全的非对称加密：然后，服务器再发送ChangeCipherSpec和Finished告诉客户端解密完成，至此实现了RSA的非对称加密。
   </li>
  </ol>
  <h3>
   SSL协议
  </h3>
  <p>
   可回答：1）介绍下SSL
  </p>
  <p>
   问过的一些公司：字节(2022.08)，字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   SSL (Secure Sockets Layer）安全套接层。是由Netscape公司于1990年开发，用于保障Word Wide Web（WWW）通讯的安全。
   <strong>
    主要任务是提供私密性，信息完整性和身份认证
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   SSL是一个不依赖于平台和运用程序的协议，位于TCP/IP协议与各种应用层协议之间，为数据通信提高安全支持。
  </p>
  <h3>
   SSL套接字的过程？
  </h3>
  <p>
   问过的一些公司：招银网络(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   SSL 的工作主要可以分为三个阶段：握手、密钥导出、数据传输。
  </p>
  <p>
   1、握手阶段
  </p>
  <p>
   在握手阶段需要完成的三个任务分别是：建立一条 TCP 连接、验证服务端身份、分发通信主密钥。大致过程描述如下：
  </p>
  <p>
   客户端首先发起一条到服务端的 TCP 连接，随后的数据传输都是在这条 TCP 连接之上的，在 TCP 链接建立之后，客户端会向服务端发送 HELLO 报文，这个报文中包含了客户端所支持的密码算法列表，服务端在接收后会选用一种对称算法，一种非对称算法和一种 MAC 算法，连同其 证书 回应给客户端（这个证书就是经过权威机构认证的一个实体与其公钥的绑定）。
  </p>
  <p>
   因为在各种的加密过程中，只要是涉及到使用公开密钥的，一般都会有公钥被入侵者盗用和伪造的风险，这时就需要权威机构颁发的数字证书来证明一个公要与实体的绑定。
  </p>
  <p>
   客户端在收到服务端发来的证书之后，就可以明确的知道当前正在跟自己通信的服务端就是目标服务器，客户端随后会从证书中提取服务端发来的公钥，并在客户端生成一个随机的主密钥 MS，然后用服务端的公钥对其进行加密后发送给服务端，服务端会用自己的私钥解密得到主密钥 MS，这样就完成了主密钥的分发。
  </p>
  <p>
   客户端和服务器都掌握了主密钥，有了这个其他人都不知道的主密钥，随后的数据加密和验证过程就好办了。
  </p>
  <p>
   2、密钥导出
  </p>
  <p>
   密钥导出阶段，就是通信双方会以相同的方法，用主密钥生成四个密钥，这四个密钥的分别作用如下：
  </p>
  <p>
   EB：用于从服务端到客户端发送数据的会话加密密钥
  </p>
  <p>
   MB：用于从服务端到客户端发送数据的会话 MAC 密钥
  </p>
  <p>
   EA：用于从客户端到服务端发送数据的会话加密密钥
  </p>
  <p>
   MA：用于从客户端到服务端发送数据的会话 MAC 密钥
  </p>
  <p>
   会话加密密钥就是实际用来加密传输数据的对称密钥，MAC 密钥在是标志传输数据完整性的密钥。
  </p>
  <p>
   MAC：报文鉴别码，是一种用来监测报文完整性的技术。它的过程并不复杂，发送方将明文与一个鉴别密钥进行级联，这个鉴别密钥是通信双方所共有的，随后会计算这个级联后的数据散列值，这个散列值就叫做原始数据的报文鉴别码 MAC，将报文的鉴别码附加在原始明文后面，一同发送给接收方。接收方用收到的明文，级联相同的鉴别密钥，再以相同的方法计算散列值，与收到的散列值 MAC 进行对比，若两者相同，则说明数据未被篡改，上述的 MA 和 MB 就是 MAC 里的鉴别密钥。
  </p>
  <p>
   3、数据传输
  </p>
  <p>
   SSL 将数据流分割成记录，对每个记录 EA 加密，并附加一个 MAC（用于完整性鉴别），然后对该记录与 MAC 进行加密，然后将这个被加密的包发送服务器，服务端收到这个数据包后，用相应的 EB 对称密钥进行解密，再用 MB 进行数据完整性检验。
  </p>
  <h3>
   SSL在历史上有一次心脏流血漏洞，这个漏洞怎么出现的？
  </h3>
  <p>
   问过的一些公司：招银网络(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   早在2014年，互联网安全协议OpenSSL被曝存在一个十分严重的安全漏洞。在黑客社区，它被命名为“心脏出血”，表明网络上出现了“致命内伤”。利用该漏洞，黑客可以获取约30%的https开头网址的用户登录账号密码，其中包括购物、网银、社交、门户等类型的知名网站。今天就为大家带来平台事件规则解读系列第四篇——震惊全球的“心脏出血”漏洞。
  </p>
  <p>
   <strong>
    在OpenSSL1.0.1版本中存在严重漏洞（CVE-2014-0160），此次漏洞问题存在于ssl/dl_both.c文件中。OpenSSL Heartbleed模块存在一个BUG，当攻击者构造一个特殊的数据包，满足用户心跳包中无法提供足够多的数据会导致memcpy把SSLv3记录之后的数据直接输出，该漏洞导致攻击者可以远程读取存在漏洞版本的openssl服务器内存中长大64K的数据。
   </strong>
  </p>
  <p>
   OpenSSL“心脏出血”漏洞是一个非常严重的问题。这个漏洞使攻击者能够从内存中读取多达64 KB的数据。也就是说，只要有这个漏洞的存在，在无需任何特权信息或身份验证的环境下，我们就可以从我们自己的（测试机上）偷来X.509证书的私钥、用户名与密码、聊天工具的消息、电子邮件以及重要的商业文档和通信等数据。
  </p>
  <h3>
   SMTP，FTP了解吗？
  </h3>
  <p>
   问过的一些公司：今日头条(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、SMTP协议
   </strong>
  </p>
  <p>
   提供电子邮件服务的协议叫做 SMTP 。SMTP 用于收发双方的邮件服务器之间，而不是用户代理和邮件服务器之间的通信方式。在实际使用中，发送方用户代理与发送方服务器之间也常采用 SMTP 协议。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671610967011-9c9dc8f0-1573-431e-8b09-b432a1fc25ed.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   SMTP 为了实现高效发送邮件内容，在传输层使用了 TCP 协议，端口号是 25。在一台邮件服务器向另一台邮件服务器发送邮件时，首先向对方的 TCP 25 端口发起一条连接。然后利用这条 TCP 连接发送控制消息和数据。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671611010003-62fcc8be-f615-4850-96da-fcbacf07228c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   尽管 SMTP 协议的逻辑简单，也足以顺利完成邮件的传输工作，但难免存在一些安全缺陷：
  </p>
  <ul list="u5b010831">
   <li fid="u2dd05d95">
    SMTP 传输的邮件是明文的形式，没有提供数据加密机制，可以看到邮件传输的具体内容，用户信息的机密性无法得到保障。
   </li>
   <li fid="u2dd05d95">
    SMTP 没有提供任何认证机制，即使使用了伪造的发件人邮件地址也无法识别，会出现冒名顶替的安全问题。
   </li>
  </ul>
  <p>
   漫天的广告邮件和包含钓鱼链接的垃圾邮件成为日益严重的问题。为了修正 SMTP 出现的问题，IETF 定义了扩展的 SMTP ，即 ESMTP 。ESMTP 提供的扩展功能中包括认证机制和加密机制等。
  </p>
  <p>
   在整个邮件传输的过程中，SMTP/ESMTP 协议定义了邮件服务器之间的消息传输方式。在接收服务器收到电子邮件后，接收方（用户代理）是如何访问邮件则需要其它的协议来处理。
  </p>
  <p>
   <strong>
    2、FTP协议
   </strong>
  </p>
  <p>
   FTP 用于服务器和客户端之间传输文件，是 IP 网络上传输文件的通用协议。FTP 采用客户端和服务器的模式，使用 TCP 协议提供可靠传输。FTP 可以对登录服务器的用户名和密码进行验证，允许客户端指定文件的传输类型，并且可以设置文件的传输权限。
  </p>
  <p>
   FTP 使用两条 TCP 连接实现文件传输。一条是 FTP 控制连接，用来控制管理；另一条是 FTP 数据连接，用于数据传输。FTP 控制连接用于传输 FTP 控制命令和命令执行的应答信息，比如登录用户名和密码的验证、发送文件的名称、发送方式的设置。这条连接在整个 FTP 会话过程中一直保持打开，通过 ASCII 码字符串发送请求和接收应答。在控制连接上无法发送数据，而 FTP 数据连接用于文件和文件列表的传输，仅在需要传输数据时建立数据连接，数据传输完毕后终止。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671611149010-668b5f27-f932-4ef7-be4a-8adb2d51154f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   FTP 控制连接使用的是 TCP 21 号端口，也是 FTP 服务器的侦听端口，等待客户端的连接。在 TCP 21 号端口进行文件 GET（ RETR ）、PUT（STOR ），以及文件表（ LIST ）等操作时，每次都会建立一个用于数据传输的数据连接。数据和文件表的传输正式在这个数据连接上进行的。
  </p>
  <p>
   数据连接的 TCP 连接通常使用端口 20 。也可以使用 PORT 命令修改为其它值。
  </p>
  <p>
   相同的一个文件，不同的操作系统可能有不同的存储方式。为了确保文件能够准确的传送给对方，常用 2 中传输模式：
  </p>
  <ul list="uf7acafd9">
   <li fid="uabf4e5f8">
    ASCII 模式
   </li>
  </ul>
  <ul data-lake-indent="1" list="uf7acafd9">
   <li fid="uabf4e5f8">
    ASCII 模式是默认的文件传输模式。发送方把本地文件转换成标准的 ASCII 码，然后在网络中传输；接收方收到文件后，根据自己的文件存储方式，把它转换成本地文件。ASCII 文件传输模式通常用于传输文本文件。
   </li>
  </ul>
  <ul list="uf7acafd9" start="2">
   <li fid="uabf4e5f8">
    二进制流模式
   </li>
  </ul>
  <ul data-lake-indent="1" list="uf7acafd9">
   <li fid="uabf4e5f8">
    二进制流模式也称为图像文件传输模式。发送方不做任何转换，把文件按照比特流的方式进行传输。二进制文件类型通常用于传送程序文件。
   </li>
  </ul>
  <p>
   在 FTP 数据连接过程中，有两种数据传输方式：主动方式和被动方式。FTP 主动传输方式，也称为 PORT 方式。采用主动方式建立数据连接时，FTP 客户端会通过 FTP 控制连接向 FTP 服务器发送 PORT 命令，PORT命令携带参数：A1 、A2 、A3 、A4 、P1 、P2 ，其中 A1 、A2 、A3、A4 表示需要建立数据连接的主机 IP 地址，而 P1 和 P2 表示客户端用于传输数据的临时端口号，临时端口号的数值为 256*P1+P2 。当需要传输数据时，服务器通过 TCP 端口号 20 与客户端提供的临时端口建立数据传输通道，完成数据传输。在整个过程中，由于服务器在建立数据连接时主动发起连接，因此被称为主动模式。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671611271267-3c05d541-b271-4b8d-b90d-7f6c827a4b46.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如果客户端在防火墙内部，主动方式可能会有问题，因为客户端的端口号是随机的，防火墙并不知道。默认安全策略，防火墙只会允许外部主机访问部分内部已知端口，阻断对内部随机端口的访问，从而无法建立 FTP 数据连接。这时，就需要使用 FTP 被动方式来进行文件传输。
  </p>
  <p>
   被动方式也被称为 PASV 方式。FTP 控制通道建立后，希望通过被动方式建立数据传输通道的 FTP 客户端会利用控制通道向 FTP 服务器发送 PASV 命令，告诉服务器进入被动方式传输。服务器选择临时端口号并告知客户端，命令参数和主动传输方式一致。当需要传输数据时，客户端主动与服务器的临时端口建立数据传输通道，并完成数据传输。在整个过程中，服务器是被动接收客户端的数据连接，所以被称为被动模式。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671611423650-fbbddc03-eb86-4e26-81ce-1c105251965e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   采用被动方式时，两个连接都由客户端发起。一般防火墙不会限制内部的客户端发起的连接，这样就解决了主动方式下的问题。
  </p>
  <h3>
   ping内部流程
  </h3>
  <p>
   可回答：1）ping一个IP地址的时候，内部会发生什么事情？
  </p>
  <p>
   问过的一些公司：蔚来数字化业务(2022.08)，百度(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ping 是 ICMP 最著名的一个应用，通过 ping 可以测试网络的可达性，即网络上的报文能否成功到达目的地。使用 ping 命令时，源设备向目的设备发送 Echo request 消息，目的地址是目的设备的 IP 地址。目的设备收到 Echo request 消息后，向源设备回应一个 Echo reply 消息，可知目的设备是可达的。也可以通过 ping 命令来判断目标主机是否启用。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671612197750-73d661ab-7a06-4a71-900e-f6ba0b11d2a2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如果中间某个路由器没有到达目的网络的路由，便会向源设备回应一个 Destination Unreachable 消息，告知目的设备不可达。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671612236714-4197231d-f9cf-4f4d-8a9b-fcf12ce7f3bd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如果源主机在一定时间内无法收到回应报文，就认为目的设备不可达，并显示超时。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671612261582-a3087fcb-4c4b-43e3-b12b-1d074593ccb2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_11%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   需要注意的是 ping 过程是双向的消息通信，只有双向都成功传输时，才能说明通信是正常的。另外主机也可能因为防火墙拦截，导致 ping 不通。
  </p>
  <h3>
   ping用的是什么协议？
  </h3>
  <p>
   问过的一些公司：Boss直聘北京(2022.10)，多益(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ICMP协议
  </p>
  <h3>
   当我们ping的时候发送的是什么包？
  </h3>
  <p>
   问过的一些公司：字节(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ICMP应答报文
  </p>
  <p>
   ping命令使用的是ICMP协议，它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。 ping位于用户层，一般用来测试一台主机是否可达，该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。
  </p>
  <h3>
   ping一下返回的那些值是什么意思？
  </h3>
  <p>
   问过的一些公司：趋势科技(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ping一个网址或ip，如图：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671625158957-cfb88028-efce-493d-a442-30b17adf10c9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   字节=32：数据包的大小。
  </p>
  <p>
   时间=21ms：返回时间，或者说延迟。
  </p>
  <p>
   TTL=56：数据包的生存时间，得到的这个是剩余的生存时间。TTL用来计算数据包在路由器的消耗时间，因为现在绝大多数路由器的消耗时间都小于1s，而时间小于1s就当1s计算，所以数据包没经过一个路由器节点TTL都减一。
  </p>
  <p>
   那么TTL的值一开始是什么呢？不同的操作系统默认下TTL是不同的。默认情况下，Linux系统的TTL值为64或255，Windows NT/2000/XP系统的TTL值为128，Windows 98系统的TTL值为32，UNIX主机的TTL值为255。
  </p>
  <p>
   上图看到Ping百度服务器返回的数据包的TTL值为56（一般都是找2^n且离返回值最近的那个值），那么途中则经过了64-56=8个路由器。
  </p>
  <p>
   再比如，ping本机ip，结果如下图：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671625247366-99b4bf95-0973-4b51-8e88-e68a768165e8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   可以看到我得到的时候TTL为64，那么途中则经过了64-64=0个路由器，也就是我自己给自己发送数据包不需要经过任何路由器，所以TTL值为64，即是说我的数据包生存时间为64。
  </p>
  <h3>
   session和cookie区别，解决了协议的什么问题？
  </h3>
  <p>
   可回答：1）socket和session的关系
  </p>
  <p>
   问过的一些公司：阿里巴巴杭州淘系(2022.08)，美团(2022.08)，字节(2021.08)(2021.09)，飞猪(2021.09)，美团(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、什么是Cookie？
   </strong>
  </p>
  <p>
   Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。
  </p>
  <p>
   当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。
  </p>
  <p>
   服务器还可以根据需要修改Cookie的内容。
  </p>
  <blockquote>
   <p>
    如果没有设置Cookie失效日期，它们仅保存到关闭浏览器程序为止。
   </p>
   <p>
    如果将Cookie对象的Expires属性设置为Minvalue，则表示Cookie永远不会过期。
   </p>
   <p>
    Cookie存储的数据量很受限制，大多数浏览器支持最大容量为4K，因此不要用来保存数据集及其他大量数据。
   </p>
   <p>
    由于并非所有的浏览器都支持Cookie，并且数据信息是以明文文本的形式保存在客户端的计算机中，因此最好不要保存敏感的，未加密的数据，否则会影响网站的安全性。
   </p>
  </blockquote>
  <p>
   <strong>
    Cookie工作原理
   </strong>
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684653673107-be68360e-045f-49d6-aee4-f89d59e7795b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ol list="ua84db213">
   <li fid="u71761c07">
    浏览器端第一次发送请求到服务器端
   </li>
   <li fid="u71761c07">
    服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端
   </li>
   <li fid="u71761c07">
    浏览器端再次访问服务器端时会携带服务器端创建的Cookie
   </li>
   <li fid="u71761c07">
    服务器端通过Cookie中携带的数据区分不同的用户
   </li>
  </ol>
  <p>
   <strong>
    2、什么是Session？
   </strong>
  </p>
  <p>
   Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。
  </p>
  <p>
   每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。
  </p>
  <p>
   <strong>
    Session的工作原理
   </strong>
  </p>
  <ol list="uf62a9857">
   <li fid="u0d79b6d5">
    浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端
   </li>
   <li fid="u0d79b6d5">
    浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
   </li>
   <li fid="u0d79b6d5">
    服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。
   </li>
  </ol>
  <ol data-lake-indent="1" list="uf62a9857">
   <li fid="u0d79b6d5">
    name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookie
   </li>
   <li fid="u0d79b6d5">
    name为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象
   </li>
   <li fid="u0d79b6d5">
    value为SessionId不存在**（Session对象默认存活30分钟）**，返回1中重新去创建Session与特殊的Cookie
   </li>
   <li fid="u0d79b6d5">
    value为SessionId存在，返回session对象
   </li>
  </ol>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684653791625-eafda251-4930-42a7-989f-150d2803a5ad.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671631458976-a3ecd16f-8401-423f-8884-86a692bda2ed.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    3、Session和Cookie的区别？
   </strong>
  </p>
  <ol list="ud49c0b2e">
   <li fid="u6f2ed971">
    数据存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。
   </li>
   <li fid="u6f2ed971">
    安全性：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
   </li>
   <li fid="u6f2ed971">
    服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
   </li>
   <li fid="u6f2ed971">
    数据大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
   </li>
   <li fid="u6f2ed971">
    信息重要程度：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。
   </li>
  </ol>
  <p>
   <strong>
    4、
   </strong>
   <strong>
    Session和Cookie的联系
   </strong>
  </p>
  <ol list="u39797ad7">
   <li fid="uda832984">
    session是通过cookie来工作的。
   </li>
   <li fid="uda832984">
    session和cookie之间是通过$_COOKIE[‘PHPSESSID’]来联系的。
   </li>
   <li fid="uda832984">
    通过$_COOKIE[‘PHPSESSID’]可以知道session的id，从而获取到其他的信息。
   </li>
  </ol>
  <p>
   Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。为了更多的理解上面那句话的作用，举一个课程实验的例子，当某个用户访问一个购物网站，将一本《xxx》的图书放到购物车，购物车的实现方式是使用map集合，再将其放入session对象中，sessionid信息又会存在于Cookie中，当某个用户再次访问服务器时，浏览器会带上Cookie对象放在请求头发送给服务器，服务器就可以取出Cookie中的sessionid，后拿到该用户对应的购物车对象，对其进行操作，达到用户购物车数据的存储。
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684654036146-a5d1c49c-e47a-4aa8-b253-821d90228492.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   分布式Session如何实现？
  </h3>
  <p>
   问过的一些公司：美团(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <ol list="u3f51c4ff">
   <li fid="ua51dc795">
    基于数据库的Session共享
   </li>
   <li fid="ua51dc795">
    基于NFS共享文件系统
   </li>
   <li fid="ua51dc795">
    基于memcached 的session，如何保证 memcached 本身的高可用性
   </li>
   <li fid="ua51dc795">
    基于resin/tomcat web容器本身的session复制机制
   </li>
   <li fid="ua51dc795">
    基于TT/Redis 或 jbosscache 进行 session 共享
   </li>
   <li fid="ua51dc795">
    基于cookie 进行session共享
   </li>
  </ol>
  <h3>
   网络IO模型有几种，分别是什么？
  </h3>
  <p>
   可回答：1）讲讲IO多路复用？2）说一下网络IO模型
  </p>
  <p>
   问过的一些公司：腾讯(2022.08)，快手(2022.08)，蔚来数字化业务(2022.08)，字节(2021.09)，绿盟科技(2021.09)，知乎(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   阻塞
   <span class="lake-fontsize-12">
    式
   </span>
   <span class="lake-fontsize-12">
    IO、非阻塞
   </span>
   <span class="lake-fontsize-12">
    式
   </span>
   <span class="lake-fontsize-12">
    IO、IO多路复用、信号IO、异步IO
   </span>
  </p>
  <p>
   <strong>
    1、
   </strong>
   <strong>
    阻塞式IO
   </strong>
  </p>
  <p>
   使用系统调用，并一直阻塞直到内核将数据准备好，之后再由内核缓冲区复制到用户态，在等待内核准备的这段时间什么也干不了
  </p>
  <p>
   下图函数调用期间，一直被阻塞，直到数据准备好且从内核复制到用户程序才返回，这种IO模型为阻塞式IO
  </p>
  <p>
   阻塞式IO式最流行的IO模型
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671633726882-1b8c0134-296d-4642-ba0c-98fe00d07477.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    2、非阻塞式IO
   </strong>
  </p>
  <p>
   内核在没有准备好数据的时候会返回错误码，而调用程序不会休眠，而是不断轮询询问内核数据是否准备好
  </p>
  <p>
   下图函数调用时，如果数据没有准备好，不像阻塞式IO那样一直被阻塞，而是返回一个错误码。数据准备好时，函数成功返回。
  </p>
  <p>
   应用程序对这样一个非阻塞描述符循环调用成为轮询。
  </p>
  <p>
   非阻塞式IO的轮询会耗费大量cpu，通常在专门提供某一功能的系统中才会使用。通过为套接字的描述符属性设置非阻塞式，可使用该功能
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671633732906-ad820a19-dd47-4c52-a13c-e2a5bde42206.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    3、IO多路复用
   </strong>
  </p>
  <p>
   类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态
  </p>
  <p>
   下图中select这个系统调用，充当代理类的角色，不断轮询注册到它这里的所有需要IO的文件描述符，有结果时，把结果告诉被代理的recvfrom函数，它本尊再亲自出马去拿数据
  </p>
  <p>
   IO多路复用至少有两次系统调用，如果只有一个代理对象，性能上是不如前面的IO模型的，但是由于它可以同时监听很多套接字，所以性能比前两者高
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671633741857-5a34e87b-b25a-473d-bfb9-426bb6591ad0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   多路复用包括：
  </p>
  <ul list="u59a419df">
   <li fid="ued640cc1">
    select：线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）
   </li>
   <li fid="ued640cc1">
    poll：同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作
   </li>
   <li fid="ued640cc1">
    epoll：用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。最后，epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销
   </li>
  </ul>
  <p>
   <strong>
    4、信号驱动式IO
   </strong>
  </p>
  <p>
   使用信号，内核在数据准备就绪时通过信号来进行通知
  </p>
  <p>
   首先开启信号驱动io套接字，并使用sigaction系统调用来安装信号处理程序，内核直接返回，不会阻塞用户态
  </p>
  <p>
   数据准备好时，内核会发送SIGIO信号，收到信号后开始进行io操作
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671633904708-f8e99bd5-7928-49ec-aeec-81014399c124.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    5、异步IO
   </strong>
  </p>
  <p>
   异步IO依赖信号处理程序来进行通知
  </p>
  <p>
   不过异步IO与前面IO模型不同的是：前面的都是数据准备阶段的阻塞与非阻塞，异步IO模型通知的是IO操作已经完成，而不是数据准备完成
  </p>
  <p>
   异步IO才是真正的非阻塞，主进程只负责做自己的事情，等IO操作完成(数据成功从内核缓存区复制到应用程序缓冲区)时通过回调函数对数据进行处理
  </p>
  <p>
   unix中异步io函数以aio_或lio_打头
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671633923371-e8aac6ac-4c4d-433c-ad62-8a61eff817f3.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    6、各种IO模型对比
   </strong>
  </p>
  <p>
   前面四种IO模型的主要区别在第一阶段，他们第二阶段是一样的：数据从内核缓冲区复制到调用者缓冲区期间都被阻塞住！
  </p>
  <p>
   前面四种IO都是同步IO：IO操作导致请求进程阻塞，直到IO操作完成
  </p>
  <p>
   异步IO：IO操作不导致请求进程阻塞
  </p>
  <p>
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671633954978-50c6d275-d287-4a30-aff1-a57bff6358da.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   IO多路复用实现方式有哪些？
  </h3>
  <p>
   问过的一些公司：百度(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   IO 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄。一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出 cpu。IO 是指网络 IO，多路指多个TCP连接(即 socket 或者 channel)，复用指复用一个或几个线程。
  </p>
  <p>
   意思说一个或一组线程处理多个 TCP 连接。最大优势是减少系统开销小，不必创建过多的进程/线程，也不必维护这些进程/线程。
   <strong>
    IO 多路复用的三种实现方式：select、poll、epoll
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   <strong>
    1、select 机制
   </strong>
  </p>
  <p>
   基本原理：
  </p>
  <p>
   客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和 exceptfds(异常)。select 会阻塞住监视 3 类文件描述符，等有数据、可读、可写、出异常或超时就会返回；返回后通过遍历 fdset 整个数组来找到就绪的描述符 fd，然后进行对应的 IO 操作。
  </p>
  <p>
   优点：
  </p>
  <ul list="uee9d0b92">
   <li fid="u36ad343d">
    几乎在所有的平台上支持，跨平台支持性好
   </li>
  </ul>
  <p>
   缺点：
  </p>
  <ul list="ue722565d">
   <li fid="u66f0560a">
    由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
   </li>
   <li fid="u66f0560a">
    每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)。
   </li>
   <li fid="u66f0560a">
    单个进程打开的 FD 是有限制(通过FD_SETSIZE设置)的，默认是 1024 个，可修改宏定义，但是效率仍然慢。
   </li>
  </ul>
  <p>
   <strong>
    2、poll 机制
   </strong>
  </p>
  <p>
   基本原理与 select 一致，也是轮询+遍历。唯一的区别就是 poll 没有最大文件描述符限制(使用链表的方式存储 fd)。
  </p>
  <p>
   poll 缺点：
  </p>
  <ul list="u542f9c8a">
   <li fid="u32ab2d35">
    由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
   </li>
   <li fid="u32ab2d35">
    每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)。
   </li>
  </ul>
  <p>
   <strong>
    3、epoll 机制
   </strong>
  </p>
  <p>
   基本原理：
  </p>
  <p>
   没有 fd 个数限制，用户态拷贝到内核态只需要一次，使用时间通知机制来触发。通过 epoll_ctl 注册 fd，一旦 fd 就绪就会通过 callback 回调机制来激活对应 fd，进行相关的 io 操作。epoll 之所以高性能是得益于它的三个函数：
  </p>
  <ul list="u85106733">
   <li fid="u01c2e4b2">
    epoll_create() 系统启动时，在 Linux 内核里面申请一个B+树结构文件系统，返回 epoll 对象，也是一个 fd。
   </li>
   <li fid="u01c2e4b2">
    epoll_ctl() 每新建一个连接，都通过该函数操作 epoll 对象，在这个对象里面修改添加删除对应的链接 fd，绑定一个 callback 函数
   </li>
   <li fid="u01c2e4b2">
    epoll_wait() 轮训所有的 callback 集合，并完成对应的 IO 操作
   </li>
  </ul>
  <p>
   优点：
  </p>
  <ul list="u3d9b43c4">
   <li fid="ua2c183e3">
    没 fd 这个限制，所支持的 FD 上限是操作系统的最大文件句柄数，1G 内存大概支持 10 万个句柄。效率提高，使用回调通知而不是轮询的方式，不会随着 FD 数目的增加效率下降。内核和用户空间 mmap 同一块内存实现(mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)
   </li>
  </ul>
  <p>
   epoll缺点：
  </p>
  <ul list="u16af9478">
   <li fid="u6c8468ce">
    epoll 只能工作在linux下
   </li>
  </ul>
  <p>
   epoll 应用：redis、nginx
  </p>
  <p>
   <strong>
    epoll 水平触发(LT)与边缘触发(ET)的区别
   </strong>
  </p>
  <p>
   epoll 有 epoll LT 和 epoll ET 两种触发模式，LT 是默认的模式，ET 是“高速”模式。
  </p>
  <p>
   LT 模式下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作。
  </p>
  <p>
   ET 模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论 fd 中是否还有数据可读。所以在 ET 模式下，read 一个 fd 的时候一定要把它的 buffer 读完，或者遇到 EAGAIN 错误。
  </p>
  <p>
   <strong>
    4、select/poll/epoll 之间的区别
   </strong>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671634292483-899207aa-3d65-4f98-aa3b-bef10ac4246d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    5、为什么有 IO 多路复用机制
   </strong>
  </p>
  <p>
   没有 IO 多路复用机制时，有 BIO、NIO 两种实现方式，但有一些问题。
  </p>
  <p>
   1）同步阻塞(BIO)
  </p>
  <p>
   服务端采用单线程，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求(必须等上一个请求 recv 或 send 完)，无法处理并发。
  </p>
  <p>
   服务器端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000 个线程真正发生读写事件的线程数不会超过 20%，每次 accept 都开一个线程也是一种资源浪费。
  </p>
  <p>
   2）同步非阻塞(NIO)
  </p>
  <p>
   服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv(非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd(包括没有发生读写事件的fd)会很浪费 cpu。
  </p>
  <p>
   3）IO 多路复用
  </p>
  <p>
   服务器端采用单线程通过 select/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send，使其能支持更多的并发连接请求。
  </p>
  <p>
   <strong>
    6、示例
   </strong>
  </p>
  <p>
   100 万个连接，里面有 1 万个连接是活跃，可以对比 select、poll、epoll 的性能表现：
  </p>
  <ul list="ud7136d46">
   <li fid="u53807c84">
    select：不修改宏定义默认是 1024，则需要100w/1024=977个进程才可以支持 100 万连接，会使得 CPU 性能特别的差。
   </li>
   <li fid="u53807c84">
    poll：没有最大文件描述符限制，100 万个链接则需要 100 万个 fd，遍历都响应不过来了，还有空间的拷贝消耗大量的资源。
   </li>
   <li fid="u53807c84">
    epoll：请求进来时就创建 fd 并绑定一个 callback，只需要遍历 1 万个活跃连接的 callback 即可，既高效又不用内存拷贝。
   </li>
  </ul>
  <h3>
   介绍一下多路复用的流程是怎么样的？
  </h3>
  <p>
   问过的一些公司：蔚来数字化业务(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    IO 多路复用有三种实现方式：select、poll、epoll
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   1、select
  </p>
  <ol list="ub71e2f14">
   <li fid="u89a78902">
    应用程序首先发起 select 系统调用，传入要监听的文件描述符集合
   </li>
   <li fid="u89a78902">
    内核遍历应用程序传入的 fd 集合，如果遍历完一遍后发现没有就绪的 fd 则用户进程会进入阻塞状态，如果有就绪的 fd 则会对就绪的 fd 打标，然后返回
   </li>
   <li fid="u89a78902">
    应用程序遍历 fd 集合，找到就绪的 fd，进行相应的事件处理
   </li>
  </ol>
  <p>
   2、poll
  </p>
  <p>
   基本同 select
  </p>
  <p>
   3、epoll
  </p>
  <ol list="u54e3e8b4">
   <li fid="u6bfed915">
    应用程序调用 epoll_create，内核会分配一块内存空间，创建一个 epoll，最后将 epoll 的 fd 返回，我们后续可以通过这个 fd 来操作 epoll 对象
   </li>
   <li fid="u6bfed915">
    应用程序不断调用 epoll_ctl 将我们要监听的 fd 维护到 epoll，内核通过红黑树的结构来高效的维护我们传入的 fd 集合
   </li>
   <li fid="u6bfed915">
    应用程序调用 epoll_wait 来获取就绪事件，内核检查 epoll 的就绪列表，如果就绪列表为空则会进入阻塞，否则直接返回就绪的事件。
   </li>
   <li fid="u6bfed915">
    应用程序根据内核返回的就绪事件，进行相应的事件处理
   </li>
  </ol>
  <h3>
   socket编程的流程
  </h3>
  <p>
   问过的一些公司：字节(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   socket编程的总体流程如下图所示。 服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684656694639-ffc76031-93e2-4992-8c4f-af5d425307a4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   综上可得：
  </p>
  <p>
   服务端：socket—&gt;bind—&gt;listen—&gt;accept—&gt;send/recv—&gt;closesocket
  </p>
  <p>
   客户端：socket—&gt;bind(可选)—&gt;connect—&gt;send/recv----&gt;closesocket
  </p>
  <h3>
   RPC原理，底层？
  </h3>
  <p>
   问过的一些公司：百度(2021.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。
  </p>
  <p>
   为什么要 RPC？因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。
  </p>
  <p>
   RPC 能帮助我们做什么呢？简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。 举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。
  </p>
  <p>
   <strong>
    RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。
   </strong>
  </p>
  <p>
   整个RPC的核心功能看作是下面 6 个部分实现的：
  </p>
  <ul list="ud71c47c6">
   <li fid="ua4984509">
    <strong>
     客户端（服务消费端）
    </strong>
    ：调用远程方法的一端。
   </li>
   <li fid="ua4984509">
    <strong>
     客户端 Stub（桩）
    </strong>
    <span class="lake-fontsize-12">
     ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。
    </span>
   </li>
   <li fid="ua4984509">
    <strong>
     网络传输
    </strong>
    <span class="lake-fontsize-12">
     ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。
    </span>
   </li>
   <li fid="ua4984509">
    <strong>
     服务端 Stub（桩）
    </strong>
    <span class="lake-fontsize-12">
     ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。
    </span>
   </li>
   <li fid="ua4984509">
    <strong>
     服务端（服务提供端）
    </strong>
    <span class="lake-fontsize-12">
     ：提供远程方法的一端。
    </span>
   </li>
  </ul>
  <p>
   <strong>
    具体原理图如下：
   </strong>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12867669/1671713048806-01f16790-26c9-4089-9104-92176c1453ed.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <ul list="uce39c037">
   <li fid="ua2606949">
    服务消费端（client）以本地调用的方式调用远程服务；
   </li>
   <li fid="ua2606949">
    客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：
    <span class="lake-fontsize-12">
     RpcRequest
    </span>
    <span class="lake-fontsize-12">
     ；
    </span>
   </li>
   <li fid="ua2606949">
    客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
   </li>
   <li fid="ua2606949">
    服务端 Stub（桩）收到消息将消息反序列化为Java对象:
    <span class="lake-fontsize-12">
     RpcRequest
    </span>
    <span class="lake-fontsize-12">
     ；
    </span>
   </li>
   <li fid="ua2606949">
    服务端 Stub（桩）根据
    <span class="lake-fontsize-12">
     RpcRequest
    </span>
    <span class="lake-fontsize-12">
     中的类、方法、方法参数等信息调用本地的方法；
    </span>
   </li>
   <li fid="ua2606949">
    服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：
    <span class="lake-fontsize-12">
     RpcResponse
    </span>
    <span class="lake-fontsize-12">
     （序列化）发送至消费方；
    </span>
   </li>
   <li fid="ua2606949">
    客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。
   </li>
  </ul>
  <h3>
   LRU是什么？如何实现？
  </h3>
  <p>
   问过的一些公司：美团(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   LRU（Least Recently Used）是一种常见的缓存淘汰算法，其思想是淘汰最近最少被使用的数据，保留最近被使用的数据。
  </p>
  <p>
   LRU算法的实现可以使用哈希表和双向链表结合的方式。
  </p>
  <p>
   具体实现如下：
  </p>
  <ul list="u167159df">
   <li fid="ue333b450">
    使用哈希表（HashMap）存储缓存中的数据，以键值对的形式存储，其中键为缓存的key，值为双向链表中对应节点的引用。
   </li>
   <li fid="ue333b450">
    使用双向链表存储缓存中的key，链表的头部表示最近访问的数据，链表的尾部表示最近最少使用的数据。每次访问一个缓存数据，将其从链表中删除并插入到链表头部；每次淘汰数据时，将链表尾部的数据删除即可。
   </li>
   <li fid="ue333b450">
    当缓存中的数据达到容量限制时，需要淘汰最近最少使用的数据，即链表尾部的数据。
   </li>
  </ul>
  <h3>
   ARP协议
  </h3>
  <p>
   可回答：1）ARP协议是哪一层的协议？2）ARP协议的概念，ARP的报文格式
  </p>
  <p>
   问过的一些公司：趋势科技(2022.08)，蔚来(2022.08)，字节(2022.07)，华为(2022.05)，知乎(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ARP，地址解析协议，属于网络层协议。
  </p>
  <p>
   该协议是
   <strong>
    根据设备的 IP 地址来查询对应 MAC 地址的协议
   </strong>
   <span class="lake-fontsize-12">
    。主机通过 ARP 查询到 MAC 地址后，将在 ARP 缓存表中增加映射表项，即 IP 地址和 MAC 地址的映射表项。
   </span>
  </p>
  <p>
   <strong>
    ARP 报文格式
   </strong>
   <span class="lake-fontsize-12">
    ：
   </span>
  </p>
  <p>
   ARP 报文分为 ARP 请求报文和 ARP 应答报文，它们的报文格式相同，但是各个字段的取值不同。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671714586598-036eb1a7-500a-47d5-b49b-265c2e733a4f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   ARP 报文中各个字段的含义如下。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671714632430-29df50c0-597f-4f6f-b6df-bbf1009e4b4a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   ARP协议中网关怎么去转换IP地址到对应MAC地址的？
  </h3>
  <p>
   可回答：1）ARP协议原理
  </p>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ARP 是通过 ARP 请求和 ARP 响应报文确定 MAC 地址的
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671716161293-744018e1-b4d1-4db1-8b57-a7ec0c53399a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   假如主机 A 向同一网段上的主机 B 发送数据。主机 A 的 IP 地址为 10.0.0.1 ，主机 B 的 IP 地址为 10.0.0.2 ，主机 C 的 IP 地址为 10.0.0.3 。它们都不知道对方的 MAC 地址。
  </p>
  <p>
   ARP 地址解析过程如下：
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671716202496-8a7a0b04-4cae-40bb-94ed-d123553f179f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   1）主机 A 首先查看自己的 ARP 表（即 ARP 缓存表），确定是否有主机 B 的 IP 地址对应表项。如果有，则直接使用表项中的 MAC 地址进行封装，封装成帧后发送给主机 B 。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671716947801-9ecdac4a-d88d-46a7-8e58-42d74d18cff0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   2）如果主机 A 的 ARP 表没有对应的表项，就发送一个广播帧，源 IP 和源 MAC 地址是主机 A ，目的 IP 地址是主机 B ，目的 MAC 地址是广播 MAC 地址，即 FFFF-FFFF-FFFF 。这就是 ARP 请求报文。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671716997143-dcb72e5a-2ca9-4ad5-9953-d72b9c26bdba.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   3）ARP 请求是广播报文，同一个网段的所有主机都能收到。只有主机 B 发现报文中的目的 IP 地址是自己，于是主机 B 发送响应报文给主机 A ，源 MAC 地址和源 IP 地址是主机 B ，目的 MAC 地址和目的 IP 地址是主机 A ，这个报文就叫
   <strong>
    ARP 响应报文
   </strong>
   <span class="lake-fontsize-12">
    。同时，主机 B 的 ARP 表记录主机 A 的映射关系，即主机 A 的 IP 地址和 MAC 地址的对应关系。
   </span>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671717037503-8faef07d-7f50-40cc-bbc4-4d910e9a4cbb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   4）主机 C 也收到了 ARP 请求报文，但目的 IP 地址不是自己，所以不会进行响应。于是主机 C 添加主机 A 的映射关系到 ARP 表，并丢弃 ARP 请求报文。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671717086670-f65f08e2-51e7-4d0a-969e-99a4f5103610.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   5）主机 A 收到 ARP 响应报文后，添加主机 B 的映射关系，同时用主机 B 的 MAC 地址做为目的地址封装成帧，并发送给主机 B 。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671717110770-9f63051a-dc3f-45e5-9b0d-d5955ac31bc9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   <strong>
    如果每发送一个 IP 报文就要进行一次 ARP 请求，来确定 MAC 地址，那将会造成不必要的网络流量，通常的做法是用 ARP 表记录 IP 地址和 MAC 地址的映射关系。主机发送报文时，首先会查看它的 ARP 表，目的是为了确定是否是已知的设备 MAC 地址。如果有，就直接使用；如果没有，就发起 ARP请求获取。
   </strong>
  </p>
  <h3>
   DHCP协议
  </h3>
  <p>
   问过的一些公司：科大讯飞(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   DHCP（Dynamic Host Configuration Protocol），
   <strong>
    动态主机配置协议，是一个应用层协议
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
   <strong>
    将主机的IP地址设置为动态分配时，DHCP服务器就会根据DHCP将IP地址分配给客户端，使客户端可以通过这个IP地址进行上网的操作
   </strong>
   <span class="lake-fontsize-12">
    。
   </span>
  </p>
  <p>
   DHCP 协议是从 BOOTP 协议发展而来。但 BOOTP 运行在相对静态的环境中，每台设备配置专门的 BOOTP 参数文件，该文件会在相当长的时间内保持不变。DHCP 从以下两方面对 BOOTP 进行了扩展：
  </p>
  <ul list="u4ff63c65">
   <li fid="u0f546fab">
    DHCP 允许设备动态地获取 IP 地址，而不是静态指定每台主机地址。
   </li>
   <li fid="u0f546fab">
    DHCP 能够分配其它的配置参数，客户端仅用一个消息就获取它所需要的所有配置信息。
   </li>
  </ul>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671718606034-60d0a326-ce35-496c-b524-f812a21ad7ba.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   案例：
  </p>
  <p>
   大刘有两台电脑和两台手机，小美有一台笔记本电脑、一台平板电脑和两台手机，老王、阿丽、敏敏也有几台终端设备。如果为每台设备手动配置 IP 地址，那会非常繁琐，一点儿也不方便。特别是手机、笔记本电脑、平板电脑等设备，每移动到一个新的地方，接入不同的网络，都要重新设置 IP 地址，实在是太麻烦了。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671718708475-502fd997-a3db-4cd9-8b79-2c29e58c4c02.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   于是就有了 DHCP 协议，会自动配置设备的网络参数，包括 IP 地址、子网掩码、网关地址、DNS 服务器等，替代手动配置。还能统一 IP 地址分配，方便网络管理。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671718766715-6de0ce44-d37a-4a97-b5d9-48b8efba9b3a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   大刘他们的设备使用 DHCP 功能后，只要连接到网络，就可以进行 TCP/IP 通信。对于路由器和交换机，通常是手动配置 IP 地址等参数。
  </p>
  <p>
   扩展一下，再说一下DHSCP分配机制。
  </p>
  <p>
   DHCP 提供了两种地址分配机制，可以根据网络需求为不同的 Client 选择不同的分配策略。
  </p>
  <ul list="u4aa735a6">
   <li fid="u55f42ca5">
    动态分配机制：通过 DHCP 为 Client 分配一个有使用期限的 IP 地址。如果 Client 没有及时续约，到达使用期限后，这个地址可能会被其它 Cl ent使用。绝大多数 Client 使用的都是这种动态分配的地址。
   </li>
   <li fid="u55f42ca5">
    静态分配机制：通过 DHCP 为特定的 Client 分配固定的 IP 地址。固定 IP 地址可以永久使用， Client 通常是打印机、服务器等设备。
   </li>
  </ul>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671718929236-700051de-996e-451a-81f8-9d9f94714b11.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   在实际情况中，我们发现 DHCP Client 重启后，也能获得相同的 IP 地址。DHCP Ser ver 为 DHCP Client 分配 IP 地址时，采用如下的顺序：
  </p>
  <ol list="ubac136fb">
   <li fid="u11a671bb">
    DHCP Ser ver 中与 DHCP Client 的 MAC 地址静态绑定的 IP 地址；
   </li>
   <li fid="u11a671bb">
    DHCP Client 曾经使用过的 IP 地址；
   </li>
   <li fid="u11a671bb">
    最先找到的可用 IP 地址。
   </li>
  </ol>
  <p>
   如果没找到可用的 IP 地址，就依次查询超过租期、发生冲突的 IP 地址，如果找到就进行分配，否则报错处理。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671719074453-ed6aea56-43cc-4dee-88cb-168115c0aff7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <h3>
   FIN-WAIT-2是什么时候？
  </h3>
  <p>
   问过的一些公司：字节抖音(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   FIN-WAIT-2出现在TCP四次挥手的第二次和第三次之间。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671719398640-c2c3a317-834b-4eb9-bf69-bf0ada71cce4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   FIN-WAIT-1状态的连接收到 ACK 确认包以后进入FIN-WAIT-2状态，这个时候主动关闭方的 FIN 包已经被对方确认，等待被动关闭方发送 FIN 包。
  </p>
  <p>
   再说一下四次挥手：
  </p>
  <p>
   第一次挥手： 主机A向主机B发送FIN=1(标记位FIN表示请求释放链接)，seq=m,随后主机A进入FIN-WAIT-1阶段，即半关闭阶段。停止主机A到主机B方向上发送数据（停止的是正常传输的数据，不是确认报文，确认报文依旧可发），但主机A依旧能接收主机B发送过来的数据，
  </p>
  <p>
   第二次挥手： 主机B收到主机A发过来的结束报文，确认主机A要释放连接，主机B结束ESTABLISHED状态，进入CLOSED-WAIT阶段（半关闭状态），并返回ACK=1(确认收到主机A的释放连接请求)，seq=n,ack=m+1。此时主机A收到主机B发送过来的报文，确认主机B已收到自己的释放请求，结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段
  </p>
  <p>
   第三次挥手： 主机B经过CLOSED-WAIT阶段后，做好了释放准备，再次向主机A发送一段TCP报文，FIN=1，ACK=1，seq=p，ack=m+1。FIN和ACK表示已准备好释放连接，此处ACK并不是确认收到主机B报文的确认报文；随后主机B结束CLOSED-WAIT阶段，进入LASK-ACK阶段，并停止向主机A发送数据，但仍能收到主机A发送过来的数据；
  </p>
  <p>
   第4次挥手： 主机A收到主机B发送过来的报文，确认主机B已做好释放准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向主机B发送ACK=1，seq=m+1，ack=p+1；随后主机A在TIME-WAIT阶段等待2MSL。等待完2MSL之后主机A结束TIME-WAIT阶段，进入CLOSED阶段，由此完成四次挥手。
  </p>
  <h3>
   host作用
  </h3>
  <p>
   问过的一些公司：奇安信(2021.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    加快域名解析
   </strong>
   <span class="lake-fontsize-12">
    ：对于经常访问的网站，咱们可以通过
   </span>
   <strong>
    在hosts文件中配置域名和 IP 的映射关系，提高域名的解析速度
   </strong>
   <span class="lake-fontsize-12">
    。由于有了映射关系，当咱们输入域名后，计算机就能够快速解析出 IP 地址，而不用请求网络上的 DNS 服务器。
   </span>
  </p>
  <p>
   <strong>
    构建映射关系
   </strong>
   <span class="lake-fontsize-12">
    ：在很多单位中，都会有自己局域网，而且还会有不同的服务器提供给公司的成员使用。但由于局域网中一般很少架设 DNS 服务器，因此在访问这些服务器时，就需要输入难记的 IP 地址，这对大家来说相当麻烦。因此，咱们可以分别
   </span>
   <strong>
    给这些服务器取个容易记住的名字，然后在hosts文件中建立 IP 映射，这样在以后访问的时候，只要输入这个服务器的名字就可以了
   </strong>
   <span class="lake-fontsize-12">
    ！
   </span>
  </p>
  <p>
   <strong>
    屏蔽垃圾网站
   </strong>
   <span class="lake-fontsize-12">
    ：现在有很多网站，在不经过咱们同意的时候，就将各种各样的插件安装到咱们的计算机中，其中不乏病毒和木马。对于这些网站，咱们就可以
   </span>
   <strong>
    利用hosts文件把这些网站的域名映射到一个错误的 IP 或本地计算机的 IP 地址上，这样就可以达到禁止访问的目的。
   </strong>
  </p>
  <h3>
   用过抓包工具吗？
  </h3>
  <p>
   问过的一些公司：奇安信(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   常用抓包工具如下：
  </p>
  <p>
   1、Wireshark抓包工具很强大，可以捕捉网络中的数据，并为用户提供关于网络和上层协议的各种信息。但是如果只是抓取http和https的话，还是用fiddler和Charles比较简洁一点。
  </p>
  <p>
   2、Charles抓包工具也是比较常用的，和fiddler差不多，请求接口和返回数据的显示方式不一样，Charles是树状结构比较清晰，fiddler是按照时间倒叙排的。
  </p>
  <p>
   3、Firebug抓包工具是浏览器firefox浏览器自带插件，支持很多种浏览器，直接按f12,就可以打开，用起来比较方便。
  </p>
  <p>
   4、httpwatch抓包工具是强大的网页数据分析工具，安装简单，不需要设置代理和证书，但只能看不能修改，，集成在Internet Explorer工具栏。
  </p>
  <p>
   5、fiddler抓包工具，是客户端和服务端的http代理，客户端所有的请求都要先经过fiddler，到响应的服务端，然后端返回的所有数据也都要经过fiddler，fiddler也是最常用的抓包工具之一。
  </p>
  <p>
   6、SmartSniff抓包工具是一款方便小巧的 TCP/IP 数据包捕获软件，网络监视实用程序。
  </p>
  <h3>
   IP地址怎么找到物理机？
  </h3>
  <p>
   问过的一些公司：好未来(2022.09)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   IP地址并不能直接用于找到物理机器，因为IP地址是逻辑地址，而物理机器是通过MAC地址来确定的。
  </p>
  <p>
   在局域网中，ARP协议可以将IP地址转换为MAC地址。当计算机需要将数据包发送到另一台计算机时，它会首先检查本地ARP缓存，如果该IP地址的MAC地址已经存在于缓存中，则直接将数据包发送到该MAC地址。如果不存在，则会向网络广播ARP请求，并等待目标计算机的响应。
  </p>
  <p>
   在广域网中，如果需要将IP地址转换为物理地址，则需要使用ARP的一种变体，称为RARP（Reverse Address Resolution Protocol），或者通过DHCP服务器来获取IP地址和对应的MAC地址。
  </p>
  <p>
   综上，IP地址与物理机之间的对应关系需要通过特定的协议（如ARP、RARP或DHCP）来实现。
  </p>
  <h3>
   如果数据包不在当前子网内，怎么传输到目标子网网关的？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   首先，如何判断这个数据包的目标 IP 地址和当前主机的 IP 地址是否在同一子网（网段）内？
  </p>
  <p>
   利用子网掩码可以判断两台主机是否中同一子网中。若两台主机的 IP 地址分别与它们的子网掩码相 “与” 后的结果相同，则说明这两台主机在同一子网中。
  </p>
  <p>
   其次，网关到底是什么呢？
  </p>
  <p>
   网关实质上是一个网络通向其他网络的 IP 地址（一般都是路由器的 IP 地址）。而默认网关（Default Gateway）就是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。
  </p>
  <p>
   当一台计算机发送数据时，根据数据包中的目标 IP 地址，通过子网掩码来判定目标主机是否在本地子网中，如果目标主机在本地子网中，则（通过二层设备 - 交换机）直接发送即可。如果目标不在本地子网中则将该信息送到缺省网关/路由器，由路由器将其转发到其他网络中，进一步寻找目标主机。
  </p>
  <h3>
   服务器A向B发包，如果遇到网络阻塞都会发生什么？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   如果服务器A向B发包时遇到了网络阻塞，可能会发生以下情况：
  </p>
  <ul list="uf499c786">
   <li fid="u930500ad">
    数据包丢失：由于网络阻塞导致数据包在传输过程中丢失，此时需要等待超时重传或使用快速重传等协议机制。
   </li>
   <li fid="u930500ad">
    延迟增加：由于网络阻塞导致数据包的传输延迟增加，此时需要使用拥塞控制机制来控制数据包的发送速率，避免网络拥塞进一步加剧。
   </li>
   <li fid="u930500ad">
    乱序传输：由于网络阻塞导致数据包的传输顺序被打乱，此时需要使用序号来重新排序数据包。
   </li>
   <li fid="u930500ad">
    重复数据包：由于网络阻塞导致数据包被重复传输，此时需要使用序号和确认机制来避免重复数据包的产生。
   </li>
  </ul>
  <h3>
   unicode和ascii的区别？
  </h3>
  <p>
   问过的一些公司：字节(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   1、ASCII编码是1个字节，而Unicode编码通常是2个字节。
  </p>
  <p>
   2、ASCII是单字节编码，无法用来表示中文；而Unicode可以表示所有语言。
  </p>
  <p>
   3、用Unicode编码比ASCII编码需要多一倍的存储空间。
  </p>
  <h3>
   MAC地址在传输过程中会改变吗？
  </h3>
  <p>
   问过的一些公司：字节(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   MAC
   <span class="lake-fontsize-12">
    地址在同一个广播域传输过程中是不变的，在跨越广播域的时候会发生改变的。
   </span>
  </p>
  <h3>
   CSMA/CD协议作用于哪一层？如何工作的？如何降低碰撞几率的？
  </h3>
  <p>
   问过的一些公司：字节(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   CSMA/CD ，全称 Carrier Sense Multiple Access with Collision Detection ，即载波侦听多路访问/冲突检测协议，以太网用 CSMA/CD 进行传输控制。该协议作用于数据链路层。
  </p>
  <p>
   载波侦听（ Carrier Sense ），是指网络中的各个设备在发送数据前，都要确认确认线路上有没有数据传输。如果有数据传输，就不发送数据；如果没有数据传输，马上发送数据。
  </p>
  <p>
   多路访问（ Multiple Access ），是指网络上所有设备收发数据，共同使用同一条线路，而且发送的数据是广播型。
  </p>
  <p>
   冲突检测（ Col l i s ion Detection ），是指设备在发送数据帧的同时，还必须监听线路情况，判断是否发生冲突。也就是说，同一时刻，有没有其它设备也在发送数据帧。
  </p>
  <p>
   以太网的冲突域是指数据发送时，检测出冲突，当发生冲突时等待一段随机时间再次发送。
  </p>
  <p>
   <strong>
    CSMA/CD的基本工作过程：
   </strong>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671723219147-2dcaad34-1b4a-404b-851f-5823a2efa337.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如图是一个10BASE5以太网，每个主机都是用同一根同轴电缆来与其它主机进行通信，因此，这里的同轴电缆又被称为共享介质，相应的网络被称为共享介质网络，或简称为共享式网络。共享式网络中，不同的主机同时发送数据时，就会产生信号冲突的问题，解决这一问题的方法一般是采用载波侦听多路访问/冲突检测技术 （Carrier Sense MultipleAccess/Collision Detection）。
  </p>
  <p>
   CSMA/CD的基本工作过程如下：
  </p>
  <ol list="u7c95c596">
   <li fid="uf5ee59fa">
    终端设备不停地检测共享线路的状态。如果线路空闲，则可以发送数据；如果线路不空闲，则等待一段时间后继续检测（延时时间由退避算法决）。
   </li>
   <li fid="uf5ee59fa">
    如果有另外一个设备同时发送数据，两个设备发送的数据会产生冲突。
   </li>
   <li fid="uf5ee59fa">
    终端设备检测到冲突之后，会马上停止发送自己的数据，并发送特殊阻塞信息，以强化冲突信号，使线路上其他站点能够尽早检测到冲突。
   </li>
   <li fid="uf5ee59fa">
    终端设备检测到冲突后，等待一段时间之后再进行数据发送（延时时间由退避算法决定）。CSMA/CD的工作原理可简单总结为：先听后发，边发边听，冲突停发，随机延迟后重发。
   </li>
  </ol>
  <p>
   <strong>
    主机在发送数据之前，先监听信道上是否有别的站发送的载波信号。若有，说明信道忙；否则信道是空闲的。即使信道空闲，若立即发送仍然会发生冲突。所以需要监听算法把冲突减到最小。
   </strong>
  </p>
  <p>
   有以下3种监听算法：
  </p>
  <p>
   1）非坚持型监听算法：当一个站准备好帧，在发送之前先监听信道。
  </p>
  <p>
   （1）若信道空闲，立即发送，否则转（2）
  </p>
  <p>
   （2）若信道忙，则后退一个随机时间，重复(1)
  </p>
  <p>
   由于随机时延后退，从而减少了冲突的概率。然而，可能会因为后退而使信道闲置一段时间，这使信道利用率降低，而且增加了发送时延。
  </p>
  <p>
   2）I-坚持型监听算法：当一个站准备好帧，发送之前先监听信道。
  </p>
  <p>
   （1）若信道空闲，立即发送，否则转（2）
  </p>
  <p>
   （2）若信道忙，继续监听，直到信道空闲后立即发送。
  </p>
  <p>
   这种算法的优缺点与前一种正好相反：有利于抢占信道，减少信道空闲时间。但是，多个站同时都在监听信道时必然发生冲突。
  </p>
  <p>
   3）P-坚持型监听算法。这种算法汲取了上述两种算法的优点，但较为复杂：
  </p>
  <p>
   （1）若信道空闲，以概率P发送，以概率（I-P）延迟一个时间单位。一个时间单位等于网络传输时延。
  </p>
  <p>
   （2）若信道忙，继续监听直到信道空闲，转（1)。
  </p>
  <p>
   （3）如果发送延迟一个单位t，则重复（1）。
  </p>
  <p>
   4）发送站采取边发送边听的冲突检测方法
  </p>
  <p>
   载波监听只能减少冲突的概率，不能完全避免冲突。当两个帧发生冲突后，若继续发送，将浪费网络带宽。为了进一步改进带宽的利用率，发送站应采取边发送边听的冲突检测方法，即：
  </p>
  <p>
   （1）发送期间同时接收，并把接收的数据与站中存储的数据进行比较。（或用其他办法检测冲突）
  </p>
  <p>
   （2）若比较结果一致，说明没有冲突，重复（1）。
  </p>
  <p>
   （3）若比较结果不一致，说明发生了冲突，立即停止发送，并发送一个简短的阻塞信号（Jamming），使所有站都停止发送。
  </p>
  <p>
   （4）发送Jamming信号后，等待一段时间重新监听，再试图发送。
  </p>
  <h3>
   如何获取本机IP地址？
  </h3>
  <p>
   问过的一些公司：趋势科技(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   第一种方法：
  </p>
  <p>
   按win+r，输入cmd，进入dos界面，然后输入ipconfig，即可查看本机IP地址。
  </p>
  <p>
   第二种方法：
  </p>
  <p>
   百度输入本机IP地址，即可查看本机IP地址。
  </p>
  <h3>
   IP分类
  </h3>
  <p>
   问过的一些公司：猿辅导(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684656816480-41321973-8c97-4ba8-a071-5fceb353f545.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   上图中黄色部分为分类号，用以区分 IP 地址类别。
  </p>
  <p>
   A类IP地址
  </p>
  <p>
   一个A类IP地址由1字节的网络地址和3字节主机地址组成，它主要为大型网络而设计的，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到127.0.0.0）。可用的A类网络有127个，每个网络能容纳16777214个主机。其中127.0.0.1是一个特殊的IP地址，表示主机本身，用于本地机器的测试。
  </p>
  <p>
   注意：
  </p>
  <ul list="uf9350812">
   <li fid="uedc940a8">
    A：0-127，其中0代表任何地址，127为回环测试地址，因此，A类IP地址的实际范围是1-126
   </li>
   <li fid="uedc940a8">
    默认子网掩码为255.0.0.0
   </li>
  </ul>
  <p>
   B类IP地址
  </p>
  <p>
   一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。
  </p>
  <p>
   注：
  </p>
  <ul list="ud04640de">
   <li fid="u98a661cb">
    B：128-191，其中128.0.0.0和191.255.0.0为保留ip，实际范围是128.1.0.0--191.254.0.0。
   </li>
  </ul>
  <p>
   C类IP地址
  </p>
  <p>
   一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。
  </p>
  <p>
   注：
  </p>
  <ul list="u9286767b">
   <li fid="ue20ae63f">
    C：192-223，其中192.0.0.0和223.255.255.0为保留ip，实际范围是192.0.1.0--223.255.254.0
   </li>
  </ul>
  <p>
   D类IP地址
  </p>
  <p>
   用于多点广播（Multicast）。 D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。224.0.0.0到239.255.255.255用于多点广播 。
  </p>
  <p>
   E类IP地址
  </p>
  <p>
   以“llll0”开始，为将来使用保留。240.0.0.0到255.255.255.254，255.255.255.255用于广播地址。
  </p>
  <p>
   全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。
  </p>
  <p>
   在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：
  </p>
  <ul list="ud89fca32">
   <li fid="u40bb37bb">
    A类地址：10.0.0.0～10.255.255.255
   </li>
   <li fid="u40bb37bb">
    B类地址：172.16.0.0～172.31.255.255
   </li>
   <li fid="u40bb37bb">
    C类地址：192.168.0.0～192.168.255.255
   </li>
  </ul>
  <h3>
   什么是子网掩码，有什么用？
  </h3>
  <p>
   可回答：1）子网掩码是什么？
  </p>
  <p>
   问过的一些公司：睿联(2022.10)，猿辅导(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   ⼦⽹掩码(subnet mask) ⼜叫做⽹络掩码，它是⼀种
   <strong>
    ⽤来指明⼀个 IP 地址的哪些位标识的是主机所在的⽹络
   </strong>
   <span class="lake-fontsize-12">
    。⼦⽹掩码是⼀个32位地址，⽤于屏蔽 IP 地址的⼀部分以区别⽹络标识和主机标识。
   </span>
  </p>
  <h3>
   局域网（LAN）中涉及的协议
  </h3>
  <p>
   问过的一些公司：快手(2022.08)，第四范式(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   用于机构内部通信与信息传递。使用以太网技术在公司或学校范围内构建网络。LAN 分为使用线缆的有线 LAN 和使用电波的无线 LAN 。一般在 LAN 内部使用私有 IP 地址。在使用线缆连接 LAN 时，用户的个人计算机通过以太网线（双绞线）连接交换机，然后由交换机连接路由器，最终在路由器处理不同子网和发送到互联网的通信。
  </p>
  <p>
   常见的协议有：TCP/IP协议、IPX/SPX协议、NetBEUI协议等。在局域网中用得的比较多的是IPX/SPX.。用户如果访问Internet，则必须在网络协议中添加TCP/IP协议。
  </p>
  <h3>
   网关作用
  </h3>
  <p>
   问过的一些公司：中望(2022.07)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   网关的作用就是对两个网络段中的使用不同传输协议的数据进行互相的翻译转换。
  </p>
  <h3>
   TCP队头阻塞，HTTP也有这个问题，怎么解决？
  </h3>
  <p>
   问过的一些公司：快手(2022.08)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   <strong>
    1、TCP对头阻塞
   </strong>
  </p>
  <p>
   TCP 的阻塞问题是因为传输阶段可能会丢包，TCP是一个按序传输的通道，一旦丢包就会等待重新发包，阻塞后续内容传输。
  </p>
  <p>
   解决方案：
  </p>
  <ul list="u0061569a">
   <li fid="ub7a05d82">
    TCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。
   </li>
   <li fid="ub7a05d82">
    比如google推出的quic协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。
   </li>
   <li fid="ub7a05d82">
    此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。
   </li>
  </ul>
  <p>
   <strong>
    2、HTTP
   </strong>
   <strong>
    对头阻塞
   </strong>
  </p>
  <p>
   <strong>
    HTTP 1.0
   </strong>
  </p>
  <p>
   <strong>
    无连接
   </strong>
  </p>
  <p>
   HTTP 1.0，是一种无状态、无连接的应用层协议。其规定浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。这可能就会引发一些问题。
  </p>
  <p>
   首先，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。
  </p>
  <p>
   其次就是队头阻塞（head of line blocking）。
  </p>
  <p>
   <strong>
    队头阻塞
   </strong>
  </p>
  <p>
   由于HTTP1.0规定下一个请求必须在前一个请求响应到达之后才能发送。假设前一个请求响应一直不到达（网络原因导致迟到或者丢失、服务器崩盘等原因），那么下一个请求就不发送，同样的后面的请求也给阻塞了。
  </p>
  <p>
   其实，队头阻塞与短连接和长连接无关（这里只是有所关联，捎带介绍），而是由 HTTP 基本的 请求 - 应答 模型所导致的。因为 HTTP 规定报文必须是 一发一收，一个 request 对应一个 response，这就形成了一个先进先出的 串行 队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1671726103141-4d7f8f19-0bf9-45ec-840f-a7cf12a83ffc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   关于队头阻塞，在 HTTP1.0 协议中没有什么具体的解决办法，之后更新为 HTTP1.1 之后有所改善。
  </p>
  <p>
   <strong>
    HTTP 1.1
   </strong>
  </p>
  <p>
   <strong>
    长连接
   </strong>
  </p>
  <p>
   HTTP1.1 增加了一个 Connection 字段，通过设置 Keep-Alive 可以保持 HTTP 连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立 TCP 连接，提高了网络的利用率。如果客户端想关闭 HTTP 连接，可以在请求头中携带 Connection: False 来告知服务器关闭请求。
  </p>
  <p>
   <strong>
    管道化
   </strong>
  </p>
  <p>
   HTTP1.1 支持请求管道化（pipelining）。基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个 HTML 页面，页面中包含了很多img，这个时候 keep-alive 就起了很大的作用，能够进行“并行”发送多个请求。这里虽然不用等待上一个请求返回 response，可以连续发送多给请求，但一个 request 对应一个 response。（注意这里的“并行”并不是真正意义上的并行传输，具体解释如下。）
  </p>
  <p>
   需要注意的是，服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。
  </p>
  <p>
   也就是说，HTTP管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684656944200-062fad97-0653-41be-b4c9-182cc6c55cd6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如图所示，客户端同时发了两个请求分别来获取 HTML 和 css，假如说服务器的 css 资源先准备就绪，服务器也会先发送 HTML 再发送 css。
  </p>
  <p>
   换句话来说，只有等到 HTML 响应的资源完全传输完毕后，css 响应的资源才能开始传输。也就是说，不允许同时存在两个并行的响应。
  </p>
  <p>
   可见，HTTP1.1 还是无法解决队头阻塞（head of line blocking）的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么就直接默认关闭，并且开启的条件很苛刻…而且实际上好像并没有什么用处。
  </p>
  <p>
   那我们在谷歌控制台看到的并行请求又是怎么一回事呢？
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2023/png/28141494/1684657082261-0d128cf2-40f7-4de2-9739-250a8016cd13.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   如图所示，绿色部分代表请求发起到服务器响应的一个等待时间，而蓝色部分表示资源的下载时间。按照理论来说，HTTP 响应理应当是前一个响应的资源下载完了，下一个响应的资源才能开始下载。而这里却出现了响应资源下载并行的情况。这又是为什么呢？
  </p>
  <p>
   其实，虽然 HTTP1.1 支持管道化，但是服务器也必须进行逐个响应的送回，这个是很大的一个缺陷。实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个 TCP 的会话。也就是说，上图我们看到的并行，其实是不同的 TCP 连接上的HTTP请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是现在的主流解决方式，才是真正的并行！
  </p>
  <p>
   <strong>
    HTTP 2.0
   </strong>
  </p>
  <p>
   <strong>
    二进制分帧
   </strong>
  </p>
  <p>
   HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能。
  </p>
  <p>
   可见，虽然HTTP2.0的协议和HTTP1.x协议之间的规范完全不同了，但是实际上HTTP2.0并没有改变HTTP1.x的语义。简单来说，HTTP2.0只是把原来HTTP1.x的header和body部分用frame重新封装了一层而已。
  </p>
  <p>
   <strong>
    多路复用
   </strong>
  </p>
  <p>
   概念
  </p>
  <p>
   流（stream）：已建立连接上的双向字节流。
  </p>
  <p>
   消息：与逻辑消息对应的完整的一系列数据帧。
  </p>
  <p>
   帧（frame）：HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）。
  </p>
  <p>
   从图中可见，所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。
  </p>
  <p>
   每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。
  </p>
  <p>
   举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着 stream id 用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据 stream id 将帧再归属到各自不同的请求当中去。
  </p>
  <p>
   另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0 里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。
  </p>
  <p>
   可见，HTTP2.0 实现了真正的并行传输，它能够在一个 TCP 上进行任意数量 HTTP 请求。而这个强大的功能则是基于 二进制分帧 的特性。
  </p>
  <h3>
   客户端发送数据到服务器端，内容发生了几次拷贝？
  </h3>
  <p>
   问过的一些公司：金山办公(2022.10)
  </p>
  <p>
   参考答案：
  </p>
  <p>
   客户端一个包发送到服务器端，一共要经过5次内存拷贝：
  </p>
  <ol list="ud507039b">
   <li fid="uc6d92f89">
    应用程序空间到系统缓存
   </li>
   <li fid="uc6d92f89">
    系统缓存到设备缓存
   </li>
   <li fid="uc6d92f89">
    设备缓存到网络上再到设备缓存
   </li>
   <li fid="uc6d92f89">
    设备缓存到系统缓存
   </li>
   <li fid="uc6d92f89">
    系统缓存到应用程序空间
    <span class="lake-fontsize-12">
     <br/>
     <br/>
    </span>
   </li>
  </ol>
  <p>
   ​
   <br/>
  </p>
  <p>
   ​
   <br/>
  </p>
  <p style="text-align: center">
   <img src="https://cdn.nlark.com/yuque/0/2022/png/12867669/1661077543035-a9c9e813-6e34-4f60-bd43-2a020969b404.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_5YWs5LyX5Y-377ya5pen5pe25YWJ5aSn5pWw5o2u%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"/>
  </p>
  <p>
   ​
   <br/>
  </p>
 </body>
</html>