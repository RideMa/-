## 计算机网络
### 协议栈
* ISO七层模型
* * 应用层：HTTP、SMTP、FTP、DNS、DHCP、SNMP
* * 表示层：对数据进行压缩、加密、描述
* * 会话层：数据交换的定界和同步功能
* * 传输层：TCP、UDP
* * 网络层：IP、ICMP、IGMP
* * 链路层：ARP、RARP
* * 物理层：光纤、Wifi、双绞铜线
* TCP/IP四层
* * 应用层
* * 传输层
* * 网络层
* * 链路层
### HTTP
* HTTP状态码
* * 1xx：提示信息，表示目前处于协议处理的中间状态、还需要后续的操作
* * 2xx：成功，报文已经收到并被正确处理
* * 3xx：重定向，资源位置发生变动，需要客户端重新发送请求
* * 4xx：客户端错误，请求报文有误，服务器无法处理
* * 5xx：服务器错误，服务器在处理请求的时候内部发生了错误
* 常见状态码
* * 200：一切正常
* * 204：No Content，没有body
* * 206：partial content，响应的body是一部分
* * 301：moved permanently永久重定向
* * 302：found 临时重定向，资源还在，要换一个url
* * 304：not modified，继续使用缓存，不具有跳转含义
* * 400：bad request 请求报文有错误
* * 403：forbidden 服务器禁止访问资源
* * 404：not found
* * 500：internal server error
* * 501：not implemented
* * 502：bad gateway服务器本身没问题，后端服务器发生了错误
* * 503：service unavailable 服务器无法响应
* 常用字段
* * host 域名
* * content-length，数据长度
* * connection，长连接
* * content-type，发送数据格式
* * accept，接受数据格式
* GET和POST
* * GET是安全和幂等的，POST是不安全，不是幂等的
* * GET如果是增删改数据，那么也不是安全的，也不是幂等了
* * GET可以带Body，POST也可以在url里指定参数
* HTTP缓存
* * cache-control，优先级高，是相对时间，没过期直接用缓存，过期了协商
* * 使用If-Modified-Since或If-Modified来进行配合，由服务器判断是否使用缓存
* * expires，是绝对时间
* HTTP/1.1
* * 优点：简单易于理解，灵活易于扩展，应用广泛，跨平台
* * 双刃剑：无状态、明文传输；
* * 无状态：服务器不需要记忆、关联操作每次都需要重新验证（cookie解决）
* * 明文传输：易于理解，不安全
* * 被窃听、被篡改、无法确认对方身份
* * 长连接，HTTP/1.1默认开启
* * 管道传输，一次发好几个HTTP请求，减少整体响应时间
* * 队头阻塞：服务器按顺序处理管道的请求，后续请求被之前的请求阻塞
* * HTTP1.1解决了请求的队头阻塞，但是没有解决响应的队头阻塞（管道也不是默认开启）
* HTTPS的区别
* 窃听风险：confidentiality
* * 混合加密：对称加密和非对称加密
* * 通信建立前使用非对称加密，建立后使用对称加密
* 篡改风险：integrity
* * 通过哈希函数计算内容的哈希值，再使用非对称加密，私钥加密的方式建立数字签名
* 冒充风险：authentity
* * 数字证书，由数字证书认证机构颁发，确定公钥可信
* SSL/TLS握手
* RSA算法和ECDHE算法
* * RSA握手
* * 客户端发送TLS版本，客户端随机数，客户端支持的密码套件列表
* * 服务端确定TLS版本，发送服务端随机数，确认密码套件列表，发送数字证书
* * 客户端验证数字证书，取出公钥，加密报文，发送一个随机数，通告加密通信改变，客户端握手结束（计算出会话秘钥，随后都使用会话秘钥），发送一个内容摘要
* * 服务端收到pre-master，算出会话秘钥，回复通信改变，发送一个内容摘要
* * RSA算法存在前向安全问题，如果服务器私钥泄露，会被破解所有密文
* * ECDHE握手
* * * 分解质因数算法无法快速进行
* * * ECDHE算法和私钥没关系，每次重新算
* * * 双方都确定好使用那种椭圆曲线，和曲线上的基点，双方各自随机选取一个随机数作为私钥，与基点相乘得到公钥，双方交换公钥，椭圆曲线上的点满足乘法交换律和结合律，双方x一样，就共享了秘钥
* * * ECDHE只要一个RTT的握手时间
* * * 第一次握手发送TLS版本号、支持的密码套件和随机数
* * * 第二次握手发送TLS版本号、选择的密码套件、随机数、公钥、证书
* * * 第三次握手，客户端用服务端公钥自己的公钥私钥、椭圆曲线算出来，根据x，客户端随机数、服务端随机数算出来会话秘钥，发送开始保密，做个摘要
* * * 第四次握手开始保密，做个总结；在第三次握手就可以发数据了
* * * RSA在四次握手之后才能发数据，ECDHE第三次握手就可以发了（这个抢跑按理来说RSA好像也可以。但是不知道为啥不行）
* TLS 3.0
* * 只用1个RTT就可以开始传输数据了，因为在第一个握手就发出去了自己的椭圆曲线和对应的公钥
* HTTPS优化
* * 握手优化，用ECHDE，用特殊的椭圆曲线，特殊的对称加密算法
* * 证书优化，用椭圆曲线证书
* * 硬件优化，CPU支持解密加密
* * 证书验证优化，CA的缓存
* * 会话复用，双方缓存会话秘钥，用session ID或者session Ticket
* * * session ID有可能下次不是同一个服务器，session Ticket发送加密的秘钥给客户端，下一次客户端发送回服务器，服务器解密了就可以恢复了
* * * 都不具备前向安全性，还难以防止回访攻击，中间人重复最后一次操作
* * pre-shared key把ticket发给服务器，同时发HTTP请求，同样面临重放攻击的问题
* 数字证书验证
* * 数字证书内容通过hash算法，再私钥加密得到签名，客户端通过hash算法对内容计算H1，并利用公钥解密签名得到H2，比较H1和H2是否一致
* 如果一个中间人转发所有信息，他也是无法得到内容的，因为没有私钥，没法解密服务器公钥加密的内容
* * 如果中间人发送的是自己的证书，那么其证书不可信，也无法骗过客户端（certificate transparency）
* * 抓包工具是把伪造的证书直接放在操作系统里，因此被信任
* * 避免中间人抓取数据，使用HTTPS双向认证的方式。
* HTTP1的缺点
* * 请求/响应头没有压缩
* * 发送冗长的头部
* * 服务器按顺序响应，造成队头阻塞
* * 没有请求优先级控制
* * 请求只能从客户端开始，服务器只能被动响应
* HTTP/1.1如何优化
* * 尽量避免发送HTTP请求
* * * 缓存技术：304状态码
* * * cache-control
* * 在需要发送的时候，考虑如何减少请求次数
* * * 减少重定向次数：代理服务器不直接返回重定向，而是查询后端结果后直接返回结果
* * * 合并请求：减少头部，合并图片
* * * 延迟发送请求：不需要的先不发
* * 减少服务器的HTTP响应的数据大小
* * * 有损压缩（WebP，增量），无损压缩（编码）
* HTTP2
* 优化
* * 头部压缩：HPACK算法，在客户端和服务器同时维护一张头信息表，之后发送索引号
* * * 静态表61个，key直接二进制编码，value用huffman编码
* * * 动态表发送了先缓存，以后就发编号
* * 二进制格式，头信息和数据体都是帧，使用Huffman编码
* * 并发传输，引入stream的概念，多个stream复用在一个TCP连接中，stream用ID来标识，不同stream的帧可以乱序发送，并行交错地发送请求和响应
* * 一个stream可以有多个message，一个message可以有多个frame
* * 服务器可以主动推送，充分利用TCP的全双工，服务器stream ID是偶数
* 缺点
* * TCP的字节是完整连续的，如果发生丢包，后续都要阻塞，也就是HTTP2如果一个stream丢包，其他stream也会阻塞，这还是队头阻塞
* HTTP3
* * 基于UDP，使用QUIC实现可靠性传输（不是简单的TCP迁移）
* * QUIC无队头阻塞，更快的连接建立，连接可以迁移
* * 每个stream丢包的时候只会阻塞这个流，无队头阻塞
* * 握手自带TLS1.3，一个RTT就可以建立连接与秘钥协商
* * 恢复连接的时候可以把数据和连接信息+TLS信息一起发送，达到0-RTT的效果
* * 使用连接ID标识通信的两个端点，IP地址变化也可以无缝复用原连接
* * QUIC的包有序列号，可以精确计算RTT，可以乱序确认
* RPC
* * RPC基于TCP
* * 调用远程的函数
* * gRPC，thrift
* * HTTP要用DNS找到IP地址，RPC一般是中间服务保存服务名和IP名
* * RPC用连接池，用完放回去，使用TCP长连接
* * HTTP头部，body较为冗余，RPC定制化强，在公司内部微服务有时候会用RPC
* * HTTP/2可能性能比RPC还好
* WebSocket
* * 长轮询：将超时调大，服务器收到了请求就返回（扫码立刻返回，主动推送）
* * RocketMQ消费者取数据也用到了这种方式
* * WebSocket要从HTTP在头部加上字段，升级成WebSocket，101状态码
* * 升级以后就和HTTP没关系了，用特定的头进行通信，是全双工的，可以服务器主动推送
### TCP
* 面向连接、可靠、基于字节流
* 序列号：SYN和FIN给序列号加1
* TCP不能项UDP一对多
* 唯一确定一个TCP，四元组：源IP地址、源端口、目标IP地址、目标端口
* 最大TCP并发数收到文件描述符（系统级、用户级、内存级）和内存的限制
* TCP和UDP的区别
* * TCP面向连接，是一对一的，UDP不连接，可以一对多，多对多
* * TCP有拥塞控制和流量控制，UDP没有
* * TCP头部比较长，固定20字节，选项更长；UDP8字节（源端口号、目标端口号、包长度、校验和）
* * TCP会自己分片，UDP不会，利用IP分片
* * * TCP如果不自己分片的话，如果利用IP分片，丢了一个分片，那么后面到达目标主机就全丢了
* * * TCP自己分片要在我收的时候协商双方的MSS值
* * TCP没有包长度，可以直接算出来（减去IP头部和TCP头部），UDP有，虽然没啥用，但是可能是为了应对不同的网络层协议，或者4字节对齐
* TCP和UDP可以用同一个端口，操作系统用不同的模块来处理
* TCP三次握手：SYN，SYN/ACK，ACK
* * 开始都是close状态，服务器监听某个端口，进入listen
* * 客户端随机初始化序列号，发送SYN（SYN标志位设为1），进入SYN-SENT状态
* * 服务器收到以后随机初始化序列号，ACKNUM设置成客户端的序列号加1，发送SYN/ACK（SYN和ACK标志位为1），进入SYN-RCVD状态
* * 客户端把ACKNUM设置成服务器的序列号加1，发送ACK，进入ESTABLISHED状态
* * 服务端收到以后进入ESTABLISHED状态
* * 第三次握手是可以带数据的
* 为什么不能是两次握手？
* * 为了阻止重复历史连接的初始化
* * * 如果只有两次握手，那么收到SYN就要进入ESTABLISHED状态。如果旧的SYN因为网络延迟了，客户端重发，旧的先到，那么服务器就会建立连接，收到新的SYN之后就会ack，客户端RST，需要再重发
* * * 如果新的SYN先到，旧的后到，服务器就会challenge ack，客户端会RST
* * * 避免历史连接其实就避免了浪费资源
* * 同步双方序列号
* * * 回复一个ACK确保双方的初始序列号都能同步
* * * 四次握手也没必要，因为SYN/ACK就可以了
* * 避免资源浪费
* TCP初始化序列号
* * 如果每次都是从0开始的话，那么很容易就会重复，那么历史连接发送的数据就很以后可能被后续连接接受（只要序列号在窗口范围内）
* * 序列号初始化的时候是ISN每4微妙加一，然后根据四元组有一个函数出一个数相加。转一圈要4.55小时，会用完，还是无法用序列号判断历史报文（TIME-WAIT）
* 握手丢失
* * 第一次握手丢失：重发SYN，序列号不变，tcp_syn_retries参数，默认5，第一次1秒，后面每次翻倍
* * 第二次握手丢失：客户端以为SYN丢失，重发，服务端以为SYN/ACK丢失，重发，SYN/ACK重发参数tcp_synack_retries，默认5，重发时间类似
* * 第三次握手丢失：服务端重发SYN/ACK，超时断开连接
* SYN攻击，SYN泛洪攻击
* * 发送大量SYN报文，进入半连接队列，使得后续请求无法处理
* * 避免：增大网络包缓存队列，增大半连接队列，开启net.upv4.tcp_syncookies(0 关,1 满了用,2 直接用)，减少重传SYN/ACK的数量（减小tcp_synack_retries）
* TCP四次挥手
* * 客户端发送FIN，序列号加1，进入FIN_WAIT_1状态
* * 服务端收到进入CLOSE_WAIT状态，发送ACK，这时候服务端还是能发送数据，客户端收到进入CLOSE_WAIT_2状态
* * 等服务端发完了数据，就发送FIN过去，客户端收到进入TIME_WAIT状态，返回ACK
* * 服务端收到ACK直接close
* * 当服务器没有数据发，并且启用了TCP延迟确认机制，服务端直接发FIN/ACK，成三次握手
* * 为什么普通时候不要FIN/ACK一起发
* * * 因为ACK不耗时间，代价很小，跟数据一起发过去
* * * 还会导致客户端重发，以为没收到FIN
* * * TCP内核不知道啥时候数据才发完，等着发FIN不合适
* TCP挥手丢失
* * 第一次丢失，客户端重发，超时直接close
* * 第二次丢失，客户端服务端重发，超时直接close（如果使用shutdown，关闭读方向，收到了ACK会一直处在FIN_WAIT_2状态）
* * 第三次丢失，服务端重发，超时直接close，服务端FIN_WAIT_2只等2MSL
* * 第四次丢失，服务端重发，客户端重发，由于每次FIN都会重置2MSL计时器，所以需要服务器那边重发间隔大于2MSL或者服务器超时关了，才能结束
* 为什么要有TIME_WAIT
* * TIME_WAIT等待2MSL，是为了确保报文已经消失在网络里了
* * 这样可以防止历史连接中的数据被后续四元组接收，下一个TCP连接得2MSL之后建立，那么包都已经消失了（虽然有初始序列号，但是其会回环，数据少没啥，大量数据会很快回环，没法判断新老数据）
* * 可以保障服务端正确关闭，就算第四次握手丢失了，也可以收到重发的一次FIN，就可以重发一个ACK
* TIME_WAIT太多的危害
* * 客户端会占用端口资源（tcp_tw_reuse，tcp_tw_recycle）
* * 服务端占用文件描述符，内存资源，CPU资源，线程资源等
* TIME_WAIT优化
* * tcp_tw_reuse，只能客户端用，内核会找一个time_wait超过1s的连接给新的用
* * tcp_timestamps，用时间戳来判断，就不用time_wait了，回环及其慢
* * 直接发RST（太暴力了）
* 服务端有大量TIME_WAIT状态的原因
* * HTTP没有使用长连接，只要一方没有开，都需要服务端关闭连接，就会产生大量TIME_WAIT
* * HTTP长连接超时，nginx 60s没请求就断开
* * HTTP长连接请求数量达到上限，nginx会主动关闭，高并发很容易出现
* 服务端出现大量CLOSE_WAIT
* * 没有调用close关闭连接
* * * TCP服务流程：创建服务端socket，bind端口，listen端口
* * * 注册socket到epoll
* * * epoll_wait等待，连接时调用accept获取已连接socket
* * * 将已连接socket注册到epoll
* * * epoll_wait等待事件发生
* * * 连接关闭时调用close
* * 如果没有注册到epoll，服务器没法感知连接，就没有close
* * 如果么有accept，类似
* * 如果连接没有注册到epoll，也没法感知事件，没法close
* * 没有正常执行close
* 客户端、服务端发生故障
* * 进程崩溃操作系统会正常回收资源，发送挥手消息
* * 如果宕机了，web服务软件会有超时事件，nginx默认60s
* * TCP保活，7200s没有任何连接相关活动，就会启动保活；发送探测报文，间隔75s，9次之后才认为不可达，时间很长。
* * 如果目标端口还能用，收到保活探测报文，就会发RST
* listen的backlog参数，在2.2之前是半连接队列最大长度，后来是全连接队列最大长度，不过还有个内核参数somaxconn限制，所以是这两的较小值
* 没有accept怎么建立TCP连接
* * 没有accept也是正常握手，但是不会被应用程序捕捉
* * 半连接队列是个哈希表，全连接队列是个链表，握手完就放全连接队列里
* 没有listen怎么建立TCP连接
* * 服务器端不listen，就会RST
* * 在回环地址没有listen也可以建立TCP连接
* * 可以connet自己本身bind的端口
* TCP重传
* * 超时重传
* * * 超时时间选择超时重发时间应当略大与RTT
* * * RTT是动态变化的，首次计算，后续计算RTO要根据最新测量的进行平滑，并且计算方差
* * * 每当遇到一次超时重传的时候都要将下一次超时时间间隔设为先前值的两倍，两次超时则说明网络环境差，不适宜频繁重发
* * * 超时重传默认是15次，可以改tcp_retries2
* * * tcp+retires1和tcp_retries2一起计算一个timeout，当重传时间（每次乘2）超过timeout的时候就会断开
* * 快速重传
* * * 收到三次相同的ACK就触发快速重传，如果两次相同的ACK就重传，可能是后续的先到了，这很常见，不一定是丢包了
* * * 重传一个还是重传所有都有问题，快速重传穿多了效率低，传少了可能出问题
* * SACK
* * * 选择重传，在TCP里加入SACK的头，将已经收到的数据信息发给发送方，SACK可以告诉发送方哪一段已经收到了
* * Duplicate SACK
* * * 使用SACK告诉发送方那些数据被重复接受了
* * * 就是ACK后面的，SACK前面的，表述重复了
* * * 好处是：让发送方知道了是丢包还是丢了ACK，是不是发送方的包延迟了，或者复制了
* 滑动窗口
* * 一次把窗口内的都发出去，一个一个发很慢
* * 窗口大小在TCP头部有字段，接收端要比发送方大，这样不会接受不过来
* * 发送方根据接收方返回的ACK中的窗口大小字段调整窗口大小
* 流量控制
* * 如果接收方处理不过来，其接受的包就会保存在缓冲区里，那么其窗口就会减小
* * 返回的ACK中指出窗口减小了，发送方就也会减小窗口
* * 为了防止丢包，TCP要求先收缩窗口再减小缓存，这样发送方就不会一下发来太多东西
* * 当窗口为0的时候，发送方会定期发送窗口报文，否则会死锁
* * 如果接收方好不容易腾出来几个字节，发送方就发过去几个字节，这会造成浪费，因为头部太大了
* * 可以当窗口大小小于一个阈值的时候就通报为0，或者发送方等到窗口大小和数据大小都大于阈值才发送，或者收到ACK包才发送
* * 单独一种方式没法避免糊涂窗口综合征
* 拥塞控制
* * 拥塞窗口会随着网络拥塞成都而变化
* * swnd=min（rwnd, cwnd）
* * 慢启动（比拥塞避免快）
* * * 每收到一个ACK，cwnd增加1
* * * 这样就是指数级增长
* * * 到达ssthresh的时候转为拥塞避免
* * 拥塞避免，一般为65535
* * * 每收到一个ACK，cwnd增加1/cwnd
* * * 这样就是线性增长的
* * 拥塞发生
* * * 如果发生了超时重传，那么情况比较严重，ssthred变成cwnd/2，cwnd设置为1
* * * 如果是快速重传，那就把cwnd设置成原来的一半，然后把ssthred设置成cwnd，后面还是拥塞避免算法
* TCP快速建立连接 fast_open
* * 在第一次请求的时候带上cookie，第二次在SYN报文直接带上HTTP请求
* TCP优化
* * TCP三次握手优化
* * * 减少丢包重发的次数
* * * 增大半连接队列长度（同时增大backlog和somaxconn）
* * * 增大全连接队列长度，同上
* * * 使用syncookies
* * * 减少重传SYN/ACK的次数
* * * fast open
* * TCP四次挥手优化
* * * 主动方减少重发FIN的次数
* * * tcp_tw_reuse参数优化timewait（客户端）
* * * tcp_tw_recycle（在NAT下有问题）
* * TCP传输数据优化
* * * 自动调节缓冲区大小
* * * 调节TCP内存大小
* TCP粘包
* * TCP是面向字节流的，消息会被拆成多个包，用户就不知道消息的边界在哪
* * 拆分边界：固定长度消息，特殊字符作为边界，自定义消息结构（一个struct，填满就是边界）
* 什么情况下会丢弃SYN报文
* * 半连接队列满了又没有开启syncookies
* * 全连接队列满了，也会丢弃后续请求
* * timewait太多把端口号都占了
* * tcp_tw_recycle会比较对于一个ip地址，包是否是有序的，但是NAT环境下，不同客户端同样的ip，不一样的端口，所以很有可能会丢弃SYN报文
* TCP已经有连接的端口收到一个SYN，会返回一个challenge ack，客户端再发一个RST，结束连接
* * 可以利用这个来伪造一个四元组，以及序列号，从而关闭tcp连接
* TCP如果第三次的FIN发送过来乱序了，其实无所谓，因为TCP会保障有序，不会有啥问题的
* time wait状态收到了SYN
* * 如果SYN的序号比服务端期望下一个收到的序列号大，时间戳也大，那么会立刻重用四元组
* * 如果SYN序列号比预期序列号小，或者时间戳小，会再回复一个第四次握手的ACK，客户端会发现序号不对，回复RST
* * time wait收到RST是否会断开连接需要看一个参数
* 拔掉网线还是有TCP连接的
* * 如果传输数据了，那么在最大重试次数之后就关闭了
* * 如果不传数据了，就要靠TCP 保活机制了
* tcp_tw_reuse为什么是默认关闭
* * 只在客户端有用
* * RST就算过期了也应该被接受，开启了tcp_tw_reuse可能会收到过期的RST，导致资源浪费
* * 如果第四次握手的ack丢了，被动方重传SYN/ACK，那么重用了的四元组会RST，导致资源浪费
* TCP三次握手和TLS四次握手同时进行
* * 一般来说是不行了
* * 要是使用了TCP fast open和TLS 1.3，在第二次通信的时候，TCP直接带着cookies和data一起，TLS1.3也可以会话恢复就可以了
* TCP的缺陷
* * 升级困难
* * 握手太慢
* * 队头阻塞
* * TLS无法对TCP头部加密，如果攻击者可以仿造一个RST
* * 网络迁移需要重新连接TCP连接
* 重启TCP会遇到address already in use
* * 因为上一个在time wait
* * 开启SO_REUSEADDR就可以bind同一个在time wait的端口
* 为啥不都开启syn_cookies
* * cookies需要消耗CPU，攻击者会伪造一大堆ACK，编一大堆cookies，消耗CPU
### IP
* 本地广播：子网掩码之外的部分全部设置成1
* 直接广播：目标子网掩码之外的部分全部设置成1
* 多播地址：把包发给特定组内的所有主机，D类地址，前四位1110
* IP分片之后，如果一个片丢失，整个包就都无了
* IPv6不用DHCP也能自动分配IP地址，头部固定40字节，去掉了校验和
* IPv6有应对伪造IP地址的网络安全功能以及防止线路窃听的功能
* DNS域名解析
* * DNS是层级结构，根域DNS服务器、顶级域DNS服务器、权威DNS服务器
* * 所有DNS服务器都保存了根域DNS服务器的信息
* * 用UDP传输
* * 客户发送一个DNS请求，问某个域名的IP是啥，发给本地DNS服务器（客户端的TCP/IP设置中填写的DNS服务器地址）
* * 本地DNS服务器收到客户请求之后，如果缓存有，就直接返回，否则区分它的上级DNS服务器
* * 上级服务器没有缓存，问再上级，直到根服务器，根服务器不解析，发现是.com的，于是告诉它去.com服务器找
* * 本地DNS服务器收到根服务器告诉的位置之后，去问.com，.com是顶级域名服务器，告诉本地服务器去权威找
* * 本地直到权威的地址之后，去问权威。权威告诉本地IP地址是X.X.X.X
* * 本地DNS告诉客户端IP地址
* ARP
* * 确定MAC地址
* * 主机广播ARP请求，请求包含了想要直到MAC地址的设备的IP地址
* * 同一个链路中的设备都收到了ARP请求，只有IP地址和自己的一致才会回复自己的MAC地址
* * MAC地址有一定的时限，过期了会被清除
* RARP
* * 知道MAC地址，问IP地址
* * 设备发送我的MAC地址是XXXX，我的IP地址应该是什么？
* * RARP服务器返回MAC地址为XXXX的设备，你的IP地址是X.X.X.X
* DHCP
* * 动态分配IP地址
* * DHCP客户端监听68端口，服务器监听67端口
* * 客户端发起DHCP发现报文，使用UDP广播，源地址为0.0.0.0(68)，目标地址为255.255.255.255(67)
* * DHCP服务器发现了报文以后，向客户端做出响应，目标地址还是广播地址：255.255.255.255(67)，源地址是DHCP服务器地址
* * 报文携带服务器提供可租约的IP地址，子网掩码，默认网关，DNS服务器以及IP地址租用期
* * 客户端收到一个或者多个DHCP服务器的请求以后，选择一个服务端进行响应，回显配置的参数
* * 服务端收到用DHCP报文对DHCP请求进行响应，应答所要求的参数
* * 如果租约到底，客户端会发送DHCP报文，服务器同意继续，就会ACK，否则NACK
* * 如果DHCP服务器和客户端不在一个子网内，那需要通过中继代理进行中继单播，中继代理是个路由器，收到DHCP单播给DHCP服务器，广播给DHCP客户端
* NAT
* * 把不同的私有IP都转换成IP地址为公有IP，配备不同的端口号作为区分
* * NAPT路由器转换表，将端口和转换地址进行结合
* * TCP建立SYN，就会生成这个表，关闭连接FIN的应答，就会从表里删除
* * 外部无法主动与NAT内部服务器建立连接，因为NAPT没有转换记录
* * 转换表的生成与转换操作都会产生性能开销
* * NAT路由器要是重启了，所有的TCP连接都会被重置
* * 使用IPv6就不用NAT了
* * NAT穿透技术：NAT之后的应用主动配合NAT设备的操作，主动建立好映射，主动获取公有IP地址，自己建立端口映射条目，用这个条目对外通信
* ICMP
* * 确认IP包是否成功送达目标地址，报告发送过程中IP包被废弃的原因和改善网络设置等
* * 没达到的IP包由ICMP通知：A给B发包，路由器找不到B，就返回一个ICMP告诉A
* IGMP
* * 路由器之间是组播路由协议，最后一跳路由器和主机之间是IGMP，组播成员管理协议
* * IGMP报文向路由器申请加入和退出组播组，默认路由器是不发给主机的，除非主机通过IGMP加入了组播组
* * IGMP报文采用IP封装，IP头部协议号为2，TLL设置为1