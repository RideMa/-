## MySQL
### MySQL执行流程
* 连接器
* * 连接MySQL服务，通过TCP连接进行
* * 连接器会获取用户的权限等，可以使用show processlist看有多少个连接
* * 空闲的连接超过8小时就会自动断开，也可以用kill connection 来断开
* * 也有长连接和短连接之分，区别就是是否执行一个SQL就断开
* 缓存
* * 连接器发来的SQL会先在缓存中查找是否存在
* * 由于缓存不是很好用，MySQL8.0之后就删掉了
* 解析器
* * 词法分析语法分析，判断SQL是否正确
* * 这里不查询是否表或字段存在
* 预处理器
* * 查询表或者字符是否存在
* * 把*扩展成所有列
* 优化器
* * 负责确定执行方案
* * 优化器选择索引、选择是否使用索引、是否全表扫描、是否回表等
* 执行器
* * 执行语句，和存储引擎交互
* * 主键索引查询：调用read_first_record函数指针，把条件传给InnoDB，不断循环
* * 全表扫描：还是那个函数，读取记录，条件由执行器来判断
* * 索引下推：如果联合索引失效了，那么需要回表查询，然后由执行器判断条件，但是判断条件的列其实也是联合索引的一部分，就可以使用索引下推，就不需要执行器来判断，交给存储引擎来做（可以减少回表的次数）
* * * 索引下推的时候，存储引擎判断条件不符合就不回表了
* * * 判断条件的列使用了函数就没办法下推了
* * * 有子查询也没办法下推
### MySQL行存储结构
* MySQL在Linux里存在/var/lib/mysql底下
* * 一个库就有一个文件夹，一个table就有三个文件
* * 一个是db.opt是存储默认字符集和字符校验规则
* * 一个是.frm保存表的元数据
* * 一个是.ibd是表的数据
* 表空间文件的结构
* * 表->段->区->页->行
* * 记录按行存储
* * 页是I/O的最小单元，默认一个页大小是16kb，B+树的结点就是页
* * 为了让B+树的节点之间物理存储位置连续一下，就有区，一个区1mb，64个页
* * 段是多个区，分为数据段、索引段、回滚段
* 行格式
* * 分为Redundant、Compated、Dynamic和Compressed
* * Compact多用，其有记录额外信息和记录真实信息两个部分组成
* * 记录额外信息包括三个部分：变长字段长度列表、NULL值列表、记录头信息
* * * 变长字段长度列表是对varchar的长度进行记录，在行中会倒序存放，每个长度两个字节或一个字节（倒序是为了长度和靠前的数据在同一个CPU cache里）
* * * NULL长度列表是一个Bitmap，也是倒序的，每8个可能有空就多一个字节
* * * 记录头信息，记录是否被删除，下一条记录的指针，记录类型（叶子结点、最小记录、最大记录、非叶子结点）
* * 记录真实信息
* * * 三个隐藏字段，roll_id，trx_id，roll_ptr
* * * 一个是自增主键，如果建表的时候指定了就没这个了，6 bytes
* * * trx_id是修改这一行的事务的id，6 bytes
* * * roll_ptr是mvcc的上一个版本的指针，7 bytes
* * varchar(n) n最大是多少
* * * 一行记录加起来最大65535
* * * 如果单一字段，加上可变长度是2 bytes，加上NULL的bitmap 1 byte，可以存65532
* * * 多个字段要看可变长度，和NULL
* * 行溢出
* * * 一页16374kb，比如说TEXT和BLOB都可能溢出，就需要存在另外的溢出页
* * * compacted是这一行保存一部分，其他用指针指过去，Dynamic和Compressed是直接指向溢出页地址
### MySQL索引
* InnoDB默认B+树索引，还支持full-text索引，MyISAM也是
* B+树索引
* * 节点里多个数据，数据按照主键顺序存放，B+树叶子结点是单向链表（MySQL是双向）
* * 查询的时候通过一个节点的主键值范围查找到对应的叶子结点
* * B+树的优势，层数少，磁盘I/O次数少，并且比B树更适合范围查找（叶子结点双向链表）
* * B+树一层通过设置超过1000个节点，所以在2000w行以内基本都是3-4层，比HASH也更是和范围查询
* * B+树二级索引是再建立一个B+树，其叶子结点存储的是索引的值和主键ID，查询如果不止这两个列的话，就要回表，即查到了主键ID再回聚簇索引里找
* * 不用回聚簇索引里找就叫索引覆盖
* * 主键默认是第一个UNIQUE NOT NULL
* * 没有就自增ID
* * 前缀索引：用字符类型字段的前几个字符建立的索引
* 联合索引
* * 即多个字段联合建立的索引
* * 联合索引的最左匹配原则
* * 因为联合索引建立的时候是按照顺序的，第一个全局有序，第二个在第一个一样的情况下有序
* * 所以如果不按顺序进行查询，就是无序的查询，没法利用联合索引，就会索引失效
* * 而如果第一个使用了范围查询，后面可能就没法用联合索引了
* * * 如果第一个使用了小于等于或大于等于，后面的在等于的情况其实是可以用的，不会从等于的第一个开始遍历，而是等于且满足第二个条件的那个节点开始遍历
* * * 使用Between and也是类似于有等于的情况
* * * like j%其实也是可以用的，就是会从满足第二个的首个节点开始遍历
* * * 如果第一个使用了大于或小于，以及其他范围查询，后面的就不能用了
* * * 使用左或者左右模糊匹配就啥索引都用不了like %xx%或者%xx
* 索引区分度
* * 建立联合索引的时候要把区分度大的放前面
* * $区分度=\frac{distinct(column)}{count(*)}$如果区分度小，比如说男女，比例达到30%以上，MySQL就会直接忽略索引，全表扫描
* 建立索引问题
* * 占用空间大
* * 维护代价高
* * 创建速度慢
* 适用与不适用建立索引的情况
* * 适用
* * 唯一性字段
* * 经常使用where比较的字段
* * 经常使用Group by和Order by的字段
* * 不适用
* * 区分度小
* * where group by order by用不着的字段
* * 表的数据少的时候
* * 经常更新的字段
* 索引优化
* * 前缀索引优化
* * * 减少空间，一个页更多索引，提高速度
* * * order by没法用，没法用覆盖索引
* * 覆盖索引优化
* * * 覆盖了就不用回表了
* * 主键最好是自增的
* * * 这样每次插入都是append，不需要移动数据
* * * 否则可能涉及页分裂等问题，可能造成内存碎片，影响查询效率
* * 索引最好NOT NULL
* * * NULL会使得优化器不好处理
* * * NULL还要占据额外的物理存储空间
* explain执行计划参数
* * possible_keys，可能用的索引
* * key，字段实际用的索引
* * key_len，索引长度
* * rows，扫描的数据行数
* * type，数据扫描类型
* * * 效率排行：ALL-Index-range-ref-eq_ref-const
* * Extra，是否用了额filesort，temporary，index