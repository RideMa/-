## Redis
* redis是内存数据存储引擎，可以用作数据库、缓存、消息队列和分布式锁等
* redis有String、Hash、Set、Zset、Bitmap、Hyperloglog、GEO、Stream
* 数据操作是原子性的
* redis支持事务、持久化、Lua脚本、多种集群方式、发布/订阅模式、内存淘汰机制、过期删除机制等等
### Redis和Memcache有什么区别
* 都是高性能内存数据库，一般用来做缓存，都有过期替换策略
* Redis数据结构更丰富，Memcache只有key-value
* Redis支持持久化，Memcache断电就没了
* Redis支持集群化，Memcache依靠客户端实现往集群里写入数据
* Redis支持订阅模型、Lua脚本、事务等
### Redis作为MySQL的缓存
* MySQL QPS很难突破1w，Redis可以轻松突破10w
* 请求从Redis读取数据，没有再从MySQL加载数据到Redis
* 缓存一致性问题通过先修改，再删除，部分解决
### Redis数据类型的应用场景
* String：缓存对象、常规计数、分布式锁、共享session信息等
* List：消息队列（生产者需要自行实现全局唯一ID、不能以消费组的形式消费数据）
* Set：聚合计算的场景，比如点赞、关注、抽奖活动等
* Zset：排序场景，排行榜、热搜、电话和姓名排序等
* Bitmap：二值状态统计的场景、用户登录状态、签到、连续签到的人数
* HyperLoglog：海量数据统计、百万级网页uv计数
* GEO：LBS
* Stream：消息队列，相比List，自动生成全局唯一ID，可以用消费组的形式消费数据
### Redis数据类型的实现
* String基于SDS
* * 动态简单字符串，不仅可以保存文本还可以保存二进制
* * 获取字符串长度的代价是O（1）
* * SDS API是安全的，拼接字符串不会造成缓冲区溢出
* List基于双向链表或压缩列表
* * 小于512个，列表每个元素的值都小于64字节，使用压缩列表
* * 其他使用双向链表
* * redis3.2之后List底层都是quicklist实现的
* Hash是压缩列表或哈希表
* * 哈希类型元素小于512个，每个都小于64字节，使用压缩列表
* * 其他用哈希表
* * redis 7.0之后压缩列表被listpack取代了
* Set是压缩列表或跳表
* * 元素个数小于128个，每个都小于64字节，用压缩列表
* * 其他用跳表
* * 7.0以后压缩列表被listpack取代
* Zset用压缩列表或跳表
* * 和Set一样
* GEO用ZSET实现
* Bitmap
* HyperLogLog
* Stream
### Redis线程模型
* Redis单线程指的是接受客户端请求、解析请求、进行数据读写操作、发送数据到客户端时主线程完成的
* redis会启动后台进行，2.6以前俩，处理关闭文件、AOF刷盘；4.0之后加了一个，lazyfree异步释放Redis内存
* 删除大key的时候，使用del命令会使得主线程阻塞，要用unlink
* 主线程会把BIO_CLOSE_FILE队列放要关闭的任务，BIO_AOF_FSYNC放要AOF刷盘的任务，BIO_LAZY_FREE放要释放内存的任务，后台线程从队列里面取出任务，进行处理
* 主线程再6.0以前的模型：
* * 注册I/O多路复用epoll，把socket都注册进去
* * epoll_wait等待，发现任务以后进行分发
* * 连接事件用accept，再注册socket
* * 读事件用read，解析命令、执行命令、添加到发送队列，执行结果加入缓存
* * 写事件，调用write，如果一轮没法玩，注册一个写事件函数到epoll，epoll发现可以写的时候下一轮接着发（每次循环都会写，处理epoll发现的事件后要写一轮）
* Redis使用单线程模型是因为CPU不是Redis性能表现的瓶颈所在，更多情况受内存和网络I/O的限制
* 并且可维护性高，多线程可能增加程序复杂性、同时存在线程切换、加锁、解锁等带来的性能损耗
* Redis6.0之后的多线程模型
* * 采用多个I/O线程处理网络请求，因为网络I/O硬件设备的提升使得其瓶颈可能再网络I/O上
* * 可以将I/O性能提高1倍以上
* * 推荐4核CPU，2-3个I/O线程（主线程也算）
* * redis 6.0之后默认额外开启6个线程，前三个一样：关闭文件、AOF刷盘、Lazyfree，还有三个io_thd分担网络I/O压力
### Redis为什么这么快
* redis都在内存中完成，采用了高效的数据模型
* redis使用单线程模型，避免了多线程之间的竞争，省去了线程切换的时间和性能开销
* redis使用I/O多路复用机制处理大量的socket，
### Redis持久化
* AOF日志
* * 每执行一次写操作之后，就把命令以追加的方式写入一个文件里
* * \*3的意思是命令有3个部分，$3是这个部分有几个字符
* * 先执行命令再写入日志到数据库
* * * 这样可以避免额外的检查开销，如果是错的就不用写日志了
* * * 不会阻塞当前的写操作
* * * 但是数据可能会丢失（写日志之前断电）
* * * 可能阻塞其他操作（主线程写AOF文件，还是会阻塞后续操作）
* * AOF写操作有三种写回策略
* * * always：总是，每次操作之后都刷盘
* * * everysec，每秒把写命令输刷盘
* * * No，redis不管，操作系统决定啥时候刷盘
* * AOF重写
* * * 如果AOF文件太大了，就会重写
* * * 读取每一个键值对，把其写为一个AOF命令，用新的代替旧的文件
* * * 使用后台子进程bgrewriteaof来实现，这样可以不用阻塞主进程
* * * 子进程有数据副本，并且由于cow，父子进程数据安全，其副本不会变，父进程还可以继续操作
* * * 主进程执行期间的把命令写道AOF缓冲区，并且写到AOF重写缓冲区
* * * 完事了把新的覆盖旧的就行了（期间还是要写旧的，防止失败）
* RDB快照
* * 把某一时刻的内存数据以二进制写入磁盘
* * 有save和bgsave，前者阻塞，后者不阻塞
* * 可以用命令save num1 num2来定期执行，num1秒内对数据库至少进行了num2次修改就快照
* * 子进程进行RDB的时候还是可以操作的
* 混合持久化
* * 再AOF文件重写的时候，fork的子进程会先RDB写入AOF文件，然后主线程处理的操作命令会被记录再重写缓冲区，写完以后以增量的形式写在AOF后面
* * 之后AOF文件就变成了前一部分是RDB，后面是AOF
* * 优点：可以结合RDB的优点，快速启动，又可以结合AOF有点，丢失少
* * 缺点：AOF文件加入了RDB可读性差，兼容不了redis4.0之前的版本
### Redis集群
* redis主从复制
* * 主服务器可以读写，从服务器只有读取，
* * 由于从服务器复制过程是异步的，因此不是强一致性
* 哨兵模式
* * 哨兵可以监控主从节点的故障，从而控制其故障转移
* 切片模式
* * 一个服务器无法处理，就用多个服务器，对数据库进行切片
* * redis cluster方案中，一个切片集群有16538个哈希槽
* * 根据key得到一个hash值，然后模16538，得到映射
* * 哈希槽的分配可以是平均或者手动指定等
* 脑裂
* * 主节点和哨兵失联，哨兵认为其挂了，新指定一个节点
* * 但是主节点还是可以更客户端通信，于是还在读写
* * 这时候新选了一个主节点，就有俩主节点了
* * 这样重新连回来的时候就会把数据覆盖掉了
* * 解决方法：必须有至少x个从节点可以通信才写数据，t时间内必须有x个回信
* * 没法完全解决，需要抽屉原理才行

